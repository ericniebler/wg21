---
title: "High-Quality Sender Diagnostics with Constexpr Exceptions"
document: D3557R3
date: today
audience:
  - "LWG Library Working Group"
author:
  - name: Eric Niebler
    email: <eric.niebler@gmail.com>
toc: true
---

<div style="text-align: right;">
_"Only the exceptional paths bring exceptional glories!"_<br/>
--- Mehmet Murat Ildan
</div>

Introduction
============

The hardest part of writing a sender algorithm is often the computation of its
completion signatures, an intricate meta-programming task. Using sender
algorithms incorrectly leads to large, incomprehensible errors deep within the
completion-signatures meta-program. What is needed is a way to propagate type
errors automatically to the API boundary where they can be reported concisely,
much the way exceptions do for runtime errors.

Support for exceptions during constant-evaluation was recently accepted into the
Working Draft for C++26. We can take advantage of this powerful new feature to
easily propagate type errors during the computation of a sender's completion
signatures. This significantly improves the diagnostics users are likely to
encounter while also simplifying the job of writing new sender algorithms.

Executive Summary
=================

This paper proposes the following changes to the working draft with the
addition of [@P3164R4]. Subsequent sections will address the motivation
and the designs in detail.

1. Change `std::execution::get_completion_signatures` from a customization
  point object that accepts a sender and (optionally) an environment to
  a `consteval` function template that takes no arguments, as follows:

::: cmptable

### Before
```cpp
inline constexpr struct get_completion_signatures_t {
  template <class Sndr, class... Env>
  auto operator()(Sndr&&, Env&&...) const -> @_`see below`_@;
} get_completion_signatures {};
```

### After
```cpp
template <class Sndr, class... Env>
consteval auto get_completion_signatures()
  -> @_`valid-completion-signatures`_@ auto;
```

:::

2. Change the mechanism by which senders customize `get_completion_signatures`
  from a member function that accepts the _cv_-qualified sender object and an
  optional environment object to a `static constexpr` function template that
  take the sender and environment types as template parameters.

::: cmptable

### Before
```cpp
struct my_sender {
  template <class Self, class... Env>
    requires @_`some-predicate`_@<Self, Env...>
  auto get_completion_signatures(this Self&&, Env&&) {
    return completion_signatures</* … */>();
  }
  ...
};
```

### After
```cpp
struct my_sender {
  template <class Self, class... Env>
  static constexpr auto get_completion_signatures() {
    if constexpr (!@_`some-predicate`_@<Self, Env...>) {
      throw @_`a-helpful-diagnostic`_@(); // <--- LOOK!
    }
    return completion_signatures</* … */>();
  }
  ...
};
```

:::

3. Change the `sender_in<Sender, Env...>` concept to test that
  `get_completion_signatures<Sndr, Env...>()` is a constant expression.

::: cmptable

### Before
```cpp
template<class Sndr, class... Env>
concept sender_in =
  sender<Sndr> &&
  (queryable<Env> &&...) &&
  requires (Sndr&& sndr, Env&&... env) {
    { get_completion_signatures(
        std::forward<Sndr>(sndr),
        std::forward<Env>(env)...) }
            -> @_`valid-completion-signatures`_@;
  };
```

### After
```cpp
template <auto>
concept @_`is-constant`_@ = true; // exposition only

template<class Sndr, class... Env>
concept sender_in =
  sender<Sndr> &&
  (queryable<Env> &&...) &&
  @_`is-constant`_@<get_completion_signatures<Sndr, Env...>()>;
```

:::

4. In the exposition-only _`basic-sender`_ class template, specify under what
  conditions its `get_completion_signatures` static member function is
  ill-formed when called without an `Env` template parameter (see proposed
  wording for details).

5. Add a `dependent_sender` concept that is modeled by sender types that do not
  know how they will complete independent of their execution environment.

6. Remove the `transform_completion_signatures` alias template (to be later
  replaced with a `consteval` function that does the same job and that throws
  on error).


Revision History
================

R2
----

* Move the nice-to-haves into a separate paper (TBD).

* Drop support for specifying a sender's completion signatures with a nested
  type alias.

* Promote the exposition-only _`dependent-sender-error`_ class to
  `std::execution::dependent_sender_error`.

* Change ```@_`basic-sender`_@::@_`check-types`_@``` and all its customizations
  from `constexpr` to `consteval`.

* Merge the proposed wording of [@P3164R4] into this paper's proposed wording
  for ease of wording review.

R1
----

Since R0, a significant fraction of C++26's `std::execution` has been
implemented with the design changes proposed by this paper. Several bugs in R0
have been found and fixed as a result.

In addition, this paper exposed [several
bugs](https://github.com/cplusplus/sender-receiver/issues/317) in the Working
Draft for C++26. As those bugs relate to the computation of completion
signatures, R1 integrates the proposed fixes for those bugs.

* Fix the specification of `std::execution::get_completion_signatures` which was
  the victim of an incomplete last-minute edit.
* Add support for awaitables, which was dropped accidentally, back to
  `get_completion_signatures`.
* Change proposed replacement for `transform_completion_signatures` to take
  a transform function for the stopped completion signature instead of
  a `completion_signatures` object.
* Add missing semantic constraints to ```@_`impls-for`_@<Tag>::@_`check-types`_@```
  customizations.
* Add missing syntactic constraint on ```@_`basic-sender`_@<Tag>::get_completion_signatures```.
* Strengthen the _Mandates_ on `std::execution::connect`.
* Fixed the constraint on `stopped_as_optional.transform_sender(sndr, env)`.
* Report type errors from the `let_*`, `schedule_from`, `into_variant`, `split`,
  and `when_all` algorithms when the prececessor's result datums cannot be
  copied into intermediate storage.
* Add proposed wording for the nice-to-have features:
  - `eptr_completion_if`
  - `make_completion_signatures`
  - `transform_completion_signatures` (a `constexpr` function version)
  - `invalid_completion_signature`
* Integrate proposed fix for [cplusplus/sender-receiver#311](https://github.com/cplusplus/sender-receiver/issues/311),
  "`stopped_as_optional` tests constraints satisfaction of self instead of child".
* Integrate proposed fix for [cplusplus/sender-receiver#317](https://github.com/cplusplus/sender-receiver/issues/317),
  "Several algorithms are not applying _`FWD-ENV`_ as they should".
* Integrate proposed fix for [cplusplus/sender-receiver#318](https://github.com/cplusplus/sender-receiver/issues/318),
  "specification of `as-sndr2(Sig)` in [exec.let]{.sref} is incomplete".
* Integrate proposed fix for [cplusplus/sender-receiver#319](https://github.com/cplusplus/sender-receiver/issues/319),
  "`let_[*].transform_env` is specified in terms of the `let_*` sender itself instead of its child".
* Fix paragraph numbering.

R0
----

* Initial revision

Motivation
==========

This paper exists principly to improve the experience of users who make type
errors in their sender expressions by leveraging exceptions during constant-
evaluation. It is a follow-on of [@P3164R4], which defines a category of
"non-dependent" senders that can and must be type-checked early.

Senders have a construction phase and a subsequent connection phase. Prior to
P3164, all type-checking of senders happened at the connection phase (when a
sender is connected to a receiver). P3164 mandates that the sender algorithms
type-check non-dependent senders, moving the diagnostic closer to the source of
the error.

This paper addresses the _quality_ of those diagnostics, as well as the diagnostics users
encounter when a dependent sender fails type-checking at connection time.

Senders are expression trees, and type errors can happen deep within their
structure. If programmed naively, ill-formed senders would generate megabytes of
incomprehensible diagnostics. The challenge is to report type errors _concisely_
and _comprehensibly_, at the right level of abstraction.

Doing this requires propagating domain-specific descriptions of type errors out
of the completion signatures meta-program so they can be reported concisely.
Such error detection and propagation is very cumbersome in template
meta-programming.

The C++ solution to error propagation is exceptions. With the adoption of
[@P3068R6], C++26 has gained the ability to throw and catch exceptions during
constant-evaluation. If we express the computation of completion signatures as a
`constexpr` meta-program, we can use exceptions to propagate type errors. This
greatly improves diagnostics and even simplifies the code that computes
completion signatures.

This paper proposes changes to `std::execution` that make the computation
of a sender's completion signatures an evaluation of a `constexpr` function.
It also specifies the conditions under which the computation is to exit
with an exception.

Example
-------

How good are `std::execution`'s diagnostics with `constexpr` exceptions? Let's
consider a user that makes a simple mistake in their sender expression:

> ```c++
> using stdex = std::execution;
> auto sndr = stdex::just(42) | stdex::then([]() { /*…*/ });
> ```

This is an error because the nullary lambda cannot be called with the integer that
`just(42)` completes with.

With `constexpr` exceptions, the resulting diagnostic is blissfully direct:

### With `constexpr` exceptions:

<blockquote>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">
<span><b>&lt;source&gt;:658:3: <span style="color:red">error: </span>call to immediate function 'operator|&lt;_basic_sender&lt;just_t, _tupl&lt;nullptr, int&gt;&gt;&gt;'
is not a constant expression</b></span>
 2212 |   <span style="color:blue">auto</span> sndr = just(<span style="color:green">42</span>) | then([](){});
      |             <b><span style="color:green">  ^</span></b>
<span><b>&lt;source&gt;:658:3: <span style="color:cyan">note:</span></b> 'operator|&lt;_basic_sender&lt;just_t, _tupl&lt;nullptr, int&gt;&gt;&gt;' is an immediate function
because its body contains a call to an immediate function '_make_sender&lt;then_t, (lambda at &lt;source&gt;:2212:
31), _basic_sender&lt;just_t, _tupl&lt;nullptr, int&gt;&gt;&gt;' and that call is not a constant expression
 1912 |       <span style="color:blue">return</span> transform_sender(dom, _make_sender(Algorithm, std::move(_self.data_), sndr));
      |                                  <b><span style="color:green"> <b><span style="color:green"> ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></b></span></b>
<span><b>&lt;source&gt;:658:3: <span style="color:cyan">note:</span></b> unhandled exception of type '_sender_type_check_failure&lt;const char *, <span style="background-color:yellow">IN_ALGORITHM&lt;
then&gt;, WITH_FUNCTION ((lambda at &lt;source&gt;:2212:31)), WITH_ARGUMENTS (int)&gt;' with content {{{}}, &amp;"The fun
ction passed to std::execution::then is not callable with the values sent by the predecessor sender."[<span style="color:green">0</span>]}</span>
thrown from here
  876 |     <span style="color:blue">throw</span> _sender_type_check_failure&lt;Values...[<span style="color:green">0</span>], What...&gt;(values...);
      |           <b><span style="color:green">^</span></b></code></pre></div>
</blockquote>


The above is the _complete_ diagnostic, regardless of how deeply nested the type error is.

In contrast, the following is the diagnostic we get without `constexpr` exceptions. Notice
that the backtrace is truncated; the actual error is considerably longer.

### Without `constexpr` exceptions:

<blockquote style="font-size:85%">
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">
<b>&lt;source&gt;:1912:36: <span style="color:red">error:</span> call to immediate function 'operator|&lt;_basic_sender&lt;just_t, _tupl&lt;nullptr, int&gt;&gt;&gt;' is not a constant 
expression</b>
 2212 |   <span style="color:blue">auto</span> sndr = just(<span style="color:green">42</span>) | then([](){});
      |              <b><span style="color:green"> ^</span></b>
<b>&lt;source&gt;:1912:36: <span style="color:cyan">note:</span></b> 'operator|&lt;_basic_sender&lt;just_t, _tupl&lt;nullptr, int&gt;&gt;&gt;' is an immediate function because its body cont
ains a call to an immediate function '_make_sender&lt;then_t, (lambda at &lt;source&gt;:2212:31), _basic_sender&lt;just_t, _tupl&lt;nullptr, 
int&gt;&gt;&gt;' and that call is not a constant expression
 1912 |       <span style="color:blue">return</span> transform_sender(dom, _make_sender(Algorithm, std::move(_self.data_), sndr));
      |                                   <b><span style="color:green"> ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></b>
<b>&lt;source&gt;:876:5: <span style="color:cyan">note:</span></b> subexpression not valid in a constant expression
  876 |     <span style="color:blue">throw</span> _sender_type_check_failure&lt;Values...[<span style="color:green">0</span>], What...&gt;(values...);
      |    <b><span style="color:green"> ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></b>
<b>&lt;source&gt;:1990:16: <span style="color:cyan">note:</span></b> in call to 'invalid_completion_signature&lt;IN_ALGORITHM&lt;then&gt;, WITH_FUNCTION ((lambda at &lt;source&gt;:2212:3
1)), WITH_ARGUMENTS (int), const char *&gt;(&amp;"The function passed to std::execution::then is not callable with the values sent by
 the predecessor sender."[<span style="color:green">0</span>])'
 1990 |         <span style="color:blue">return</span> invalid_completion_signature&lt;IN_ALGORITHM&lt;then&gt;,
      |               <b><span style="color:green"> ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></b>
 1991 |                                             <span style="color:blue">struct</span> WITH_FUNCTION(Fn),
      |                                            <b><span style="color:green"> ~~~~~~~~~~~~~~~~~~~~~~~~~</span></b>
 1992 |                                             <span style="color:blue">struct</span> WITH_ARGUMENTS(As...)&gt;(
      |                                            <b><span style="color:green"> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></b>
 1993 |         "The function passed to std::execution::then is not callable with the"
      |        <b><span style="color:green"> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></b>
 1994 |         " values sent by the predecessor sender.");
      |        <b><span style="color:green"> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></b>
<b>&lt;source&gt;:885:10: <span style="color:cyan">note:</span></b> in call to 'fn.operator()&lt;int&gt;()'
  885 |   <span style="color:blue">return</span> fn.template operator()&lt;As...&gt;();
      |         <b><span style="color:green"> ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></b>
<b>&lt;source&gt;:897:12: <span style="color:cyan">note:</span></b> in call to '_transform_expr&lt;int, _impls_for&lt;then_t&gt;::(lambda at &lt;source&gt;:1988:5)&gt;(fn..)'
  897 |     <span style="color:blue">return</span> ::_transform_expr&lt;As...&gt;(fn);
      |           <b><span style="color:green"> ^~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></b>
<b>&lt;source&gt;:923:14: <span style="color:cyan">note:</span></b> in call to '_apply_transform&lt;int, _impls_for&lt;then_t&gt;::(lambda at &lt;source&gt;:1988:5)&gt;(fn..)'
  923 |       <span style="color:blue">return</span> _apply_transform&lt;Ts...&gt;(value_fn);
      |             <b><span style="color:green"> ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></b>
<b>&lt;source&gt;:930:13: <span style="color:cyan">note:</span></b> in call to 'transform1.operator()&lt;set_value_t, int&gt;(nullptr)'
  930 |     <span style="color:blue">return</span> (transform1(sigs) +...+ completion_signatures());
      |            <b><span style="color:green"> ^~~~~~~~~~~~~~~~</span></b>
<b>&lt;source&gt;:804:12: <span style="color:cyan">note:</span></b> (skipping 6 calls in backtrace; use -fconstexpr-backtrace-limit=<span style="color:green">0</span> to see all)
  804 |     <span style="color:blue">return</span> fn(_normalized_sig_t&lt;Sigs&gt;()...);
      |           <b><span style="color:green"> ^</span></b>
<b>&lt;source&gt;:1206:31: <span style="color:cyan">note:</span></b> in call to 'get_completion_signatures&lt;_basic_sender&lt;then_t, (lambda at &lt;source&gt;:2212:31), _basic_sende
r&lt;just_t, _tupl&lt;nullptr, int&gt;&gt;&gt;&gt;()'
 1206 |     <span style="color:blue">return</span> _CHECKED_COMPLSIGS(_GET_COMPLSIGS(Sndr, Env...));
      |           <b><span style="color:green"> ~~~~~~~~~~~~~~~~~~~</span></b>^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<b>&lt;source&gt;:1188:3: <span style="color:cyan">note:</span></b> expanded from macro '_GET_COMPLSIGS'
 1188 |   std::remove_reference_t&lt;Sndr&gt;::template get_completion_signatures&lt;Sndr __VA_OPT__(,) __VA_ARGS__&gt;()
      |  <b><span style="color:green"> ^</span></b>
<b>&lt;source&gt;:1190:34: <span style="color:cyan">note:</span></b> expanded from macro '_CHECKED_COMPLSIGS'
 1190 | #define _CHECKED_COMPLSIGS(...) (__VA_ARGS__, ::_checked_complsigs&lt;decltype(__VA_ARGS__)&gt;())
      |                                 <b><span style="color:green"> ^~~~~~~~~~~</span></b>
<b>&lt;source&gt;:1230:10: <span style="color:cyan">note:</span></b> in call to '_get_completion_signatures_helper&lt;_basic_sender&lt;then_t, (lambda at &lt;source&gt;:2212:31), _bas
ic_sender&lt;just_t, _tupl&lt;nullptr, int&gt;&gt;&gt;&gt;()'
 1230 |   <span style="color:blue">return</span> _get_completion_signatures_helper&lt;Sndr&gt;();
      |         <b><span style="color:green"> ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></b>
<b>&lt;source&gt;:1872:12: <span style="color:cyan">note:</span></b> in call to 'get_completion_signatures&lt;_basic_sender&lt;then_t, (lambda at &lt;source&gt;:2212:31), _basic_sende
r&lt;just_t, _tupl&lt;nullptr, int&gt;&gt;&gt;&gt;()'
 1872 |     (void) get_completion_signatures&lt;Sender&gt;();
      |           <b><span style="color:green"> ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></b>
<b>&lt;source&gt;:1912:36: <span style="color:cyan">note:</span></b> in call to '_make_sender&lt;then_t, (lambda at &lt;source&gt;:2212:31), _basic_sender&lt;just_t, _tupl&lt;nullptr, in
t&gt;&gt;&gt;({{}}, {}, {{}, {}, {{<span style="color:green">42</span>}}})'
 1912 |       <span style="color:blue">return</span> transform_sender(dom, _make_sender(Algorithm, std::move(_self.data_), sndr));
      |                                   <b><span style="color:green"> ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></b>
<b>&lt;source&gt;:2212:15: <span style="color:cyan">note:</span></b> in call to 'operator|&lt;_basic_sender&lt;just_t, _tupl&lt;nullptr, int&gt;&gt;&gt;({{}, {}, {{<span style="color:green">42</span>}}}, {{}})'
 2212 |   <span style="color:blue">auto</span> sndr = just(<span style="color:green">42</span>) | then([](){});
      |              <b><span style="color:green"> ^~~~~~~~~~~~~~~~~~~~~~~</span></b></code></pre></div>
</blockquote>


The code that generated these diagnostics can be found
[here](https://gist.github.com/ericniebler/0896776ab1c8f5b7f77d7094c0400df5) or at
[https://godbolt.org/z/rPEqWz693](https://godbolt.org/z/rPEqWz693)


Proposed Design
===============

`get_completion_signatures`
---------------------------

In the Working Draft, a sender's completion signatures are determined by the
type of the expression `std::execution::get_completion_signatures(sndr, env)`
(or, after P3164, `std::execution::get_completion_signatures(sndr)` for
non-dependent senders). Only the type of the expression matters; the expression
itself is never evaluated.

In the design proposed by this paper, the `get_completion_signatures` expression
must be constant-evaluated in order use exceptions to report errors. To
make it ammenable to constant evaluation, it must not accept arguments with
runtime values, so the expression is changed to
`std::execution::get_completion_signatures<Sndr, Env...>()`, where
`get_completion_signatures` is a `consteval` function.

If an unhandled exception propagates out of `get_completion_signatures` the
program is ill-formed (because `get_completion_signatures` is `consteval`). The
diagnostic displays the type and value of the exception.

`std::execution::get_completion_signatures<Sndr, Env...>()` in turn calls
```remove_reference_t<Sndr>::template get_completion_signatures<Sndr, Env...>()```,
which computes the completion signatures or throws as appropriate, as shown below:

> ```cpp
> namespace exec = std::execution;
>
> struct void_sender {
>   using sender_concept = exec::sender_t;
>
>   template <class Self, class... Env>
>   static constexpr auto get_completion_signatures() {
>     return exec::completion_signatures<exec::set_value_t()>();
>   }
>
>   /* … more … */
> };
> ```

To better support the `constexpr` value-oriented programming style, calls to
`std::execution::get_completion_signatures` from a `constexpr` function are never
ill-formed, and their return type is always a specialization of the
`completion_signatures` template. `std::execution::get_completion_signatures` reports
errors by failing to be a constant expression.

### _Non_-non-dependent senders

[@P3164R4] introduces the concept of non-dependent senders: senders that have
the same completion signatures regardless of the receiver's execution
environment. For a sender type `DependentSndr` whose completions _do_ depend on
the environment, what should happen when the sender's completions are queried
without an environment? That is, what should the semantics be for
`get_completion_signatures<DependentSndr>()`?

`get_completion_signatures<DependentSndr>()` should follow the general rule: it
should be well-formed in a `constexpr` function, and it should have a
`completion_signatures` type. That way, sender adaptors do not need to do
anything special when computing the completions of child senders that are
dependent. So `get_completion_signatures<DependentSndr>()` should throw.

If `get_completion_signatures<Sndr>()` throws for dependent senders, and it also
throws for non-dependent senders that fail to type-check, how then do we
distinguish between valid dependent and invalid non-dependent senders? We can
distinguish by checking the type of the exception.

An example will help. Consider the `read_env(q)` sender, a dependent sender that
sends the result of calling `q` with the receiver's environment. It cannot
compute its completion signatures without an environment. The natural way for
the `read_env` sender to express that is to require an `Env` parameter to its
customization of `get_completion_signatures`:

> ```cpp
> namespace exec = std::execution;
>
> template <class Query>
> struct read_env_sender {
>   using sender_concept = exec::sender_t;
>
>   template <class Self, class Env> // NOTE: Env is not optional!
>   static constexpr auto get_completion_signatures() {
>     if constexpr (!std::invocable<Query, Env>) {
>       throw @_`exception-type-goes-here`_@();
>     } else {
>       using Result = std::invoke_result_t<Query, Env>;
>       return exec::completion_signatures<exec::set_value_t(Result)>();
>     }
>   }
>
>   /* … more … */
> };
> ```

That makes `read_env_sender<Q>::get_completion_signatures<Sndr>()` an ill-formed
expression, which the `get_completion_signatures` function can detect. In such
cases, it would throw an exception of a special type that it can catch later
when distinguishing between dependent and non-dependent senders.

### Implementation

Since the design has several parts, reading the implementation of
`get_completion_signatures` is probably the easiest way to understand it. The
implementation is shown below with comments describing the parts.

> ```cpp
> // This macro expands to an invocation of SNDR's get_completion_signatures
> // customization.
> #define GET_COMPLSIGS(SNDR, ...) std::remove_reference_t<SNDR>::template      \
>     get_completion_signatures<SNDR __VA_OPT__(,) __VA_ARGS__>()
>
> // This macro expands to an evaluation of EXPR, followed by an invocation
> // of the _checked_complsigs function which validates its type.
> #define CHECK_COMPLSIGS(EXPR) (EXPR, _check_complsigs<decltype(EXPR)>())
>
> // This helper ensures that the passed type is indeed a specialization of the
> // completion_signatures class template, and throws if it is not.
> template <class Completions>
> consteval auto _check_complsigs() {
>   if constexpr (@_`valid-completion-signatures`_@<Completions>)
>     // We got a type that is a specialization of the completion_signatures
>     // class template representing the sender's completions. Return it.
>     return Completions();
>   else
>     // throw unconditionally but make sure the return type is deduced to
>     // be `completion_signatures<>`. That way, a sender adaptor can ask
>     // a child for its completions and take for granted that the return
>     // type is a specialization of `completion_signatures<>`
>     return (throw @_`unspecified`_@, completion_signatures());
> }
>
> template <class Sndr, class... Env>
> consteval auto _get_completion_signatures_helper() {
>   // The following `if` tests whether GET_COMPLSIGS(Sndr, Env...)
>   // is a well-formed expression.
>   if constexpr (requires { GET_COMPLSIGS(Sndr, Env...); }) {
>     // The GET_COMPLSIGS(Sndr, Env...) expression is well-formed, but it may
>     // throw an exception or otherwise fail to be a constant expression.
>     // By evaluating it, we cause its exception and its non-constexpr-ness to
>     // propagate. Then CHECK_COMPLSIGS ensures that its type is indeed
>     // a specialization of the completion_signatures class template.
>     return CHECK_COMPLSIGS(GET_COMPLSIGS(Sndr, Env...));
>   }
>   // The following `if` does the same as above, but for GET_COMPLSIGS(Sndr).
>   // A non-dependent sender may announce itself by way of this signature.
>   else if constexpr (requires { GET_COMPLSIGS(Sndr); }) {
>     // Same as above: propagate any exceptions and non-constexpr-ness, and
>     // verify the expression has the right type.
>     return CHECK_COMPLSIGS(GET_COMPLSIGS(Sndr));
>   }
>   // We can't recognize Sndr as a sender proper, but maybe it is awaitable,
>   // in which case we can adapt it to be a sender.
>   else if constexpr (@_`is-awaitable`_@<Sndr, @_`env-promise`_@<Env>...>) {
>     return completion_signatures<
>       @_`SET-VALUE-SIG`_@(@_`await-result-type`_@<Sndr, @_`env-promise`_@<Env>...>),  //  ([exec.snd.concepts]{.sref})
>       set_error_t(exception_ptr),
>       set_stopped_t()>();
>   }
>   // If none of the above expressions are well-formed, then we don't know
>   // the sender's completions. If we are testing without an environment, then
>   // we assume Sndr is a dependent sender. Throw an exception that
>   // communicates that.
>   else if constexpr (sizeof...(Env) == 0) {
>     return (throw dependent_sender_error(), completion_signatures());
>   }
>   else {
>     // We cannot compute the completion signatures for this sender and
>     // environment. Give up and throw an exception.
>     return (throw @_`unspecified`_@, completion_signatures());
>   }
> }
>
> template <class Sndr>
> consteval auto get_completion_signatures() -> _valid_completion_signatures auto {
>   // There is no environment, which means we are asking for the sender's non-
>   // dependent completion signatures. If the sender is dependent, this will
>   // exit with a special exception type.
>   return _get_completion_signatures_helper<Sndr>();
> }
>
> template <class Sndr, class Env>
> consteval auto get_completion_signatures() -> _valid_completion_signatures auto {
>   // Apply a lazy sender transform if one exists before computing the completion signatures:
>   using Domain = decltype(_get_domain_late(std::declval<Sndr>(), std::declval<Env>()));
>   using NewSndr = decltype(transform_sender(Domain(), std::declval<Sndr>(), std::declval<Env>()));
>
>   return _get_completion_signatures_helper<NewSndr, Env>();
> }
> ```

Given this definition of `get_completion_signatures`, we can implement
a `dependent_sender` concept as follows:

> ```cpp
> // Returns true when get_completion_signatures<Sndr>() throws a
> // dependent_sender_error or a type dereived from it. Returns false when
> // get_completion_signatures<Sndr>() returns normally (Sndr is non-dependent).
> template <class Sndr>
> consteval bool @_`is-dependent-sender-helper`_@() try {
>   (void) get_completion_signatures<Sndr>();
>   return false;
> } catch (dependent_sender_error&) {
>   return true;
> }
>
> // If get_completion_signatures<Sndr>() throws an exception other than
> // dependent_sender_error, then @_`is-dependent-sender-helper`_@<Sndr>() will
> // fail to be a constant expression and so 2ill not be a valid non-type
> // template parameter to bool_constant. Therefore, dependent_sender<Sndr> will
> // be false.
> template <class Sndr>
> concept dependent_sender =
>   sender<Sndr> &&
>   bool_constant<@_`is-dependent-sender-helper`_@<Sndr>()>::value;
> ```

After the adoption of [@P3164R4], the sender algorithms are all required to
return senders that are either dependent or else that type-check successfully.
This paper proposes adding that type-checking as a _Mandates_ on the
exposition-only _`make-sender`_ function template that all the algorithms use
to construct their return value.

Users who define their own sender algorithms can use `dependent_sender`
and `get_completion_signatures` to perform early type-checking of their
own sender types using a helper such as the following:

> ```cpp
> template <class Sndr>
> constexpr auto _type_check_sender(Sndr sndr) {
>   if constexpr (!dependent_sender<Sndr>) {
>     // This line will fail to compile if Sndr fails its type checking. We
>     // don't want to perform this type checking when Sndr is dependent, though.
>     // Without an environment, the sender doesn't know its completions.
>     (void) get_completion_signatures<Sndr>();
>   }
>   return sndr;
> }
> ```

Using this helper, a `then` algorithm might type-check its returned senders as
follows:

> ```cpp
> inline constexpr struct then_t {
>   template <sender Sndr, class Fn>
>   auto operator()(Sndr sndr, Fn fn) const {
>     return _type_check_sender(_then_sender{std::move(sndr), std::move(fn)});
>   }
> } then {};
> ```

`sender_in`
-----------

With the above changes, we need to tweak the `sender_in` concept to require
that `get_completion_signatures<Sndr, Env...>()` is a constant expression.

The changes to `sender_in` relative to [@P3164R4] are as follows:

> ```cpp
> @[`template <auto>`]{.add}@
>   @@[`concept @_is-constant_@ = true; // exposition only`]{.add}@@
>
> template<class Sndr, class... Env>
>   concept sender_in =
>     sender<Sndr> &&
>     (sizeof...(Env) <= 1)
>     (queryable<Env> &&...) &&
>     @@[`@_is-constant_@<get_completion_signatures<Sndr, Env...>()>;`]{.add}@@
>     @[`requires (Sndr&& sndr, Env&&... env) {`]{.rm}@
>       @[`{ get_completion_signatures(std::forward<Sndr>(sndr), std::forward<Env>(env)...) }`]{.rm}@
>         @@[`-> @_valid-completion-signatures_@;`]{.rm}@@
>     @[`};`]{.rm}@
> ```

_`basic-sender`_
----------------

The sender algorithms are expressed in terms of the exposition-only class
template _`basic-sender`_. The mechanics of computing completion signatures is
not specified, however, so very little change there is needed to implement this
proposal.

We do, however, have to say when
```@_`basic-sender`_@::get_completion_signatures<Sndr>()``` is
ill-formed. In [@P3164R4], non-dependent senders are dealt with by discussing
whether or not a sender's potentially-evaluated completion operations are
dependent on the type of the receiver's environment. In this paper, we make a
similar appeal when specifying whether or not
```@_`basic-sender`_@::get_completion_signatures<Sndr>()``` is
well-formed.

`dependent_sender`
------------------

Users who write their own sender adaptors will also want to perform early
type-checking of senders that are not dependent. Therefore, they need a way
to determine whether or not a sender is dependent.

In the section [`get_completion_signatures`](#get_completion_signatures) we show
how the concept `dependent_sender` can be implemented in terms of this paper's
`get_completion_signatures` function template. By making this a public-facing
concept, we give sender adaptor authors a way to do early type-checking, just
like the standard adaptors.

Implementation Experience
=========================

A significant fraction of `std::execution` has been implemented with this design
change. It can be found on [Compiler Explorer](https://godbolt.org/z/rPEqWz693)[^1] and in
[this GitHub gist](https://gist.github.com/ericniebler/0896776ab1c8f5b7f77d7094c0400df5)[^2].
This implementation includes all the design elements that would stress the completion
signature computation including:

* Both dependent and non-dependent senders and sender adaptors, with tests for
  both early and late diagnosis of type errors.

* The exposition-only _`basic-sender`_ has been implemented with the changes
  `get_completion_signatures` customization syntax and the new
  ```@_`impls-for`_@<Tag>::@_`check-types`_@``` customization, which has been
  used to implement and type-check all the sender types, as specified.

* A sender that is implemented via a lowering to another sender type via a
  lazy `transform_sender` customization (`stopped_as_optional`).

* Using awaitables as senders and _vice versa_.

[^1]: [https://godbolt.org/z/rPEqWz693](https://godbolt.org/z/rPEqWz693)
[^2]: [https://gist.github.com/ericniebler/0896776ab1c8f5b7f77d7094c0400df5](https://gist.github.com/ericniebler/0896776ab1c8f5b7f77d7094c0400df5)

Proposed Wording
================

[This wording is relative to the current working draft with the addition of
[@P3164R4]]{.ednote}

[Change [async.ops]/13 as follows:]{.ednote}

> [13]{.pnum} A <dfn>completion signature</dfn> is a function type that describes a
> completion operation. An asychronous operation has a finite set of possible completion
> signatures corresponding to the completion operations that the asynchronous operation
> potentially evaluates ([basic.def.odr]). For a completion function `set`, receiver
> `rcvr`, and pack of arguments `args`, let `c` be the completion operation `set(rcvr,
> args...)`, and let `F` be the function type `decltype(auto(set))(decltype((args))...)`.
> A completion signature `Sig` is associated with `c` if and only if
> ```@_`MATCHING-SIG`_@(Sig, F)``` is `true` ([exec.general]{.sref}). Together, a sender type and
> an environment type `Env` determine the set of completion signatures of an asynchronous
> operation that results from connecting the sender with a receiver that has an
> environment of type `Env`. The type of the receiver does not affect an asychronous
> operation’s completion signatures, only the type of the receiver’s environment. [A
> <dfn>non-dependent sender</dfn> is a sender type whose completion signatures are
> knowable independent of an execution environment.]{.add}


[Change [execution.syn] as follows:]{.ednote}

> <b>Header `<execution>` synopsis [execution.syn]</b>
>
> ```cpp
> namespace std::execution {
>   @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
>
>   template<class Sndr, class@[`...`]{.add}@ Env @[`= env<>`]{.rm}@>
>     concept sender_in = @ _see below_ @;
>
>   @[`template<class Sndr>`{.cpp}]{.add}@
>     @@[`concept dependent_sender = @ _see below_@;`{.cpp}]{.add}@@
>
>   template<class Sndr, class Rcvr>
>     concept sender_to = @ _see below_@;
>
>   template<class... Ts>
>     struct @_`type-list`_@;                                           // exposition only
>
>   @[`// [exec.getcomplsigs]{.sref}, completion signatures`]{.rm}@
>   @[`struct get_completion_signatures_t;`]{.rm}@
>   @[`inline constexpr get_completion_signatures_t get_completion_signatures {};`]{.rm}@
>
>   @[`This alias is moved below and modified.`]{.ednote}@
>   @[`template<class Sndr, class... Env>`]{.rm}@
>       @[`requires sender_in<Sndr, Env...>`]{.rm}@
>     @@[```using completion_signatures_of_t = @_`call-result-t`_@<get_completion_signatures_t, Sndr, Env...>;```]{.rm}@@
>
>   template<class... Ts>
>     using @_`decayed-tuple`_@ = tuple<decay_t<Ts>...>;                // exposition only
>
>   @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
>
>   template<class Sndr, class@[`...`]{.add}@ Env>
>     using @_`single-sender-value-type`_@ = @_`see below`_@;               // exposition only
> 
>   template<class Sndr, class@[`...`]{.add}@ Env>
>     concept @_`single-sender`_@ = @_`see below`_@;                        // exposition only
> 
>   @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
>
>   // [exec.util]{.sref}, sender and receiver utilities
>   // [exec.util.cmplsig]{.sref} @[`completion signatures`]{.add}@
>   template<class Fn>
>     concept @_`completion-signature`_@ = @_`see below`_@;                   // exposition only
>
>   template<@_`completion-signature`_@... Fns>
>     struct completion_signatures @[`{}`]{.rm}@;
>
>   template<class Sigs>
>     concept @_`valid-completion-signatures`_@ = @_`see below`_@;            // exposition only
>
>   @[`struct dependent_sender_error : exception {};`]{.add}@
>
>   @[`// [exec.getcomplsigs]{.sref}`]{.add}@
>   @[`template<class Sndr, class... Env>`]{.add}@
>     @@[```consteval auto get_completion_signatures() -> @_`valid-completion-signatures`_@ auto;```]{.add}@@
>
>   @[`template<class Sndr, class... Env>`]{.add}@
>       @[`requires sender_in<Sndr, Env...>`]{.add}@
>     @[`using completion_signatures_of_t = decltype(get_completion_signatures<Sndr, Env...>());`]{.add}@
>
>   @@[`// [exec.util.cmplsig.trans]{.sref}`]{.rm}@@
>   @@[`template<`]{.rm}@@
>     @@[```@_`valid-completion-signatures`_@ InputSignatures,```]{.rm}@@
>     @@[```@_`valid-completion-signatures`_@ AdditionalSignatures = completion_signatures<>,```]{.rm}@@
>     @@[```template<class...> class SetValue = @_`see below`_@,```]{.rm}@@
>     @@[```template<class> class SetError = @_`see below`_@,```]{.rm}@@
>     @@[```@_`valid-completion-signatures`_@ SetStopped = completion_signatures<set_stopped_t()>>```]{.rm}@@
>   @@[```using transform_completion_signatures = completion_signatures<@_`see below`_@>;```]{.rm}@@
>
>   @@[`template<`]{.rm}@@
>     @@[`sender Sndr,`]{.rm}@@
>     @@[`class Env = env<>,`]{.rm}@@
>     @@[```@_`valid-completion-signatures`_@ AdditionalSignatures = completion_signatures<>,```]{.rm}@@
>     @@[```template<class...> class SetValue = @_`see below`_@,```]{.rm}@@
>     @@[```template<class> class SetError = @_`see below`_@,```]{.rm}@@
>     @@[```@_`valid-completion-signatures`_@ SetStopped = completion_signatures<set_stopped_t()>>```]{.rm}@@
>       @@[`requires sender_in<Sndr, Env>`]{.rm}@@
>   @@[`using transform_completion_signatures_of =`]{.rm}@@
>     @@[`transform_completion_signatures<`]{.rm}@@
>       @@[`completion_signatures_of_t<Sndr, Env>,`]{.rm}@@
>       @@[`AdditionalSignatures, SetValue, SetError, SetStopped>;`]{.rm}@@
>
>   // [exec.run.loop]{.sref}, run_loop
>   class run_loop;
>
>   @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
>
> }
> ```
> 
> [1]{.pnum} The exposition-only type ```@_`variant-or-empty`_@<Ts...>``` is
> defined as follows <span style="color:blue">... as before</span>
> 
> [2]{.pnum} For type[s]{.rm} `Sndr` and [pack of types]{.add} `Env`, [let `CS` be
> `completion_signatures_of_t<Sndr, Env...>`. Then]{.add}
> ```single-sender-value-type<Sndr, Env@[`...`]{.add}@>``` is
> [ill-formed if `CS` is ill-formed or if `sizeof...(Env) > 1` is `true`;
> otherwise, it is]{.add} an alias for:
> 
> - [2.1]{.pnum} ```@[`value_types_of_t<Sndr, Env`]{.rm}@```
>   ```@[_`gather-signatures`_<set_value_t, CS]{.add}@, decay_t, type_identity_t>```
>   if that type is well-formed,
> 
> - [2.2]{.pnum} Otherwise, `void` if
>   ```@[`value_types_of_t<Sndr, Env`]{.rm}@```
>   ```@[_`gather-signatures`_<set_value_t, CS]{.add}@, tuple, variant>```
>   is `variant<tuple<>>` or `variant<>`,
> 
> - [2.3]{.pnum} Otherwise,
>   ```@[`value_types_of_t<Sndr, Env`]{.rm}@```
>   ```@[_`gather-signatures`_<set_value_t, CS]{.add}@, @_`decayed-tuple`_@, type_identity_t>```
>   if that type is well-formed,
> 
> - [2.4]{.pnum} Otherwise,
>   ```@_`single-sender-value-type`_@<Sndr, Env@[`...`]{.add}@>``` is ill-formed.
> 
> [3]{.pnum} The exposition-only concept *`single-sender`* is defined as follows:
> 
> > ```c++
> > namespace std::execution {
> >   template<class Sndr, class@[`...`]{.add}@ Env>
> >     concept @_`single-sender`_@ = sender_in<Sndr, Env@[`...`]{.add}@> &&
> >       requires {
> >         typename @_`single-sender-value-type`_@<Sndr, Env@[`...`]{.add}@>;
> >       };
> > }
> > ```
> 
> ::: add
>
> [?]{.pnum} [A type satisfies and models the exposition-only concept
> _`valid-completion-signatures`_ if it is a specialization of the `completion_signatures`
> class template.]{.add}
>
> :::


[Modify [exec.snd.general]{.sref} as follows:]{.ednote}

> [1]{.pnum} Subclauses [exec.factories]{.sref} and [exec.adapt]{.sref} define customizable algorithms
> that return senders. Each algorithm has a default implementation. Let `sndr`
> be the result of an invocation of such an algorithm or an object equal to the
> result ([concepts.equality]), and let `Sndr` be `decltype((sndr))`. Let
> `rcvr` be a receiver of type `Rcvr` with associated environment `env` of type
> `Env` such that `sender_to<Sndr, Rcvr>` is `true`. For the default
> implementation of the algorithm that produced `sndr`, connecting `sndr` to
> `rcvr` and starting the resulting operation state ([exec.async.ops]{.sref})
> necessarily results in the potential evaluation ([basic.def.odr]) of a set of
> completion operations whose first argument is a subexpression equal to
> `rcvr`. Let `Sigs` be a pack of completion signatures corresponding to this
> set of completion operations[. Then]{.rm} [, and let `CS` be]{.add}
> the type of the expression [`get_completion_signatures(sndr, env)`]{.rm}
> [`get_completion_signatures<Sndr, Env>()`.  Then `CS`]{.add} is a
> specialization of the class template `completion_signatures`
> ([exec.util.cmplsig]{.sref}), the set of whose template arguments is `Sigs`. [If
> none of the types in `Sigs` are dependent on the type `Env`, then the
> expression `get_completion_signatures<Sndr>()` is well-formed and its type is
> `CS`.]{.add} If a user-provided implementation of the algorithm that produced
> `sndr` is selected instead of the default: [Reformatted
> into a list.]{.ednote}
> 
> - [1.1]{.pnum} Any completion signature that is in the set of types denoted by
>   `completion_signatures_of_t<Sndr, Env>` and that is not part of `Sigs`
>   shall correspond to error or stopped completion operations, unless
>   otherwise specified.
> 
> - [1.2]{.pnum}[If none of the types in `Sigs` are dependent on the type `Env`, then
>   `completion_signatures_of_t<Sndr>` and
>   `completion_signatures_of_t<Sndr, Env>` shall denote the same type.]{.add}


[In [exec.snd.expos]{.sref}, change para 2 as follows:]{.ednote}

> [2]{.pnum} For a queryable object `env`, ```@_`FWD-ENV`_@(env)``` is an
> expression whose type satisfies `queryable` such that for a query object `q`
> and a pack of subexpressions `as`, the expression
> ```@_`FWD-ENV`_@(env).query(q, as...)``` is ill-formed if
> `forwarding_query(q)` is `false`; otherwise, it is expression-equivalent to
> `env.query(q, as...)`. [The type ```@_`FWD-ENV-T`_@(Env)``` is
> ```decltype(@_`FWD-ENV`_@(declval<Env>()))```.]{.add}


[In [exec.snd.expos]{.sref}, insert the following paragraph after para 22 and before para 23
(thus moving the exposition-only concept out of para 24 and into its own para so it can be
used from elsewhere):]{.ednote}

::: add

> [?]{.pnum} Let _`valid-specialization`_ be the following concept:
>
> > ```c++
> > template<template<class...> class T, class... Args>
> >   concept @_`valid-specialization`_@ = requires { typename T<Args...>; }; // exposition only
> > ```

:::


[In [exec.snd.expos]{.sref} para 23 add the mandate shown below:]{.ednote}

> ```c++
> template<class Tag, class Data = @_`see below`_@, class... Child>
>   constexpr auto @_`make-sender`_@(Tag tag, Data&& data, Child&&... child);
> ```
>
> [23]{.pnum} _Mandates_: The following expressions are `true`:
>
> - [23.1]{.pnum} `semiregular<Tag>`
>
> - [23.2]{.pnum} ```@_`movable-value`_@<Data>```
>
> - [23.3]{.pnum} `(sender<Child> &&...)`

::: add

> - [23.4]{.pnum} [`dependent_sender<Sndr> || sender_in<Sndr>`, where `Sndr`
>   is ```@_`basic-sender`_@<Tag, Data, Child...>``` as defined below.]{.add}
>
>   _Recommended practice:_ If evaluation of `sender_in` results in an uncaught exception
>   from the evaluation of `get_completion_signatures<Sndr>()`, the implementation should
>   include information about that exception in the resulting diagnostic.

:::


[In [exec.snd.expos]{.sref} para 24, change the definition of the exposition-only
_`basic-sender`_ template as follows:]{.ednote}


> [24]{.pnum} _Returns_: A prvalue of type
> ```@_`basic-sender`_@<Tag, decay_t<Data>, decay_t<Child>...>``` that has
> been direct-list-initialized with the forwarded arguments, where
> _`basic-sender`_ is the following exposition-only class template except as
> noted below.
>
> > ```{.cpp}
> > namespace std::execution {
> >   template<class Tag>
> >   concept @_`completion-tag`_@ = // exposition only
> >     same_as<Tag, set_value_t> || same_as<Tag, set_error_t> || same_as<Tag, set_stopped_t>;
> >
> >   @[`template<template<class...> class T, class... Args>`]{.rm}@
> >   @@[```concept @_`valid-specialization`_@ = requires { typename T<Args...>; }; // exposition only```]{.rm}@@
> >
> >   struct @_`default-impls`_@ {  // exposition only
> >     static constexpr auto @_`get-attrs`_@ = @_`see below`_@;
> >     static constexpr auto @_`get-env`_@ = @_`see below`_@;
> >     static constexpr auto @_`get-state`_@ = @_`see below`_@;
> >     static constexpr auto @_`start`_@ = @_`see below`_@;
> >     static constexpr auto @_`complete`_@ = @_`see below`_@;
> >
> >     @[`template<class Sndr, class... Env>`]{.add}@
> >     @@[```static consteval void @_`check-types`_@();```]{.add}@@
> >   };
> >
> >   @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
> >
> >   @[`template <class Sndr>`]{.add}@
> >   @@[```using @_`data-type`_@ = decltype(declval<Sndr>().template @_`get`_@<1>());     // exposition only```]{.add}@@
> >
> >   template <class Sndr, size_t I = 0>
> >   using @_`child-type`_@ = decltype(declval<Sndr>().template @_`get`_@<I+2>());     // exposition only
> >
> >   @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
> >
> >   @[`template<class Sndr, class... Env>`]{.rm}@
> >   @@[```using @_`completion-signatures-for`_@ = @_`see below`_@; // exposition only```]{.rm}@@
> >
> >   template<class Tag, class Data, class... Child>
> >   struct @_`basic-sender`_@ : @_`product-type`_@<Tag, Data, Child...> {  // exposition only
> >     using sender_concept = sender_t;
> >     using @_`indices-for`_@ = index_sequence_for<Child...>; // exposition only
> >
> >     decltype(auto) get_env() const noexcept {
> >       auto& [_, data, ...child] = *this;
> >       return @_`impls-for`_@<Tag>::@_`get-attrs`_@(data, child...);
> >     }
> >
> >     template<@_`decays-to`_@<@_`basic-sender`_@> Self, receiver Rcvr>
> >     auto connect(this Self&& self, Rcvr rcvr) noexcept(@_`see below`_@)
> >       -> @_`basic-operation`_@<Self, Rcvr> {
> >       return {std::forward<Self>(self), std::move(rcvr)};
> >     }
> >
> >     template<@_`decays-to`_@<@_`basic-sender`_@> Self, class@[`...`]{.add}@ Env>
> >     @[`static constexpr`]{.add}@ auto get_completion_signatures@[`();`]{.add}[`(this Self&& self, Env&&... env) noexcept`]{.rm}@
> >       @@[```-> @_`completion-signatures-for`_@<Self, Env...> {```]{.rm}@@
> >       @[`return {};`]{.rm}@
> >     @[`}`]{.rm}@
> >   };
> > }
> > ```


[In [exec.snd.expos]{.sref}, replace para 39 with the paragraphs shown below and
renumber subsequent paragraphs:]{.ednote}

> ::: rm
>
> [39]{.pnum} Let `Sndr` be a (possibly `const`-qualified) specialization _`basic-sender`_
> or an lvalue reference of such, let `Rcvr` be the type of a receiver with an
> associated environment of type `Env`. If the type
> ```@_`basic-operation`_@<Sndr, Rcvr>``` is well-formed, let `op` be an
> lvalue subexpression of that type. Then
> ```@_`completion-signatures-for`_@<Sndr, Env>``` denotes a specialization of
> `completion_signatures`, the set of whose template arguments corresponds to
> the set of completion operations that are potentially evaluated
> ([basic.def.odr]) as a result of evaluating `op.start()`. Otherwise,
> ```@_`completion-signatures-for`_@<Sndr, Env>``` is ill-formed. If
> ```@_`completion-signatures-for`_@<Sndr, Env>``` is well-formed and its type
> is not dependent upon the type `Env`,
> ```@_`completion-signatures-for`_@<Sndr>```  is well-formed and denotes the
> same type; otherwise, ```@_`completion-signatures-for`_@<Sndr>```  is
> ill-formed.
>
> :::
>
> ::: add
>
> ```c++
> template <class Sndr, class... Env>
>   static consteval void @_`default-impls`_@::@_`check-types`_@();
> ```
>
> [?]{.pnum} Let `Is` be the pack of integral template arguments of the
> `integer_sequence` specialization denoted by ```@_`indices-for`_@<Sndr>```.
>
> [?]{.pnum} _Effects_: Equivalent to:
>
> > ```c++
> > (get_completion_signatures<@_`child-type`_@<Sndr, Is>, @_`FWD-ENV-T`_@(Env)...>(), ...)
> > ```
>
> [?]{.pnum} _Note_: For any types `T` and `S`, and pack `E`, let `e` be the
> expression ```@_`impls-for`_@<T>::@_`check-types`_@<S, E...>()```. Then
> exactly one of the following is `true`:
>
> - [?.1]{.pnum} `e` is ill-formed, or
>
> - [?.3]{.pnum} the evaluation of `e` exits with an exception, or
>
> - [?.2]{.pnum} `e` is a core constant expression.
>
> When `e` is a core constant expression, the pack `S`, `E...` uniquely
> determines a set of completion signatures.
>
> ```c++
> template<class Tag, class Data, class... Child>
>   template <class Sndr, class... Env>
>     constexpr auto @_`basic-sender`_@<Tag, Data, Child...>::get_completion_signatures();
> ```
>
> [?]{.pnum} Let `Rcvr` be the type of a receiver whose environment has type
> `E`, where `E` is the first type in the list ```Env..., env<>```.
> Let ```@_`CHECK-TYPES`_@()``` be the expression
> ```@_`impls-for`_@<Tag>::template @_`check-types`_@<Sndr, E>()```, and
> let `CS` be a type determined as follows:
>
> - [?.1]{.pnum} If ```@_`CHECK-TYPES`_@()``` is a core constant expression, let
>   `op` be an lvalue subexpression whose type is `connect_result_t<Sndr,
>   Rcvr>`. Then `CS` is the specialization of `completion_signatures` the set
>   of whose template arguments correspond to the set of completion operations
>   that are potentially evaluated ([basic.def.odr]) as a result of evaluating
>   `op.start()`.
>
> - [?.2]{.pnum} Otherwise, `CS` is `completion_signatures<>`.
>
> [?]{.pnum} _Constraints_: ```@_`CHECK-TYPES`_@()``` is a well-formed expression.
>
> [?]{.pnum} _Effects_: Equivalent to
>
> > ```c++
> > @_`CHECK-TYPES`_@();
> > return CS();
> > ```
>
> :::

[Add the following new paragraphs to the end of [exec.snd.expos]{.sref}]{.ednote}

> ::: add
>
> [?]{.pnum} <div>
>
> ```c++
> template<class... Fns>
> struct @_`overload-set`_@ : Fns... {
>   using Fns::operator()...;
> };
> ```
>
> </div>
>
> [The following is moved from [exec.on]{.sref} para 6 and modified.]{.ednote}
>
> [?]{.pnum} <div>
>
> ```c++
> struct @_`not-a-sender`_@ {
>   using sender_concept = sender_t;
>
>   template<class Sndr>
>   static constexpr auto get_completion_signatures() -> completion_signatures<> {
>     throw @_unspecified_@;
>   }
> };
> ```
>
> </div>
>
> [?]{.pnum} <div>
>
> ```c++
> constexpr void @_`decay-copyable-result-datums`_@(auto cs) {
>   cs.@_`for-each`_@([]<class Tag, class... Ts>(Tag(*)(Ts...)) {
>     if constexpr (!(is_constructible_v<decay_t<Ts>, Ts> &&...))
>       throw @_`unspecified`_@;
>   });
> }
> ```
>
> </div>
>
> :::


[Change [exec.snd.concepts]{.sref} para 1 and add a new para after 1 as follows:]{.ednote}

> [1]{.pnum} The `sender` concept <span style="color:blue;font-style:italic">&hellip; as
> before &hellip;</span> to produce an operation state.
>
> > ```{.cpp}
> > namespace std::execution {
> >   @[`template<class Sigs>`]{.rm}@
> >     @@[```concept @_`valid-completion-signatures`_@ = @_`see below`_@;            // exposition only```]{.rm}@@
> >
> >   @[`template<auto>`]{.add}@
> >     @@[```concept @_`is-constant`_@ = true;```]{.add}@@                                 @[`// exposition only`{.cpp}]{.add}@
> >
> >   template<class Sndr>
> >     concept @_`is-sender`_@ =                                         // exposition only
> >       derived_from<typename Sndr::sender_concept, sender_t>;
> >
> >   template<class Sndr>
> >     concept @_`enable-sender`_@ =                                     // exposition only
> >       @_`is-sender`_@<Sndr> ||
> >       @_`is-awaitable`_@<Sndr, @_`env-promise`_@<env<>>>;                   // [exec.awaitable]{.sref}
> >
> >   @[`template<class Sndr>`]{.add}@
> >     @@[```consteval bool @_`is-dependent-sender-helper`_@() try {```]{.add}@@           @[`// exposition only`{.cpp}]{.add}@
> >       @[`get_completion_signatures<Sndr>();`]{.add}@
> >       @[`return false;`]{.add}@
> >     @[`} catch (dependent_sender_error&) {`]{.add}@
> >       @[`return true;`]{.add}@
> >     @[`}`]{.add}@
> >
> >   template<class Sndr>
> >     concept sender =
> >       bool(@_`enable-sender`_@<remove_cvref_t<Sndr>>) &&
> >       requires (const remove_cvref_t<Sndr>& sndr) {
> >         { get_env(sndr) } -> @_`queryable`_@;
> >       } &&
> >       move_constructible<remove_cvref_t<Sndr>> &&
> >       constructible_from<remove_cvref_t<Sndr>, Sndr>;
> >
> >   template<class Sndr, class@[`...`]{.add}@ Env @[`= env<>`]{.rm}@>
> >     concept sender_in =
> >       sender<Sndr> &&
> >       @[`(sizeof...(Env) <= 1) &&`]{.add}@
> >       @[`(`]{.add}@queryable<Env> @[`&&...)`]{.add}@ &&
> >       @@[```@_`is-constant`_@<get_completion_signatures<Sndr, Env...>()>;```]{.add}@@
> >       @[`requires (Sndr&& sndr, Env&& env) {`]{.rm}@
> >         @[`{ get_completion_signatures(std::forward<Sndr>(sndr), std::forward<Env>(env)) }`]{.rm}@
> >           @@[```-> @_`valid-completion-signatures`_@;```]{.rm}@@
> >       @[`};`]{.rm}@
> >
> >   @[`template<class Sndr>`]{.add}@
> >     @[`concept dependent_sender =`]{.add}@
> >       @@[```sender<Sndr> && bool_constant<@_`is-dependent-sender-helper`_@<Sndr>()>::value;```]{.add}@@
> >
> >   template<class Sndr, class Rcvr>
> >     concept sender_to =
> >       sender_in<Sndr, env_of_t<Rcvr>> &&
> >       receiver_of<Rcvr, completion_signatures_of_t<Sndr, env_of_t<Rcvr>>> &&
> >       requires (Sndr&& sndr, Rcvr&& rcvr) {
> >         connect(std::forward<Sndr>(sndr), std::forward<Rcvr>(rcvr));
> >       };
> > }
> > ```
>
> ::: add
>
> - [?]{.pnum} [For a type `Sndr`, if `sender<Sndr>` is `true` and `dependent_sender<Sndr>`
>   is `false`, then `Sndr` is a non-dependent sender ([exec.async.ops]{.sref}).]{.add}
>
> :::

[Strike [exec.snd.concepts]{.sref} para 3 (this para is moved to [execution.syn]):]{.ednote}

::: rm

> [3]{.pnum} [A type models the exposition-only concept _`valid-completion-signatures`_ if
> it denotes a specialization of the `completion_signatures` class template.]{.rm}

:::


<span class="ednote">Change [exec.snd.concepts]{.sref} para 4 as follows (so that the
exposition-only *`sender-of`* concept tests for sender-ness with no environment
as opposed to the empty environment, `env<>`):</span>

> [4]{.pnum} The exposition-only concepts *`sender-of`* and *`sender-in-of`* define the
> requirements for a sender type that completes with a given unique set of
> value result types.
> 
> > ```c++
> > namespace std::execution {
> >   template<class... As>
> >     using @_`value-signature`_@ = set_value_t(As...);      // exposition only
> >
> >   @@[```template<class Sndr, class Env, class... Values>```]{.rm}@@
> >     @@[```concept @_`sender-in-of`_@ =```]{.rm}@@
> >       @@[```sender_in<Sndr, Env> &&```]{.rm}@@
> >       @@[```@_`MATCHING-SIG`_@(                     // see [exec.general]{.sref}```]{.rm}@@
> >         @@[```set_value_t(Values...),```]{.rm}@@
> >         @@[```value_types_of_t<Sndr, Env, @_`value-signature`_@, type_identity_t>);```]{.rm}@@
> >
> >   @@[```template<class Sndr, class... Values>```]{.rm}@@
> >     @@[```concept @_`sender-of`_@ = @_`sender-in-of`_@<Sndr, env<>, Values...>;```]{.rm}@@
> >
> >   @@[```template<class Sndr, class SetValue, class... Env>```]{.add}@@
> >     @@[```concept @_`sender-in-of-impl`_@ =         // exposition only```]{.add}@@
> >       @@[```sender_in<Sndr, Env...> &&```]{.add}@@
> >       @@[```@_`MATCHING-SIG`_@(SetValue,                          // see [exec.general]{.sref}        ```]{.add}@@
> >                    @@[```@_`gather-signatures`_@<set_value_t,     // see [exec.util.cmplsig]{.sref}```]{.add}@@
> >                                      @@[```completion_signatures_of_t<Sndr, Env...>,```]{.add}@@
> >                                      @@[```@_`value-signature`_@,```]{.add}@@
> >                                      @@[```type_identity_t>);```]{.add}@@
> >
> >   @@[```template<class Sndr, class Env, class... Values>```]{.add}@@
> >     @@[```concept @_`sender-in-of`_@ =              // exposition only```]{.add}@@
> >       @@[```@_`sender-in-of-impl`_@<Sndr, set_value_t(Values...), Env>;```]{.add}@@
> >
> >   @@[```template<class Sndr, class... Values>```]{.add}@@
> >     @@[```concept @_`sender-of`_@ =                 // exposition only```]{.add}@@
> >       @@[```@_`sender-in-of-impl`_@<Sndr, set_value_t(Values...)>;```]{.add}@@
> > }
> > ```


<span class="ednote">Change [exec.awaitable]{.sref} p 1-4 as follows:</span>

> [1]{.pnum} The sender concepts recognize awaitables as senders. For [exec], an
> *awaitable* is an expression that would be well-formed as the operand of a `co_await`
> expression within a given context.
> 
> [2]{.pnum} For a subexpression `c`, let ```@_`GET-AWAITER`_@(c, p)``` be
> expression-equivalent to the series of transformations and conversions applied to `c` as
> the operand of an *await-expression* in a coroutine, resulting in lvalue `e` as
> described by [expr.await], where `p` is an lvalue referring to the coroutine’s promise,
> which has type `Promise`.
>    
> [*Note 1*: This includes the invocation of the promise type’s
> `await_transform` member if any, the invocation of the `operator co_await`
> picked by overload resolution if any, and any necessary implicit conversions
> and materializations. -- *end note*]
>    
> [Let ```@_`GET-AWAITER`_@(c)``` be expression-equivalent to ```@_`GET-AWAITER`_@(c,
> q)``` where `q` is an lvalue of an unspecified empty class type *`none-such`* that lacks
> an `await_transform` member, and where ```coroutine_handle<@_`none-such`_@>``` behaves
> as `coroutine_handle<void>`.]{.add}
> 
> [3]{.pnum} Let *`is-awaitable`* be the following exposition-only concept:
> [NB: there are added ellipses in the following code block.]{.ednote}
> 
> > ```c++
> > template<class T>
> >   concept @_`await-suspend-result`_@ = @_`see below`_@;
> > 
> > template<class A, class@[`...`]{.add}@ Promise>
> >   concept @_`is-awaiter`_@ = // exposition only
> >      requires (A& a, coroutine_handle<Promise@[`...`]{.add}@> h) {
> >         a.await_ready() ? 1 : 0;
> >         { a.await_suspend(h) } -> @_`await-suspend-result`_@;
> >         a.await_resume();
> >      };
> > 
> > template<class C, class@[`...`]{.add}@ Promise>
> >   concept @_`is-awaitable`_@ =
> >      requires (C (*fc)() noexcept, Promise&@[`...`]{.add}@ p) {
> >         { @_`GET-AWAITER`_@(fc(), p@[`...`]{.add}@) } -> @_`is-awaiter`_@<Promise@[`...`]{.add}@>;
> >      };
> > ```
> 
> ```@_`await-suspend-result`_@<T>``` is `true` if and only if one
> of the following is `true`:
> 
> - [3.1]{.pnum} `T` is `void`, or
> - [3.2]{.pnum} `T` is `bool`, or
> - [3.3]{.pnum} `T` is a specialization of `coroutine_handle`.
> 
> [4]{.pnum} For a subexpression `c` such that `decltype((c))` is type `C`, and an lvalue
>    `p` of type `Promise`, ```@_`await-result-type`_@<C, Promise>```
>    denotes the type
>    ```decltype(@_`GET-AWAITER`_@(c, p).await_resume())``` [and
>    ```@_`await-result-type`_@<C>``` denotes the type
>    ```decltype(@_`GET-AWAITER`_@(c).await_resume())```]{.add}.


[Change [exec.getcomplsigs]{.sref} as follows:]{.ednote}

> ::: rm
> 
> [1]{.pnum} `get_completion_signatures` is a customization point object. Let `sndr` be an
> expression such that `decltype((sndr))` is `Sndr`, and let `env` be an expression such that
> `decltype((env))` is `Env`. Let `new_sndr` be the expression
> ```transform_sender(decltype(@_`get-domain-late`_@(sndr, env)){}, sndr, env)```, and let `NewSndr` be
> `decltype((new_sndr))`. Then `get_completion_signatures(sndr, env)` is expression-equivalent
> to `(void(sndr), void(env), CS())` except that `void(sndr)` and `void(env)` are indeterminately
> sequenced, where `CS` is:
> 
> - [1.1]{.pnum} `decltype(new_sndr.get_completion_signatures(env))` if that type is
>   well-formed,
> 
> - [1.2]{.pnum} Otherwise, `remove_cvref_t<NewSndr>​::​completion_signatures` if that type
>   is well-formed,
> 
> - [1.3]{.pnum} Otherwise, if ```@_`is-awaitable`_@<NewSndr, @_`env-promise`_@<Env>>``` is
>   `true`, then:
> 
> > ```c++
> > completion_signatures<
> >   @_`SET-VALUE-SIG`_@(@_`await-result-type`_@<NewSndr, @_`env-promise`_@<Env>>),        //  ([exec.snd.concepts]{.sref})
> >   set_error_t(exception_ptr),
> >   set_stopped_t()>
> > ```
> 
> - [1.4]{.pnum} Otherwise, `CS` is ill-formed.
> 
> :::

> ::: add
>
> ```c++
> template <class Sndr, class... Env>
>   consteval auto get_completion_signatures() -> @@```@_`valid-completion-signatures`_@ auto```@@;
> ```
>
> [?]{.pnum} Let _`except`_ be an rvalue subexpression of an unspecified class type
> _`Except`_ such that `move_constructible<Except> && derived_from<Except, exception>`
> is `true`. Let ```@_`CHECKED-COMPLSIGS`_@(@_`e`_@)``` be _`e`_ if
> _`e`_ is a core constant expression whose type satisfies
> _`valid-completion-signatures`_; otherwise, it is the following expression:
>
> > ```c++
> > (@_`e`_@, throw @_`except`_@, completion_signatures())
> > ```
>
> Let ```@_`get-complsigs`_@<Sndr, Env...>()``` be expression-equivalent to
> `remove_reference_t<Sndr>::template get_completion_signatures<Sndr, Env...>()`.
> Let `NewSndr` be `Sndr` if `sizeof...(Env) == 0` is `true`; otherwise,
> ```decltype(@_`s`_@)``` where _`s`_ is the following expression:
>
> > ```c++
> > transform_sender(
> >   @_`get-domain-late`_@(declval<Sndr>(), declval<Env>()...),
> >   declval<Sndr>(),
> >   declval<Env>()...)
> > ```
>
> [?]{.pnum} _Constraints_: `sizeof...(Env) <= 1` is `true`.
>
> [?]{.pnum} _Effects_: Equivalent to: `return @_e_@;` where _`e`_ is
> expression-equivalent to the following:
>
> - [?.1]{.pnum} ```@_`CHECKED-COMPLSIGS`_@(@_`get-complsigs`_@<NewSndr, Env...>())```
>   if ```@_`get-complsigs`_@<NewSndr, Env...>()``` is a well-formed expression.
>
> - [?.2]{.pnum} Otherwise,
>   ```@_`CHECKED-COMPLSIGS`_@(@_`get-complsigs`_@<NewSndr>())``` if
>   ```@_`get-complsigs`_@<NewSndr>()``` is a well-formed expression.
>
> - [?.3]{.pnum} Otherwise,
>
>   > ```c++
>   > completion_signatures<
>   >   @_`SET-VALUE-SIG`_@(@_`await-result-type`_@<NewSndr, @_`env-promise`_@<Env>...>),  //  ([exec.snd.concepts]{.sref})
>   >   set_error_t(exception_ptr),
>   >   set_stopped_t()>
>   > ```
>
>   if ```@_`is-awaitable`_@<NewSndr, @_`env-promise`_@<Env>...>``` is `true`.
>
> - [?.4]{.pnum} Otherwise, ```(throw @_`dependent-sender-error`_@(), completion_signatures())``` if
>   `sizeof...(Env) == 0` is `true`, where _`dependent-sender-error`_ is
>   `dependent_sender_error` or an unspecified type derived publicly and
>   unambiguously from `dependent_sender_error`.
>
> - [?.5]{.pnum} Otherwise, ```(throw @_`except`_@, completion_signatures())```.
>
> [?]{.pnum} Given a type `Env`, if `completion_signatures_of_t<Sndr>` and
> `completion_signatures_of_t<Sndr, Env>` are both well-formed, they shall
> denote the same type.
>
> :::
>
> [2]{.pnum} Let `rcvr` be an rvalue whose type [\... as before]{.ednote}.


[At the very bottom of [exec.connect], change the _Mandates_ of para 6 as follows:]{.ednote}

> [6]{.pnum} The expression `connect(sndr, rcvr)` is expression-equivalent to:
>
>   - [6.1]{.pnum} `new_sndr.connect(rcvr)` if that expression is well-formed.
>
>       _Mandates_: The type of the expression above satisfies `operation_state`.
>
>   - [6.2]{.pnum} Otherwise, ```@_`connect-awaitable`_@(new_sndr, rcvr)```.
>
>   _Mandates_: [`sender<Sndr> && receiver<Rcvr>`]{.rm} [The following are `true`:]{.add}
>
> ::: add
>
>   - [6.3]{.pnum} [`sender_in<Sndr, env_of_t<Rcvr>>`]{.add}
>
>   - [6.4]{.pnum} [`receiver_of<Rcvr, completion_signatures_of_t<Sndr, env_of_t<Rcvr>>>`]{.add}
>
> :::


[In [exec.read.env]{.sref} para 3, make the following change:]{.ednote}

> [3]{.pnum} The exposition-only class template _`impls-for`_
> ([exec.snd.general]{.sref}) is specialized for `read_env` as follows:
>
> > ```c++
> > namespace std::execution {
> >   template<>
> >   struct @_`impls-for`_@<@_`decayed-typeof`_@<read_env>> : @_`default-impls`_@ {
> >     static constexpr auto @_`start`_@ =
> >       [](auto query, auto& rcvr) noexcept -> void {
> >         @_`TRY-SET-VALUE`_@(std::move(rcvr), query(get_env(rcvr)));
> >       };
> >
> >     @[`template<class Sndr, class Env>`]{.add}@
> >     @@[```static consteval void @_`check-types`_@();```]{.add}@@
> >   };
> > }
> > ```

::: add

> ```c++
> template<class Sndr, class Env>
> static consteval void @_`check-types`_@();
> ```
>
> - [3.1]{.pnum} Let `Q` be ```decay_t<@_`data-type`_@<Sndr>>```.
>
> - [3.2]{.pnum} _Throws_: An exception of an unspecified type derived from
>   `exception` if the expression `Q()(env)` is ill-formed or has type `void`,
>   where `env` is an lvalue subexpression whose type is `Env`.

:::


[Change [exec.adapt.general]{.sref} as follows:]{.ednote}

> - [3.4]{.pnum} When a parent sender is connected to a receiver `rcvr`, any receiver used
>   to connect a child sender has an associated environment equal to
>   ```@_`FWD-ENV`_@(get_env(rcvr))```.
> 
> - [3.?]{.pnum} [An adaptor whose child senders are all non-dependent ([async.ops]) is
>   itself non-dependent.]{.add}
> 
> - [3.5]{.pnum} These requirements apply to any function that is selected by the
>   implementation of the sender adaptor.
> 
> - [3.?]{.pnum} [_Recommended practice_: Implementations should use the completion
>   signatures of the adaptors to communicate type errors to users and to propagate any
>   such type errors from child senders.]{.add}

[Change [exec.write.env] as follows (see [@P3284R4] for [exec.write.env], to be voted on
in Bulgaria):]{.ednote}

> [1]{.pnum} `write_env` is a sender adaptor that accepts a sender and a queryable object,
> and that returns a sender that, when connected with a receiver `rcvr`,  connects the
> adapted sender with a receiver whose execution environment is the result of joining the
> queryable argument `env` to the result of `get_env(rcvr)`.
>
> [2]{.pnum} `write_env` is a customization point object. For some subexpressions `sndr`
> and `env`, if `decltype((sndr))` does not satisfy `sender` or if `decltype((env))` does
> not satisfy _`queryable`_, the expression `write_env(sndr, env)` is ill-formed.
> Otherwise, it is expression-equivalent to <code><i>make-sender</i>(write_env, env,
> sndr)</code>.
>
> [3]{.pnum} Let *`write-env-t`* denote the type `decltype(auto(write_env))`. The
> exposition-only class template _`impls-for`_ ([exec.snd.expos]{.sref}) is specialized for
> _`write-env-t`_ as follows:
>
> > ```c++
> > template<>
> > struct @_`impls-for`_@<@_`write-env-t`_@> : @_`default-impls`_@ {
> >   @@[```static constexpr auto @_`join-env`_@(const auto& state, const auto& env) noexcept {```]{.add}@@
> >     @@[```return @_`see below`_@;```]{.add}@@
> >   @[`}`]{.add}@
> >
> >   static constexpr auto @_`get-env`_@ =
> >     [](auto, const auto& state, const auto& rcvr) noexcept {
> >       return @@[```@_`see below`_@```]{.rm}[```@_`join-env`_@(state, @_`FWD-ENV`_@(get_env(rcvr)))```]{.add}@@;
> >     };
> >
> >   @[`template<class Sndr, class... Env>`]{.add}@
> >   @@[```static consteval void @_`check-types`_@();```]{.add}@@
> > };
> > ```
>
>   Invocation of
>   ```@_`impls-for`_@<@_`write-env-t`_@>::@_[`get-env`]{.rm}[`join-env`]{.add}_@```
>   returns an object `e` such that
>
>   - [3.1]{.pnum} `decltype(e)` models _`queryable`_ and
>  
>   - [3.2]{.pnum} given a query object `q`, the expression `e.query(q)` is
>     expression-equivalent to `state.query(q)` if that expression is valid;
>     otherwise, `e.query(q)` is expression-equivalent to
>     ```@@[`@_FWD-ENV_@(get_env(rcvr))`]{.rm}[`env`]{.add}@@.query(q)```.
>
> ::: add
>
>   - [3.3]{.pnum} [For a type `Sndr` and a pack of types `Env`, let `State` be
>     ```@_`data-type`_@<Sndr>``` and let `JoinEnv` be the pack
>     ```decltype(@_`join-env`_@(declval<State>(), @_`FWD-ENV`_@(declval<Env>())))```. Then
>     ```@_`impls-for`_@<@_`write-env-t`_@>::@_`check-types`_@<Sndr, Env...>()``` is
>     expression-equivalent to
>     ```get_completion_signatures<@_`child-type`_@<Sndr>, JoinEnv...>()```.]{.add}
>
> :::

[Change [exec.schedule.from]{.sref} para 4 and insert a new para between 6 and 7 as
follows:]{.ednote}

> [4]{.pnum} The exposition-only class template _`impls-for`_ ([exec.snd.general]{.sref}) is
> specialized for `schedule_from_t` as follows:
>
> > ```c++
> > namespace std::execution {
> >   template<>
> >   struct @_`impls-for`_@<schedule_from_t> : @_`default-impls`_@ {
> >     static constexpr auto @_`get-attrs`_@ = @_`see below;`_@
> >     static constexpr auto @_`get-state`_@ = @_`see below;`_@
> >     static constexpr auto @_`complete`_@ = @_`see below;`_@
> >
> >     @[`template<class Sndr, class... Env>`]{.add}@
> >     @@[```static consteval void @_`check-types`_@();```]{.add}@@
> >   };
> > }
> > ```
>
> [5]{.pnum} The member <span style="color:blue;font-style=italic">&hellip; as before &hellip;</span>
>
> [6]{.pnum} The member ```@_`impls-for`_@<schedule_from_t>::@_`get-state`_@```
> is initialized with a callable object equivalent to the following lambda: [This integrates
> the resolution from [LWG#4203](https://cplusplus.github.io/LWG/issue4203).]{.ednote}
>
> > ```c++
> > []<class Sndr, class Rcvr>(Sndr&& sndr, Rcvr& rcvr) noexcept(see below)
> >     requires sender_in<child-type<Sndr>, @@[```@_`FWD-ENV-T`_@(```]{.add}@@env_of_t<Rcvr>@[`)`]{.add}@> {
> >
> >   auto& [_, sch, child] = sndr;
> >   @<span style="color:blue;font-style=italic">&hellip; as before &hellip;</span>@
> > ```
>
> ::: add
>
> ```c++
> template<class Sndr, class... Env>
> static consteval void @_`check-types`_@();
> ```
>
> [?]{.pnum} _Effects_: Equivalent to:
>
> > ```c++
> > get_completion_signatures<schedule_result_t<@_`data-type`_@<Sndr>>, @_`FWD-ENV-T`_@(Env)...>();
> > auto cs = get_completion_signatures<@_`child-type`_@<Sndr>, @_`FWD-ENV-T`_@(Env)...>();
> > @_`decay-copyable-result-datums`_@(cs); // see [exec.snd.expos]{.sref}
> > ```
>
> :::
>
> [7]{.pnum} Objects of the local class _`state-type`_
> <span style="color:blue;font-style=italic">&hellip; as before &hellip;</span>
>
> [8]{.pnum} Let `Sigs` be a pack of the arguments to the `completion_signatures`
> specialization named by
> ```completion_signatures_of_t<@_`child-type`_@<Sndr>, @[_`FWD-ENV-T`_(]{.add}@env_of_t<Rcvr>@[`)`]{.add}@>```.
> Let _`as-tuple`_ be an alias template such that
> ```@_`as-tuple`_@<Tag(Args...)>``` denotes the type
> ```@_`decayed-tuple`_@<Tag, Args...>```. Then `variant_t` denotes the type
> ```variant<monostate, @_`as-tuple`_@<Sigs>...>```, except with duplicate
> types removed.

[Change [exec.on]{.sref} para 6 as follows (_`not-a-sender`_ is moved to
[exec.snd.expos]{.sref}):]{.ednote}

> [6]{.pnum} Otherwise: Let _`not-a-scheduler`_ be an unspecified empty class type[.]{.add}[, and
> let _`not-a-sender`_ be the exposition-only type:]{.rm}
>
> ::: rm
>
> > ```c++
> > struct @_`not-a-sender`_@ {
> >   using sender_concept = sender_t;
> >
> >   auto get_completion_signatures(auto&&) const {
> >     return @_see below_@;
> >   }
> > };
> > ```
>
> :::
>
> [where the member function `get_completion_signatures` returns an object
> of a type that is not a specialization of the `completion_signatures`
> class template.]{.rm}

[Delete [exec.on]{.sref} para 9 as follows:]{.ednote}

::: rm

> [9]{.pnum} [_Recommended practice_: Implementations should use the return type of
> ```@_`not-a-sender`_@::get_completion_signatures``` to inform users that
> their usage of on is incorrect because there is no available scheduler onto
> which to restore execution.]{.rm}

:::

[Change [exec.then]{.sref} para 4 as follows:]{.ednote}

> [4]{.pnum} The exposition-only class template *`impls-for`* ([exec.snd.general]{.sref}) is
> specialized for *`then-cpo`* as follows:
>
> > ```c++
> > namespace std::execution {
> >   template<>
> >   struct @_`impls-for`_@<@_`decayed-typeof`_@<@_`then-cpo`_@>> : @_`default-impls`_@ {
> >     static constexpr auto complete =
> >       []<class Tag, class... Args>
> >         (auto, auto& fn, auto& rcvr, Tag, Args&&... args) noexcept -> void {
> >           if constexpr (same_as<Tag, @_`decayed-typeof`_@<@_`set-cpo`_@>>) {
> >             @_`TRY-SET-VALUE`_@(rcvr,
> >                           invoke(std::move(fn), std::forward<Args>(args)...));
> >           } else {
> >             Tag()(std::move(rcvr), std::forward<Args>(args)...);
> >           }
> >         };
> >
> >     @[`template<class Sndr, class... Env>`]{.add}@
> >     @@[```static consteval void @_`check-types`_@();```]{.add}@@
> >   };
> > }
> > ```

::: add

> [?]{.pnum} <div>
>
> ```c++
> template<class Sndr, class... Env>
> static consteval void @_`check-types`_@();
> ```
>
> </div>
>
> - [?.1]{.pnum} _Effects:_ Equivalent to:
>
>   ```c++
>   auto cs = get_completion_signatures<@_`child-type`_@<Sndr>, @_`FWD-ENV-T`_@(Env)...>();
>   auto fn = []<class... Ts>(set_value_t(*)(Ts...)) {
>     if constexpr (!invocable<remove_cvref_t<@_`data-type`_@<Sndr>>, Ts...>)
>       throw @_`unspecified`_@;
>   };
>   cs.@_`for-each`_@(@_`overload-set`_@{fn, [](auto){}});
>   ```

:::

[Change [exec.let]{.sref} paras 5 and 6 and insert a new para after 6 as follows:]{.ednote}

> [5]{.pnum} The exposition-only class template _`impls-for`_ ([exec.snd.general]{.sref}) is
> specialized for _`let-cpo`_ as follows:
>
> > ```c++
> > namespace std::execution {
> >   template<class State, class Rcvr, class... Args>
> >   void @_`let-bind`_@(State& state, Rcvr& rcvr, Args&&... args);      // exposition only
> >
> >   template<>
> >   struct @_`impls-for`_@<@_`decayed-typeof`_@<@_`let-cpo`_@>> : @_`default-impls`_@ {
> >     static constexpr auto @_`get-state`_@ = @_`see below`_@;
> >     static constexpr auto @_`complete`_@ = @_`see below`_@;
> >
> >     @[`template<class Sndr, class... Env>`]{.add}@
> >     @@[```static consteval void @_`check-types`_@();```]{.add}@@
> >   };
> > }
> > ```
>
> [6]{.pnum} Let _`receiver2`_ denote the following exposition-only class template:
>
> > ```c++
> > namespace std::execution {
> >   @<span style="color:blue;font-style=italic">&hellip; as before &hellip;</span>@
> > }
> > ```
>
> Invocation of the function ```@_`receiver2`_@::get_env``` returns an object `e` such that
>
> - [6.1]{.pnum} `decltype(e)` models _`queryable`_ and
>
> - [6.2]{.pnum} given a query object `q`, the expression `e.query(q)` is
>   expression-equivalent to ```@_`env`_@.query(q)``` if that expression is
>   valid[,]{.rm}[;]{.add} otherwise[, if the type of `q` satisfies
>   _`forwarding-query`_,]{.add} `e.query(q)` is expression-equivalent to
>   ```get_env(@_`rcvr`_@).query(q)```[; otherwise, `e.query(q)` is
>   ill-formed]{.add}.
>
> ::: add
>
> [?]{.pnum} <div>
>
> ```c++
> template<class Sndr, class... Env>
> consteval void @_`check-types`_@();
> ```
>
> </div>
>
> - [?.1]{.pnum} _Effects:_ Equivalent to:
>
>   ```c++
>   using LetFn = remove_cvref_t<@_`data-type`_@<Sndr>>;
>   auto cs = get_completion_signatures<@_`child-type`_@<Sndr>, @_`FWD-ENV-T`_@(Env)...>();
>   auto fn = []<class... Ts>(@_`decayed-typeof`_@<@_`set-cpo`_@>(*)(Ts...)) {
>     if constexpr (!@_`is-valid-let-sender`_@) // see below
>       throw @_`unspecified`_@;
>   };
>   cs.@_`for-each`_@(@_`overload-set`_@(fn, [](auto){}));
>   ```
>
>   where _`is-valid-let-sender`_ is `true` if and only if all of the following
>   are `true`:
>
>   - [?.1.1]{.pnum} `(constructible_from<decay_t<Ts>, Ts> &&...)`
>   - [?.1.2]{.pnum} `invocable<LetFn, decay_t<Ts>&...>`
>   - [?.1.3]{.pnum} `sender<invoke_result_t<LetFn, decay_t<Ts>&...>>`
>   - [?.1.4]{.pnum} ```sizeof...(Env) == 0 || sender_in<invoke_result_t<LetFn, decay_t<Ts>&...>, @_`env-t`_@...>```
>
>   where _`env-t`_ is the pack
>   ```decltype(@_`let-cpo`_@.transform_env(declval<Sndr>(), declval<Env>()))```.
>
> :::
>
> [The following changes are the proposed resolutions to
> [cplusplus/sender-receiver#316](https://github.com/cplusplus/sender-receiver/issues/316)
> and
> [cplusplus/sender-receiver#318](https://github.com/cplusplus/sender-receiver/issues/318).
> ]{.ednote}
>
> [7]{.pnum} ```@_`impls-for`_@<@_`decayed-typeof`_@<@_`let-cpo`_@>>::@_`get-state`_@```
> is initialized with a callable object equivalent to the following:
>
> > ```c++
> > []<class Sndr, class Rcvr>(Sndr&& sndr, Rcvr& rcvr) requires @_`see below`_@ {
> >   auto& [_, fn, child] = sndr;
> >   using fn_t = decay_t<decltype(fn)>;
> >   using env_t = decltype(@_`let-env`_@(child));
> >   using args_variant_t = @_`see below`_@;
> >   using ops2_variant_t = @_`see below`_@;
> >   @<span style="color:blue;font-style=italic">&hellip; as before &hellip;</span>@
> > }
> > ```
>
> [8]{.pnum} Let `Sigs` be a pack of the arguments to the `completion_signatures`
> specialization named by
> ```completion_signatures_of_t<@_`child-type`_@<Sndr>, @[_`FWD-ENV-T`_(]{.add}@env_of_t<Rcvr>@[`)`]{.add}@>```.
> Let `LetSigs` be a pack of those types in `Sigs` with a return type of
> ```@_`decayed-typeof`_@<@_`set-cpo`_@>```. Let _`as-tuple`_ be an alias template
> such that ```@_`as-tuple`_@<Tag(Args...)>``` denotes the type
> ```@_`decayed-tuple`_@<Args...>```. Then `args_variant_t` denotes the type
> ```variant<monostate, @_`as-tuple`_@<LetSigs>...>``` except with duplicate types
> removed.
>
> [9]{.pnum} Given a type `Tag` and a pack `Args`, let _`as-sndr2`_ be an
> alias template such that ```@_`as-sndr2`_@<Tag(Args...)>``` denotes the type
> ```@_`call-result-t`_@<Fn, decay_t<Args>&...>```. Then `ops2_variant_t`
> denotes the type
>
> > ```c++
> > variant<monostate, connect_result_t<@_`as-sndr2`_@<LetSigs>, receiver2<Rcvr, @[`Env`]{.rm}[`env_t`]{.add}@>>...>
> > ```
>
> except with duplicate types removed.
>
> [10]{.pnum} The _`requires-clause`_ constraining the above lambda is satisfied
> if and only if the types `args_variant_t` and `ops2_variant_t` are well-formed.
>
> [11]{.pnum} The exposition-only function template _`let-bind`_ has effects equivalent to:
> <span style="color:blue;font-style=italic">&hellip; as before &hellip;</span>
>
> [12]{.pnum} <span style="color:blue;font-style=italic">&hellip; as before &hellip;</span>
>
> [The following change to [exec.let]{.sref} para 13 is the proposed resolution to
> [cplusplus/sender-receiver#319](https://github.com/cplusplus/sender-receiver/issues/319).]{.ednote}
>
> [13]{.pnum} Let `sndr` and `env` be subexpressions, and let `Sndr` be `decltype((sndr))`. If
> ```@_`sender-for`_@<Sndr, @_`decayed-typeof`_@<@_`let-cpo`_@>>``` is `false`, then the expression
> ```@_`let-cpo`_@.transform_env(sndr, env)``` is ill-formed. Otherwise, it is equivalent to
> [```@_`JOIN-ENV`_@(@_`let-env`_@(sndr), @_`FWD-ENV`_@(env))```.]{.rm}
>
> > ```c++
> > @[`auto& [_, _, child] = sndr;`]{.add}@
> > @@[```return @_`JOIN-ENV`_@(@_`let-env`_@(child), @_`FWD-ENV`_@(env));```]{.add}@@
> > ```

[Change [exec.bulk]{.sref} para 3 and insert a new para after 5 as follows:]{.ednote}

> [3]{.pnum} The exposition-only class template _`impls-for`_ ([exec.snd.general]{.sref}) is
> specialized for `bulk_t` as follows:
>
> > ```c++
> > namespace std::execution {
> >   template<>
> >   struct @_`impls-for`_@<bulk_t> : @_`default-impls`_@ {
> >     static constexpr auto @_`complete`_@ = @_`see below`_@;
> >
> >     @[`template<class Sndr, class... Env>`]{.add}@
> >     @@[```static consteval void @_`check-types`_@();```]{.add}@@
> >   };
> > }
> > ```
>
> [4]{.pnum} The member ```@_`impls-for`_@<bulk_t>::@_`complete`_@``` is
>     <span style="color:blue;font-style=italic">&hellip; as before &hellip;</span>
>
> [5]{.pnum} <span style="color:blue;font-style=italic">&hellip; as before &hellip;</span>

::: add

> [?]{.pnum} <div>
>
> ```c++
> template<class Sndr, class... Env>
> consteval void @_`check-types`_@();
> ```
>
> </div>
>
> - [?.1]{.pnum} _Effects:_ Equivalent to:
>
>   ```c++
>   auto cs = get_completion_signatures<@_`child-type`_@<Sndr>, @_`FWD-ENV-T`_@(Env)...>();
>   auto fn = []<class... Ts>(set_value_t(*)(Ts...)) {
>     if constexpr (!invocable<remove_cvref_t<@_`data-type`_@<Sndr>>, Ts&...>)
>       throw @_`unspecified`_@;
>   };
>   cs.@_`for-each`_@(@_`overload-set`_@{fn, [](auto){}});
>   ```

:::

[6]{.pnum} Let the subexpression `out_sndr` denote 
<span style="color:blue;font-style=italic">&hellip; as before &hellip;</span>

[Change [exec.when.all]{.sref} paras 2-9 and insert two new paras after 4 as
follows:]{.ednote}

> [2]{.pnum} The names `when_all` and `when_all_with_variant` denote customization point
> objects. Let `sndrs` be a pack of subexpressions, let `Sndrs` be a pack of
> the types `decltype((sndrs))...`, and let `CD` be the type
> ```common_type_t<decltype(@_`get-domain-early`_@(sndrs))...>```. [Let
> `CD2` be `CD` if `CD` is well-formed, and `default_domain`
> otherwise]{.add}. The expressions `when_all(sndrs...)` and
> `when_all_with_variant(sndrs...)` are ill-formed if any of the following
> is true:
>
> - [2.1]{.pnum} `sizeof...(sndrs)` is `0`, or
>
> - [2.2]{.pnum} `(sender<Sndrs> && ...)` is `false`[, or]{.rm}[.]{.add}
>
> ::: rm
>
> - [2.3]{.pnum} [`CD` is ill-formed.]{.rm}
>
> :::
>
> [3]{.pnum} The expression `when_all(sndrs...)` is expression-equivalent to:
>
> > ```c++
> > transform_sender(@[`CD()`]{.rm}[`CD2()`]{.add}@, @_`make-sender`_@(when_all, {}, sndrs...))
> > ```
>
> [4]{.pnum} The exposition-only class template _`impls-for`_ ([exec.snd.general]{.sref}) is
> specialized for `when_all_t` as follows:
>
> > ```c++
> > namespace std::execution {
> >   template<>
> >   struct @_`impls-for`_@<when_all_t> : @_`default-impls`_@ {
> >     static constexpr auto @_`get-attrs`_@ = @_`see below`_@;
> >     static constexpr auto @_`get-env`_@ = @_`see below`_@;
> >     static constexpr auto @_`get-state`_@ = @_`see below`_@;
> >     static constexpr auto @_`start`_@ = @_`see below`_@;
> >     static constexpr auto @_`complete`_@ = @_`see below`_@;
> >
> >     @[`template<class Sndr, class... Env>`]{.add}@
> >     @@[```static consteval void @_`check-types`_@();```]{.add}@@
> >   };
> > }
> > ```
>
> ::: add
>
> [?]{.pnum} [Let _`make-when-all-env`_ be the following exposition-only function template:]{.add}
>
> > ```c++
> > template<class Env>
> > constexpr auto @_`make-when-all-env`_@(inplace_stop_source& stop_src, Env&& env) noexcept {
> >   return @_`see below`_@;
> > }
> > ```
>
> :::
>
> Returns an object `e` such that [The following itemized list has been moved here from
> para 6 and modified as indicated.]{.ednote}
>
> - [?.1]{.pnum} `decltype(e)` models `queryable`, and
>
> - [?.2]{.pnum} `e.query(get_stop_token)` is expression-equivalent to
>   `stop_src.get_token()`, and
>
> - [?.3]{.pnum} given a query object `q` with type other than _cv_
>   `stop_token_t` [and whose type satisfies _`forwarding-query`_]{.add},
>   `e.query(q)` is expression-equivalent to `env.query(q)`.
>
> [Let _`when-all-env`_ be an alias template such that
> ```@_`when-all-env`_@<Env>``` denotes the type
>  ```decltype(@_`make-when-all-env`_@(declval<inplace_stop_source&>(), declval<Env>()))```.]{.add}

::: add

> [?]{.pnum} <div>
>
> ```c++
> template<class Sndr, class... Env>
> consteval void @_`check-types`_@();
> ```
>
> </div>
>
> - [?.1]{.pnum} [Let `Is` be the pack of integral template arguments
>   of the `integer_sequence` specialization denoted by
>   ```@_`indices-for`_@<Sndr>```.]{.add}
>
> - [?.2]{.pnum} [_Effects_: Equivalent to:]{.add}
>
>   ```c++
>   auto fn = []<class Child>() {
>     auto cs = get_completion_signatures<Child, @_`when-all-env`_@<Env>...>();
>     if constexpr (cs.@_`count-of`_@(set_value) >= 2)
>       throw @_`too-many-value-completions`_@();
>     @_`decay-copyable-result-datums`_@(cs); // see [exec.snd.expos]{.sref}
>   };
>   (fn.template operator()<@_`child-type`_@<Sndr, Is>>(), ...);
>   ```
>
>   where _`too-many-value-completions`_ is a type derived from `exception`.
>
> - [?.3]{.pnum} [_Throws_: Any exception thrown as a result of evaluating the
>   _Effects_, or an exception of an unspecified type derived from `exception`
>   when `CD` is ill-formed.]{.add}

:::

> [5]{.pnum} The member ```@_`impls-for`_@<when_all_t>::@_`get-attrs`_@``` <span
> style="color:blue;text-style:italic">&hellip; as before &hellip;</span>
>
> [6]{.pnum} The member ```@_`impls-for`_@<when_all_t>::@_`get-env`_@``` is initialized
> with a callable object equivalent to the following lambda expression:
>
> > ```c++
> > []<class State, class Rcvr>(auto&&, State& state, const Receiver& rcvr) noexcept {
> >   return @@[```@_`see below`_@```]{.rm}[```@_`make-when-all-env`_@(state.@_`stop-src`_@, get_env(rcvr))```]{.add}@@;
> > }
> > ```

::: rm

> [Returns an object `e` such that]{.rm} [These bullet items have been moved above.]{.ednote}
>
> - [6.1]{.pnum} [`decltype(e)` models `queryable`, and]{.rm}
>
> - [6.2]{.pnum} [`e.query(get_stop_token)` is expression-equivalent to
>   ```state.@_`stop-src`_@.get_token()```, and]{.rm}
>
> - [6.3]{.pnum} [given a query object `q` with type other than _cv_
>   `stop_token_t`, `e.query(q)` is expression-equivalent to
>   ```get_env(rcvr).query(q)```.]{.rm}

:::

> [7]{.pnum} The member ```@_`impls-for`_@<when_all_t>::@_`get-state`_@``` is
> initialized with a callable object equivalent to the following lambda
> expression:
>
> > ```c++
> > []<class Sndr, class Rcvr>(Sndr&& sndr, Rcvr& rcvr) noexcept(@_e_@) -> decltype(@_e_@) {
> >   return @_e_@;
> > }
> > ```
>
> where _`e`_ is the expression
>
> > ```c++
> > std::forward<Sndr>(sndr).apply(@_`make-state`_@<Rcvr>())
> > ```
>
> and where _`make-state`_ is the following exposition-only class template:
>
> > ```c++
> > @[`template<class Sndr, class Env>`]{.rm}@
> > @@[```concept @_`max-1-sender-in`_@ = sender_in<Sndr, Env> &&               // exposition only```]{.rm}@@
> >   @[`(tuple_size_v<value_types_of_t<Sndr, Env, tuple, tuple>> <= 1);`]{.rm}@
> >
> > enum class disposition { started, error, stopped };             // exposition only
> >
> > template<class Rcvr>
> > struct make-state {
> >   template<@@[```@_`max-1-sender-in`_@<env_of_t<Rcvr>>```]{.rm}[class]{.add}@@... Sndrs>
> >   auto operator()(auto, auto, Sndrs&&... sndrs) const {
> >     using values_tuple = see below;
> >     using errors_variant = see below;
> >     using stop_callback = stop_callback_for_t<stop_token_of_t<env_of_t<Rcvr>>, on-stop-request>;
> > @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
> > ```
>
> [8]{.pnum} Let _`copy-fail`_ be <span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>
>
> [9]{.pnum} The alias `values_tuple` denotes the type
>
> > ```c++
> > tuple<value_types_of_t<Sndrs, @@[```@_`FWD-ENV-T`_@(```]{.add}@@env_of_t<Rcvr>@[`)`]{.add}@, decayed-tuple, optional>...>
> > ```
>
> if that type is well-formed; otherwise, `tuple<>`.


[Change [exec.when.all]{.sref} para 14 as follows:]{.ednote}

> [14]{.pnum} The expression `when_all_with_variant(sndrs...)` is
> expression-equivalent to:
>
> > ```c++
> > transform_sender(@[`CD()`]{.rm}[`CD2()`]{.add}@, @_`make-sender`_@(when_all_with_variant, {}, sndrs...));
> > ```

[Change [exec.into.variant]{.sref} paras 4-5 as follows (with the change to para 5
being a drive-by fix):]{.ednote}

> [4]{.pnum} The exposition-only class template _`impls-for`_ ([exec.snd.general]{.sref})
> is specialized for _`into_variant`_ as follows:
>
> > ```c++
> > namespace std::execution {
> >   template<>
> >   struct @_`impls-for`_@<into_variant_t> : @_`default-impls`_@ {
> >     static constexpr auto @_`get-state`_@ = @_`see below`_@;
> >     static constexpr auto @_`complete`_@ = @_`see below`_@;
> >
> >     @[`template<class Sndr, class... Env>`]{.add}@
> >     @@[```static consteval void @_`check-types`_@() {```]{.add}@@
> >       @@[```auto cs = get_completion_signatures<@_`child-type`_@<Sndr>, @_`FWD-ENV-T`_@(Env)...>();```]{.add}@@
> >       @@[```@_`decay-copyable-result-datums`_@(cs);```]{.add}@@  // see [exec.snd.expos]{.sref}
> >     @[`}`]{.add}@
> >   };
> > }
> > ```
>
> [5]{.pnum} The member ```@_`impls-for`_@<into_variant_t>::@_`get-state`_@```
> is initialized with a callable object equivalent to the following lambda:
>
> > ```c++
> > []<class Sndr, class Rcvr>(Sndr&& sndr, Rcvr& rcvr) noexcept
> >   -> type_identity<value_types_of_t<@_`child-type`_@<Sndr>, @@[```@_`FWD-ENV-T`_@(```]{.add}@@env_of_t<Rcvr>@[`)`]{.add}@>> {
> >   return {};
> > }
> > ```


[Change [exec.stopped.opt]{.sref} as follows. Note: this includes the proposed resolution to
[cplusplus/sender-receiver#311](https://github.com/cplusplus/sender-receiver/issues/311)]{.ednote}

> [2]{.pnum} The name `stopped_as_optional` denotes a pipeable sender adaptor
> object. For a subexpression `sndr`, let `Sndr` be `decltype((sndr))`. The expression
> `stopped_as_optional(sndr)` is expression-equivalent to:
>
> > ```c++
> > transform_sender(@_`get-domain-early`_@(sndr), @_`make-sender`_@(stopped_as_optional, {}, sndr))
> > ```
>
> except that `sndr` is only evaluated once.
>
> ::: add
>
> [?]{.pnum} [The exposition-only class template _`impls-for`_ ([exec.snd.general]{.sref}) is specialized
> for `stopped_as_optional_t` as follows:]{.add}
>
> > ```c++
> > template<>
> > struct @_`impls-for`_@<stopped_as_optional_t> : @_`default-impls`_@ {
> >   template<class Sndr, class... Env>
> >   static consteval void @_`check-types`_@() {
> >     @_`default-impls`_@::@_`check-types`_@<Sndr, Env...>();
> >     if constexpr (!requires {
> >       requires (!same_as<void, @_`single-sender-value-type`_@<@_`child-type`_@<Sndr>, @_`FWD-ENV-T`_@(Env)...>>); })
> >       throw @_unspecified_@;
> >   }
> > };
> > ```
>
> :::
>
> [3]{.pnum} Let `sndr` and `env` be subexpressions such that `Sndr` is `decltype((sndr))`
> and `Env` is `decltype((env))`. If ```@_`sender-for`_@<Sndr, stopped_as_optional_t>``` is `false`[,
> or if the type ```@_`single-sender-value-type`_@<Sndr, Env>``` is ill-formed or `void`,]{.rm} then
> the expression `stopped_as_optional.transform_sender(sndr, env)` is ill-formed;
> [otherwise, if ```sender_in<@_`child-type`_@<Sndr>, @_`FWD-ENV-T`_@(Env)>``` is `false`,
> the expression `stopped_as_optional.transform_sender(sndr, env)` is equivalent to
> ```@_`not-a-sender`_@()```; ]{.add} otherwise, it is equivalent to:
>
> ```c++
> auto&& [_, _, child] = sndr;
> using V = @_`single-sender-value-type`_@<@@[```@_`child-type`_@<```]{.add}@@Sndr@[`>`]{.add}@, @@[```@_`FWD-ENV-T`_@(```]{.add}@@Env@[`)`]{.add}@>;
> return let_stopped(
>     then(std::forward_like<Sndr>(child),
>          []<class... Ts>(Ts&&... ts) noexcept(is_nothrow_constructible_v<V, Ts...>) {
>            return optional<V>(in_place, std::forward<Ts>(ts)...);
>          }),
>     []() noexcept { return just(optional<V>()); });
> ```


<span class="ednote">Change [exec.sync.wait]{.sref} as follows:</span>

> [4]{.pnum} The name `this_thread::sync_wait` denotes a customization point object. For a
> subexpression `sndr`, let `Sndr` be `decltype((sndr))`. [If 
> ```sender_in<Sndr, @_`sync-wait-env`_@>``` is `false`, the expression
> `this_thread::sync_wait(sndr)` is ill-formed. Otherwise, it]{.rm}
> [The expression `this_thread::sync_wait(sndr)`]{.add} is
> expression-equivalent to the following, except that `sndr` is evaluated only once:
>
> > ```c++
> > apply_sender(@_`get-domain-early`_@(sndr), sync_wait, sndr)
> > ```
> 
> *Mandates*:
> 
> - [4.?]{.pnum} [```sender_in<Sndr, @_`sync-wait-env`_@>``` is ```true```.]{.add}
> 
> - [4.1]{.pnum } The type ```@_`sync-wait-result-type`_@<Sndr>``` is well-formed.
> 
> - [4.2]{.pnum} ```same_as<decltype(@_`e`_@), @_`sync-wait-result-type`_@<Sndr>>```
>    is ```true```, where _`e`_ is the `apply_sender` expression above.</li>
>
>    <span style="color:blue">_...as before_</span>

<span class="ednote">Change [exec.sync.wait.var]{.sref} as follows:</span>

> [1]{.pnum} The name `this_thread::sync_wait_with_variant` denotes a customization point
> object. For a subexpression `sndr`, let `Sndr` be `decltype(into_variant(sndr))`.
> [If ```sender_in<Sndr, @_`sync-wait-env`_@>``` is `false`, the expression
> `this_thread::sync_wait(sndr)` is ill-formed. Otherwise, it]{.rm} [The expression
> `this_thread::sync_wait_with_variant(sndr)`]{.add} is expression-equivalent to the
> following, except that `sndr` is evaluated only once:
> 
> > ```c++
> > apply_sender(@_`get-domain-early`_@(sndr), sync_wait_with_variant, sndr)
> > ```
> 
> *Mandates*:
> 
> - [1.?]{.pnum} [```sender_in<Sndr, @_`sync-wait-env`_@>``` is ```true```.]{.add}
> 
> - [1.1]{.pnum}
>    The type ```@_`sync-wait-with-variant-result-type`_@<Sndr>```
>    is well-formed.
> 
> - [1.2]{.pnum} ```same_as<decltype(@_`e`_@), @_`sync-wait-with-variant-result-type`_@<Sndr>>```
>   is ```true```, where _`e`_ is the `apply_sender` expression above.
> 
> [2]{.pnum} [If ```@_`callable`_@<sync_wait_t, Sndr>``` is `false`, the
>    expression `sync_wait_with_variant.apply_sender(sndr)` is ill-formed.
>    Otherwise, it]{.rm} [The expression
>    `sync_wait_with_variant.apply_sender(sndr)`]{.add} is equivalent to
>    <span style="color:blue">_...as before_</span>



[Change [exec.util.cmplsig]{.sref} para 8 and add a new para after 8 as follows:]{.ednote}


> [8]{.pnum} <div>
>
> ```c++
> namespace std::execution {
>   template<@_`completion-signature`_@... Fns>
>     struct completion_signatures {
>       @@[```template<class Tag>```]{.add}@@
>       @@[```static constexpr size_t @_`count-of`_@(Tag) { return @_`see below`_@; }```]{.add}@@
>
>       @@[```template<class Fn>```]{.add}@@
>         @@[```static constexpr void @_`for-each`_@(Fn&& fn) { // exposition only```]{.add}@@
>           @@[```(std::forward<Fn>(fn)(static_cast<Fns*>(nullptr)), ...);```]{.add}@@
>         @@[```}```]{.add}@@
>     };
>
>   @<span style="color:blue;text-style:italic">&hellip; as before &hellip;</span>@
> }
> ```
>
> </div>

::: add

> [?]{.pnum} [For a subexpression `tag`, let `Tag` be the decayed type of `tag`.
> ```completion_signatures<Fns...>::@_`count-of`_@(tag)``` returns the count of
> function types in `Fns...` that are of the form `Tag(Ts...)` where `Ts` is a
> pack of types.]{.add}

:::

[Remove subclause [exec.util.cmplsig.trans]{.sref}.]{.ednote}

[Change [exec.run.loop.types]{.sref} para 5 as follows:]{.ednote}

> [5]{.pnum} *`run-loop-sender`* is an exposition-only type that satisfies `sender`.
> [For any type `Env`,]{.rm} ```completion_signatures_of_t<@_`run-loop-sender`_[, Env]{.rm}@>``` is
> `completion_signatures<set_value_t(), set_error_t(exception_ptr), set_stopped_t()>`.

Acknowledgements
================

I would like to thank Hana Dusíková for her work making constexpr exceptions a
reality for C++26. Thanks are also due to David Sankel for his encouragement to
investigate using constexpr exceptions as an alternative to TMP hackery, and for
giving feedback on an early draft of this paper.


---
references:
  - id: P3164R4
    citation-label: P3164R4
    title: "Early Diagnostics for Sender Expressions"
    author:
      - family: Niebler
        given: Eric
    URL: https://isocpp.org/files/papers/P3164R4.html

  - id: P3284R4
    citation-label: P3284R4
    title: "`write_env` and `unstoppable` Sender Adaptors"
    author:
      - family: Niebler
        given: Eric
    URL: https://isocpp.org/files/papers/P3284R4.html

  - id: µstdex
    citation-label: µstdex
    title: "µstdex"
    URL: https://github.com/ericniebler/ustdex
---
