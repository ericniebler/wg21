---
title: "High-Quality Sender Diagnostics with Constexpr Exceptions"
document: D3557R1
date: today
audience:
  - "LEWG Library Evolution"
author:
  - name: Eric Niebler
    email: <eric.niebler@gmail.com>
toc: true
---

<div style="text-align: right;">
_"Only the exceptional paths bring exceptional glories!"_<br/>
--- Mehmet Murat Ildan
</div>

Introduction
============

The hardest part of writing a sender algorithm is often the computation of its
completion signatures, an intricate meta-programming task. Using sender
algorithms incorrectly leads to large, incomprehensible errors deep within the
completion-signatures meta-program. What is needed is a way to propagate type
errors automatically to the API boundary where they can be reported concisely,
much the way exceptions do for runtime errors.

Support for exceptions during constant-evaluation was recently accepted into the
Working Draft for C++26. We can take advantage of this powerful new feature to
easily propagate type errors during the computation of a sender's completion
signatures. This significantly improves the diagnostics users are likely to
encounter while also simplifying the job of writing new sender algorithms.

Executive Summary
=================

This paper proposes the following changes to the working draft with the
addition of [@P3164R3]. Subsequent sections will address the motivation
and the designs in detail.

1. Change `std::execution::get_completion_signatures` from a customization
  point object that accepts a sender and (optionally) an environment to
  a `consteval` function template that takes no arguments, as follows:

::: cmptable

### Before
```cpp
inline constexpr struct get_completion_signatures_t {
  template <class Sndr, class... Env>
  auto operator()(Sndr&&, Env&&...) const -> @_`see below`_@;
} get_completion_signatures {};
```

### After
```cpp
template <class Sndr, class... Env>
consteval auto get_completion_signatures()
  -> @_`valid-completion-signatures`_@ auto;
```

:::

2. Change the mechanism by which senders customize `get_completion_signatures`
  from a member function that accepts the _cv_-qualified sender object and an
  optional environment object to a `static constexpr` function template that
  take the sender and environment types as template parameters.

::: cmptable

### Before
```cpp
struct my_sender {
  template <class Self, class... Env>
    requires @_`some-predicate`_@<Self, Env...>
  auto get_completion_signatures(this Self&&, Env&&) {
    return completion_signatures</* … */>();
  }
  ...
};
```

### After
```cpp
struct my_sender {
  template <class Self, class... Env>
  static constexpr auto get_completion_signatures() {
    if constexpr (!@_`some-predicate`_@<Self, Env...>) {
      throw @_`a-helpful-diagnostic`_@(); // <--- LOOK!
    }
    return completion_signatures</* … */>();
  }
  ...
};
```

:::

3. Change the `sender_in<Sender, Env...>` concept to test that
  `get_completion_signatures<Sndr, Env...>()` is a constant expression.

::: cmptable

### Before
```cpp
template<class Sndr, class... Env>
concept sender_in =
  sender<Sndr> &&
  (queryable<Env> &&...) &&
  requires (Sndr&& sndr, Env&&... env) {
    { get_completion_signatures(
        std::forward<Sndr>(sndr),
        std::forward<Env>(env)...) }
            -> @_`valid-completion-signatures`_@;
  };
```

### After
```cpp
template <auto>
concept @_`is-constant`_@ = true; // exposition only

template<class Sndr, class... Env>
concept sender_in =
  sender<Sndr> &&
  (queryable<Env> &&...) &&
  @_`is-constant`_@<get_completion_signatures<Sndr, Env...>()>;
```

:::

4. In the exposition-only _`basic-sender`_ class template, specify under what
  conditions its `get_completion_signatures` static member function is
  ill-formed when called without an `Env` template parameter (see proposed
  wording for details).

5. Add a `dependent_sender` concept that is modeled by sender types that do not
  know how they will complete independent of their execution environment.

6. \[Optional]: Remove the `transform_completion_signatures` alias template.

The following additions are suggested by this paper to make working with
completion signatures in `constexpr` code easier. None of these additions is
strictly necessary.

* Extend the [`completion_signatures`](#completion_signatures) class template
  with `constexpr` operations that make the manipulation of completion
  signatures more ergonomic. These extensions are:

  - Combining two sets of completion signatures with `operator+`. Alternative:
    provide a variadic `concat_completion_signatures` function.

  - Treating an instance of a completion signatures specialization as a tuple
    of function pointers. For example, `completion_signatures<set_value_t(int), set_stopped_t()>{}`
    would be usable as if it were `tuple<set_value_t(*)(), set_stopped_t(*)()>{nullptr, nullptr}`,
    making `std::apply` useful for manipulating completion signatures.

  - Adding CTAD to `completion_signatures` to deduce the signature types from a
    list of function pointers. Together with the above item, the following is
    the identity transform, given a `completion_signatures` object `cs`:

    > ```cpp
    > auto cs2 = std::apply([](auto... sigs){ return completion_signatures{sigs...}; }, cs);
    > static_assert(std::same_as<decltype(cs), decltype(cs2)>);
    > ```

* Add a [`make_completion_signatures`](#make_completion_signatures) helper
  function that takes signatures as template arguments or as function arguments
  or both. The returned value would have signatures that have been normalized,
  sorted ([@P2830R7]), and made unique.

* Add a [`get_child_completion_signatures`](#get_child_completion_signatures)
  function template that makes it easy for a sender adaptor to get the completion
  signatures of the child sender with the proper _cv_ qualification. It is
  simply:

  > ```cpp
  > template <class Parent, class Child, class... Env>
  > consteval auto get_child_completion_signatures() {
  >   using CvChild = decltype(std::forward_like<Parent>(declval<Child&>()));
  >   return get_completion_signatures<CvChild, @_`FWD-ENV`_@(Env)...>();
  > }
  > ```

* Reintroduce
  [`transform_completion_signatures`](#transform_completion_signatures) as a
  `constexpr` function template that accepts lambdas as transforms. For example,
  the following code removes all error completions from a set, `cs`:

  > ```cpp
  > auto cs2 = transform_completion_signatures(
  >   cs,
  >   {}, // accept the default value completion transform
  >   []<class Error>() { return completion_signatures(); });
  > ```

  See [`transform_completion_signatures`](#transform_completion_signatures) for
  a design description and reference implementation of the
  `transform_completion_signatures` function template.

* Add an [`invalid_completion_signature`](#invalid_completion_signature)
  `consteval` function template whose return type is `completion_signatures<>`
  but that throws an unspecified exception type that contains diagnostic
  information. The `read_env` sender might use it as follows:

  > ```cpp
  > template <class Q>
  > template <class Self, class Env>
  > static constexpr auto read_env_sender<Q>::get_completion_signatures() {
  >   namespace exec = std::execution;
  >   if constexpr (!std::invocable<Q, Env>) {
  >     // return type deduced to be completion_signatures<> but function exits
  >     // with an exception that contains the relevant diagnostic information.
  >     return exec::invalid_completion_signature<
  >        _IN_ALGORITHM<read_env>,
  >        _WITH_QUERY(Q),
  >        _WITH_ENVIRONMENT(Env)
  >     >("The environment does not provide a value for the given query type.");
  >   } else {
  >     using Result = std::invoke_result_t<Q, Env>;
  >     return exec::completion_signatures<exec::set_value_t(Result)>();
  >   }
  > }
  > ```

Revision History
================

R1
----

Since R0, a significant fraction of C++26's `std::execution` has been
implemented with the design changes proposed by this paper. Several bugs in R0
have been found and fixed as a result.

In addition, this paper exposed [several
bugs](https://github.com/cplusplus/sender-receiver/issues/317) in the Working
Draft for C++26. As those bugs relate to the computation of completion
signatures, R1 integrates the proposed fixes for those bugs.

* Fix the specification of `std::execution::get_completion_signatures` which was
  the victim of an incomplete last-minute edit.
* Add support for awaitables, which was dropped accidentally, back to
  `get_completion_signatures`.
* Change proposed replacement for `transform_completion_signatures` to take
  a transform function for the stopped completion signature instead of
  a `completion_signatures` object.
* Add missing semantic constraints to ```@_`impls-for`_@<Tag>::@_`check-types`_@```
  customizations.
* Add missing syntactic constraint on ```@_`basic-sender`_@<Tag>::get_completion_signatures```.
* Strengthen the _Mandates_ on `std::execution::connect`.
* Fixed the constraint on `stopped_as_optional.transform_sender(sndr, env)`.
* Report type errors from the `let_*`, `schedule_from`, `into_variant`, `split`,
  and `when_all` algorithms when the prececessor's result datums cannot be
  copied into intermediate storage.
* Integrate proposed fix for [cplusplus/sender-receiver#311](https://github.com/cplusplus/sender-receiver/issues/311),
  "`stopped_as_optional` tests constraints satisfaction of self instead of child".
* Integrate proposed fix for [cplusplus/sender-receiver#317](https://github.com/cplusplus/sender-receiver/issues/317),
  "Several algorithms are not applying _`FWD-ENV`_ as they should".
* Fix paragraph numbering.

R0
----

* Initial revision

Motivation
==========

This paper exists principly to improve the experience of users who make type
errors in their sender expressions by leveraging exceptions during constant-
evaluation. It is a follow-on of [@P3164R2], which defines a category of
"non-dependent" senders that can and must be type-checked early.

Senders have a construction phase and a subsequent connection phase. Prior to
P3164, all type-checking of senders happened at the connection phase (when a
sender is connected to a receiver). P3164 mandates that the sender algorithms
type-check non-dependent senders, moving the diagnostic closer to the source of
the error.

This paper addresses the _quality_ of those diagnostics and the diagnostics
users encounter when a dependent sender fails type-checking at connection time.

Senders are expression trees, and type errors can happen deep within their
structure. If programmed naively, ill-formed senders would generate megabytes of
incomprehensible diagnostics. The challenge is to report type errors _concisely_
and _comprehensibly_, at the right level of abstraction.

Doing this requires propagating domain-specific descriptions of type errors out
of the completion signatures meta-program so they can be reported concisely.
Such error detection and propagation is very cumbersome in template
meta-programming.

The C++ solution to error propagation is exceptions. With the adoption of
[@P3068R6], C++26 has gained the ability to throw and catch exceptions during
constant-evaluation. If we express the computation of completion signatures as a
`constexpr` meta-program, we can use exceptions to propagate type errors. This
greatly improves diagnostics and even simplifies the code that computes
completion signatures.

This paper proposes changes to `std::execution` that make the computation
of a sender's completion signatures an evaluation of a `constexpr` function.
It also specifies the conditions under which the computation is to exit
with an exception.

Proposed Design, Necessary Changes
==================================

`get_completion_signatures`
---------------------------

In the Working Draft, a sender's completion signatures are determined by the
type of the expression `std::execution::get_completion_signatures(sndr, env)`
(or, after P3164, `std::execution::get_completion_signatures(sndr)` for
non-dependent senders). Only the type of the expression matters; the expression
itself is never evaluated.

In the design proposed by this paper, the `get_completion_signatures` expression
must be constant-evaluated in order use exceptions to report errors. To
make it ammenable to constant evaluation, it must not accept arguments with
runtime values, so the expression is changed to
`std::execution::get_completion_signatures<Sndr, Env...>()`, where
`get_completion_signatures` is a `consteval` function.

If an unhandled exception propagates out of `get_completion_signatures` the
program is ill-formed (because `get_completion_signatures` is `consteval`). The
diagnostic displays the type and value of the exception.

`std::execution::get_completion_signatures<Sndr, Env...>()` in turn calls
<code>remove_reference_t&lt;Sndr>::template get_completion_signatures&lt;Sndr,
Env\...>()</code>, which computes the completion signatures or throws as
appropriate, as shown below:

> ```cpp
> namespace exec = std::execution;
>
> struct void_sender {
>   using sender_concept = exec::sender_t;
>
>   template <class Self, class... Env>
>   static constexpr auto get_completion_signatures() {
>     return exec::completion_signatures<exec::set_value_t()>();
>   }
>
>   /* … more … */
> };
> ```

To better support the `constexpr` value-oriented programming style, calls to
`get_completion_signatures` from a `constexpr` function are never ill-formed,
and they always have a `completion_signatures` type. `get_completion_signatures`
reports errors by failing to be a constant expression.

### Non-non-dependent senders

[@P3164R3] introduces the concept of non-dependent senders: senders that have
the same completion signatures regardless of the receiver's execution
environment. For a sender type `DependentSndr` whose completions _do_ depend on
the environment, what should happen when the sender's completions are queried
without an environment? That is, what should the semantics be for
`get_completion_signatures<DependentSndr>()`?

`get_completion_signatures<DependentSndr>()` should follow the general rule: it
should be well-formed in a `constexpr` function, and it should have a
`completion_signatures` type. That way, sender adaptors do not need to do
anything special when computing the completions of child senders that are
dependent. So `get_completion_signatures<DependentSndr>()` should throw.

If `get_completion_signatures<Sndr>()` throws for dependent senders, and it also
throws for non-dependent senders that fail to type-check, how then do we
distinguish between valid dependent and invalid non-dependent senders? We can
distinguish by checking the type of the exception.

An example will help. Consider the `read_env(q)` sender, a dependent sender that
sends the result of calling `q` with the receiver's environment. It cannot
compute its completion signatures without an environment. The natural way for
the `read_env` sender to express that is to require an `Env` parameter to its
customization of `get_completion_signatures`:

> ```cpp
> namespace exec = std::execution;
>
> template <class Query>
> struct read_env_sender {
>   using sender_concept = exec::sender_t;
>
>   template <class Self, class Env> // NOTE: Env is not optional!
>   static constexpr auto get_completion_signatures() {
>     if constexpr (!std::invocable<Query, Env>) {
>       throw @_`exception-type-goes-here`_@();
>     } else {
>       using Result = std::invoke_result_t<Query, Env>;
>       return exec::completion_signatures<exec::set_value_t(Result)>();
>     }
>   }
>
>   /* … more … */
> };
> ```

That makes `read_env_sender<Q>::get_completion_signatures<Sndr>()` an ill-formed
expression, which the `get_completion_signatures` function can detect. In such
cases, it would throw an exception of a special type that it can catch later
when distinguishing between dependent and non-dependent senders.

### Implementation

Since the design has several parts, reading the implementation of
`get_completion_signatures` is probably the easiest way to understand it. The
implementation is shown below with comments describing the parts.

> ```cpp
> // This macro expands to an invocation of SNDR's get_completion_signatures
> // customization.
> #define GET_COMPLSIGS(SNDR, ...) std::remove_reference_t<SNDR>::template      \
>     get_completion_signatures<SNDR __VA_OPT__(,) __VA_ARGS__>()
>
> // This macro expands to an evaluation of EXPR, followed by an invocation
> // of the _checked_complsigs function which validates its type.
> #define CHECK_COMPLSIGS(EXPR) (EXPR, _check_complsigs<decltype(EXPR)>())
>
> template <class Sndr>
> using _nested_complsigs_t = std::remove_reference_t<Sndr>::completion_signatures;
>
> // This helper ensures that the passed type is indeed a specialization of the
> // completion_signatures class template, and throws if it is not.
> template <class Completions>
> consteval auto _check_complsigs() {
>   if constexpr (_valid_completion_signatures<Completions>)
>     // We got a type that is a specialization of the completion_signatures
>     // class template representing the sender's completions. Return it.
>     return Completions();
>   else
>     // invalid_completion_signature throws unconditionally. Its return type
>     // is `completion_signatures<>`, which prevents downstream errors that
>     // would occur in other customizations of `get_completion_signatures`
>     // if computing the completions of a child returned an object with a
>     // surprising type.
>     return invalid_completion_signature<@_`unspecified`_@>(@_`unspecified`_@);
> }
>
> template <class Sndr, class... Env>
> consteval auto _get_completion_signatures_helper() {
>   // The following `if` tests whether GET_COMPLSIGS(Sndr, Env...)
>   // is a well-formed expression.
>   if constexpr (requires { GET_COMPLSIGS(Sndr, Env...); }) {
>     // The GET_COMPLSIGS(Sndr, Env...) expression is well-formed, but it may
>     // throw an exception or otherwise fail to be a constant expression.
>     // By evaluating it, we cause its exception and its non-constexpr-ness to
>     // propagate. Then CHECK_COMPLSIGS ensures that its type is indeed
>     // a specialization of the completion_signatures class template.
>     return CHECK_COMPLSIGS(GET_COMPLSIGS(Sndr, Env...));
>   }
>   // The following `if` does the same as above, but for GET_COMPLSIGS(Sndr).
>   // A non-dependent sender may announce itself by way of this signature.
>   else if constexpr (requires { GET_COMPLSIGS(Sndr); }) {
>     // Same as above: propagate any exceptions and non-constexpr-ness, and
>     // verify the expression has the right type.
>     return CHECK_COMPLSIGS(GET_COMPLSIGS(Sndr));
>   }
>   // Test whether Sndr has a nested ::completion_signatures type alias:
>   else if constexpr (requires { _nested_complsigs_t<Sndr>(); }) {
>     // It has the nested type alias, but does it denote a specialization of
>     // the completion_signatures class template?
>     return CHECK_COMPLSIGS(_nested_complsigs_t<Sndr>());
>   }
>   // If none of the above expressions are well-formed, then we don't know
>   // the sender's completions. If we are testing without an environment, then
>   // we assume Sndr is a dependent sender. Throw an exception that
>   // communicates that.
>   else if constexpr (sizeof...(Env) == 0) {
>     return (throw @_`dependent-sender-error`_@(), completion_signatures());
>   }
>   else {
>     // We cannot compute the completion signatures for this sender and
>     // environment. Give up and throw an exception.
>     return invalid_completion_signature<@_`unspecified`_@>(@_`unspecified`_@);
>   }
> }
>
> template <class Sndr>
> consteval auto get_completion_signatures() -> _valid_completion_signatures auto {
>   // There is no environment, which means we are asking for the sender's non-
>   // dependent completion signatures. If the sender is dependent, this will
>   // exit with a special exception type.
>   return _get_completion_signatures_helper<Sndr>();
> }
>
> template <class Sndr, class Env>
> consteval auto get_completion_signatures() -> _valid_completion_signatures auto {
>   // Apply a lazy sender transform if one exists before computing the completion signatures:
>   using Domain = decltype(_get_domain_late(std::declval<Sndr>(), std::declval<Env>()));
>   using NewSndr = decltype(transform_sender(Domain(), std::declval<Sndr>(), std::declval<Env>()));
>
>   return _get_completion_signatures_helper<NewSndr, Env>();
> }
> ```

Given this definition of `get_completion_signatures`, we can implement
a `dependent_sender` concept as follows:

> ```cpp
> // Returns true when get_completion_signatures<Sndr>() throws a
> // dependent-sender-error. Returns false when
> // get_completion_signatures<Sndr>() returns normally (Sndr is non-dependent),
> // or when it throws any other kind of exception (Sndr fails type-checking).
> template <class Sndr>
> consteval bool @_`is-dependent-sender-helper`_@() try {
>   (void) get_completion_signatures<Sndr>();
>   return false;
> } catch (@_`dependent-sender-error`_@&) {
>   return true;
> }
>
> template <class Sndr>
> concept dependent_sender =
>   sender<Sndr> && std::bool_constant<@_`is-dependent-sender-helper`_@<Sndr>()>::value;
> ```

After the adoption of [@P3164R3], the sender algorithms are all required to
return senders that are either dependent or else that type-check successfully.
This paper proposes adding that type-checking as a _Mandates_ on the
exposition-only _`make-sender`_ function template that all the algorithms use
to

> ```cpp
> template <class Sndr>
> constexpr auto _type_check_sender(Sndr sndr) {
>   if constexpr (!dependent_sender<Sndr>) {
>     // This line will fail to compile if Sndr fails its type checking. We
>     // don't want to perform this type checking when Sndr is dependent, though.
>     // Without an environment, the sender doesn't know its completions.
>     (void) get_completion_signatures<Sndr>();
>   }
>   return sndr;
> }
> ```

Sender algorithms could use this helper when returning the new sender.
For example, a `then` algorithm might look something like this:

> ```cpp
> inline constexpr struct then_t : _pipeable_sender_adaptor<then_t> {
>   template <sender Sndr, class Fn>
>   auto operator()(Sndr sndr, Fn fn) const {
>     return _type_check_sender(_then_sender{std::move(sndr), std::move(fn)});
>   }
> } then {};
> ```

`sender_in`
-----------

With the above changes, we need to tweak the `sender_in` concept to require
that `get_completion_signatures<Sndr, Env...>()` is a constant expression.

The changes to `sender_in` relative to [@P3164R3] are as follows:

> ```cpp
> @[`template <auto>`]{.add}@
>   @@[`concept @_is-constant_@ = true; @_// exposition only_@`]{.add}@@
>
> template<class Sndr, class... Env>
>   concept sender_in =
>     sender<Sndr> &&
>     (sizeof...(Env) <= 1)
>     (queryable<Env> &&...) &&
>     @@[`@_is-constant_@<get_completion_signatures<Sndr, Env...>()>;`]{.add}@@
>     @[`requires (Sndr&& sndr, Env&&... env) {`]{.rm}@
>       @[`{ get_completion_signatures(std::forward<Sndr>(sndr), std::forward<Env>(env)...) }`]{.rm}@
>         @@[`-> @_valid-completion-signatures_@;`]{.rm}@@
>     @[`};`]{.rm}@
> ```

_`basic-sender`_
----------------

The sender algorithms are expressed in terms of the exposition-only class
template _`basic-sender`_. The mechanics of computing completion signatures is
not specified, however, so very little change there is needed to implement this
proposal.

We do, however, have to say when
<code><em>basic-sender</em>::get_completion_signatures&lt;Sndr>()</code> is
ill-formed. In [@P3164R3], non-dependent senders are dealt with by discussing
whether or not a sender's potentially-evaluated completion operations are
dependent on the type of the receiver's environment. In this paper, we make a
similar appeal when specifying whether or not
<code><em>basic-sender</em>::get_completion_signatures&lt;Sndr>()</code> is
well-formed.

`dependent_sender`
------------------

Users who write their own sender adaptors will also want to perform early
type-checking of senders that are not dependent. Therefore, they need a way
to determine whether or not a sender is dependent.

In the section [`get_completion_signatures`](#get_completion_signatures) we show
how the concept `dependent_sender` can be implemented in terms of this paper's
`get_completion_signatures` function template. By making this a public-facing
concept, we give sender adaptor authors a way to do early type-checking, just
like the standard adaptors.

Proposed Design, Nice-to-haves
==============================

`completion_signatures`
-----------------------

Computing completions signatures is now to be done using `constexpr`
meta-programming by manipulating values using ordinary imperative C++ rather
than template meta-programming. To better support this style of programming,
it is helpful to add `constexpr` operations that manipulate instances of
specializations of the `completion_signatures` class template.

For example, it should be possible to take the union of two sets of completion
signatures. `operator+` seems like a natural choice for that:

> ```cpp
> completion_signatures<set_value_t(int), set_error_t(exception_ptr)> cs1;
> completion_signatures<set_stopped_t(), set_error_t(exception_ptr)> cs2;
>
> auto cs3 = cs1 + cs2; // completion_signatures<set_value_t(int),
>                       //                       set_error_t(exception_ptr),
>                       //                       set_stopped_t()>
> ```

It can also be convenient for `completion_signatures` specializations to model
[_`tuple-like`_](https://en.cppreference.com/w/cpp/utility/tuple/tuple-like).
Although tuple elements cannot have funtion type, they can have function
_pointer_ type. With this proposal, an object like
`completion_signatures<set_value_t(int), set_stopped_t()>{}` behaves like
`tuple<set_value_t(*)(int), set_stopped_t(*)()>{nullptr, nullptr}` (except that
it wouldn't actually have to store the `nullptr`s). That would make it possible
to manipulate completion signatures using `std::apply`:

> ```cpp
> auto cs = /* … */;
>
> // Add an lvalue reference to all arguments of all signatures:
> auto add_ref =     []<class T, class... As>(T(*)(As...)) -> T(*)(As&...) { return {}; };
> auto add_ref_all = [=](auto... sigs) { return make_completion_signatures(add_ref(sigs)...); };
>
> return std::apply(add_ref_all, cs);
> ```

The code above uses another nice-to-have feature: a `make_completion_signatures`
helper function that deduces the signatures from the arguments, removes any
duplicates, and returns a new instance of `completion_signatures`.

Consider trying to do all the above using template meta-programming. &#x1F62C;

`make_completion_signatures`
----------------------------

The `make_completion_signatures` helper function described just above would allow
users to build a `completion_signatures` object from a bunch of signature types,
or from function pointer objects, or a combination of both:

> ```cpp
> // Returns a default-initialized object of type completion_signatures<Sigs...>,
> // where Sigs is the set union of the normalized ExplicitSigs and DeducedSigs.
> template <@_`completion-signature`_@... ExplicitSigs, @_`completion-signature`_@... DeducedSigs>
> constexpr auto make_completion_signatures(DeducedSigs*... sigs) noexcept
>   -> @_`valid-completion-signatures`_@ auto;
> ```

To "normalize" a completion signature means to strip rvalue references from the
arguments. So, `set_value_t(int&&, float&)` becomes `set_value_t(int, float&)`.
`make_completions_signatures` first normalizes all the signatures and then
removes duplicates. ([@P2830R7] lets us order types, so making the set unique
will be _O_(_n_ log _n_).)

`transform_completion_signatures`
---------------------------------

The current Working Draft has a utility to make type transformations of
completion signature sets simpler: the alias template
`transform_completion_signatures`. It looks like this:

> ```cpp
> template <class... As>
> using @_value-transform-default_@ = completion_signatures<set_value_t(As...)>;
>
> template <class Error>
> using @_error-transform-default_@ = completion_signatures<set_error_t(Error)>;
>
> template <@_valid-completion-signatures_@ Completions,
>           @_valid-completion-signatures_@ OtherCompletions = completion_signatures<>,
>           template <class...> class ValueTransform = @_value-transform-default_@,
>           template <class> class ErrorTransform = @_error-transform-default_@,
>           @_valid-completion-signatures_@ StoppedCompletions = completion_signatures<set_stopped_t()>>
> using transform_completion_signatures = /*see below*/;
> ```

Anything that can be done with `transform_completion_signatures` can be done in
`constexpr` using `std::apply`, a lambda with `if constexpr`, and `operator+` of
`completion_signatures` objects. In fact, we could even implement
`transform_completion_signatures` itself that way:

> ```cpp
> template </* … as before … */>
> using transform_completion_signatures =
>   std::constant_wrapper< // see @@[@P2781R5]@@
>     std::apply(
>       [](auto... sigs) {
>         return ([]<class T, class... As>(T (*)(As...)) {
>           if constexpr (^^T == ^^set_value_t) { // use reflection to test type equality
>             return ValueTransform<As...>();
>           } else if constexpr (^^T == ^^set_error_t) {
>             return ErrorTransform<As...[0]>();
>           } else {
>             return StoppedCompletions();
>           }
>         }(sigs) +...+ completion_signatures());
>       },
>       Completions()
>     ) + OtherCompletions()
>   >::value_type;
> ```

This paper proposes dropping the `transform_completion_signatures` type alias
since it is not in the ideal form for `constexpr` meta-programming, and since
`std::apply` is good enough (sort of).

However, should we decide to keep the functionality of
`transform_completion_signatures`, we can reexpress it as a `constexpr` function
that accepts transforms as lambdas:

> ```cpp
> constexpr auto @_value-transform-default_@ = []<class... As>() { return completion_signatures<set_value_t(As...)>(); };
> constexpr auto @_error-transform-default_@ = []<class Error>() { return completion_signatures<set_error_t(Error)>(); };
> constexpr auto @_stopd-transform-default_@ = [] { return completion_signatures<set_stopped_t()>(); };
>
> template <@_valid-completion-signatures_@ Completions,
>           class ValueTransform = decltype(@_value-transform-default_@),
>           class ErrorTransform = decltype(@_error-transform-default_@),
>           @_`callable`_@ StopdTransform = decltype(@_stopd-transform-default_@),
>           @_valid-completion-signatures_@ OtherCompletions = completion_signatures<>>
> consteval auto transform_completion_signatures(Completions completions,
>                                                ValueTransform value_transform = {},
>                                                ErrorTransform error_transform = {},
>                                                StopdTransform stopd_transform = {},
>                                                OtherCompletions other_completions = {})
>   -> @_valid-completion-signatures_@ auto;
> ```

The above form of `transform_completion_signatures` is more natural to use from
within a `constexpr` function. It also makes it simple to accept the default for
some arguments as shown below:

> ```cpp
> // Transform just the error completion signatures:
> auto cs2 = transform_completion_signatures(cs, {}, []<class E>() { return /* … */; });
>                                            //  ^^  Accept the default value transform
> ```

Since accepting the default transforms is simple, we are able to move the
infrequently used `OtherCompletions` argument to the end of the argument list.

A faithful mapping of the old alias template to the new function template would
take a `completion_signatures` object for the stopped completions instead of a
stopped transform function. After all, what is the point of a nullary callable
that returns a `completion_signatures` object when you could just pass the
object itself directly? The reason is because the stopped transform function
might want to throw an exception. That is why the
`transform_completion_signatures` function template takes 3 transform functions
instead of two functions and a `completion_signatures` object.

Although the signature of this `transform_completion_signatures` function looks
frightful, the implementation is quite straightforward, and seeing it might
make it less scary:

> ```cpp
> // A concept that is modeled by lambdas like the following:
> //   []<class... Ts>() { return completion_signatures<...>(); }
> template <class Fn, class... As>
> concept __meta_transform_with = requires (const Fn& fn) {
>   { fn.template operator()<As...>() } -> __valid_completion_signatures;
> };
>
> template <class... As, class Fn>
> consteval auto __apply_transform(const Fn& fn) {
>   if constexpr (sizeof...(As) == 0)
>     return fn();
>   else if constexpr (__meta_transform_with<Fn, As...>)
>     return fn.template operator()<As...>();
>   else
>     return invalid_completion_signature< @...@ >( @...@ ); // see below
> }
>
> template < /* @...@ as shown above @...@ */ >
> consteval auto transform_completion_signatures(Completions completions,
>                                                ValueTransform value_transform,
>                                                ErrorTransform error_transform,
>                                                StopdTransform stopd_transform,
>                                                OtherCompletions other_completions) {
>   auto transform1 = [=]<class T, class... As>(Tag(*)(As...)) {
>     if constexpr (Tag() == set_value) // see "@[Completion tag comparison](#completion-tag-comparison)@" below
>       return __apply_transform<As...>(value_transform);
>     else if constexpr (Tag() == set_error)
>       return __apply_transform<As...>(error_transform);
>     else
>       return __apply_transform<As...>(stopd_transform);
>   };
>
>   auto transform_all = [=](auto*... sigs) {
>     return (transform1(sigs) +...+ completion_signatures());
>   };
>
>   return std::apply(transform_all, completions) + other_completions;
> }
> ```

Like `get_completion_signatures`, `transform_completion_signatures` always
returns a specialization of `completion_signatures` and reports errors by
throwing exceptions. It expects the lambdas passed to it to do likewise (but
handles it gracefully if they don't).

`invalid_completion_signature`
------------------------------

The reason for the design change is to permit the reporting of type errors using
exceptions. Let's look at an example where it would be desirable to throw an
exception from `get_completion_signatures`: the `then` algorithm. We will use
this example to motivate the rest of the design changes.

The `then` algorithm attaches a continuation to an async operation that executes
when the operation completes successfully. With this proposal, a `then_sender`'s
`get_completion_signatures` customization might be implemented as follows:

> ```cpp
> template <class Sndr, class Fun>
> template <class Self, class... Env>
> constexpr auto then_sender<Sndr, Fun>::get_completion_signatures() {
>   // compute the completions of the (properly cv-qualified) child:
>   using Child = decltype(std::forward_like<Self>(declval<Sndr&>()));
>   auto child_completions = get_completion_signatures<Child, decltype(@_`FWD-ENV`_@(declval<Env>()))...>();
>
>    // This lambda is used to transform value completion signatures:
>   auto value_transform = []<class... As>() {
>     if constexpr (std::invocable<Fun, As...>) {
>       using Result = std::invoke_result_t<Fun, As...>;
>       return completion_signatures<set_value_t(Result)>();
>     } else {
>       // Oh no, the user made an error! Tell them about it.
>       throw @_`some-exception-object`_@;
>     }
>   };
>
>   // Transform just the value completions:
>   return transform_completion_signatures(child_completions, value_transform);
> }
> ```

We would like to make it dead simple to throw an exception that will convey a
domain-specific diagnostic to the user. That way, the authors of sender
algorithms will be more likely to do so.

The `invalid_completion_signature` helper function is designed to make generating
meaningful diagnostics easy. As an example, here is how the `then_sender`'s
`completion_signatures` customization might use it:

> ```cpp
> template <const auto&> struct IN_ALGORITHM;
>
> template <class Sndr, class Fun>
> template <class Self, class... Env>
> constexpr auto then_sender<Sndr, Fun>::get_completion_signatures() {
>   /* … */
>   // This lambda is used to transform value completion signatures:
>   auto value_transform = []<class... As>() {
>     if constexpr (std::invocable<Fun, As...>) {
>       using Result = std::invoke_result_t<Fun, As...>;
>       return completion_signatures<set_value_t(Result)>();
>     } else {
>       // Oh no, the user made an error! Tell them about it.
>       return invalid_completion_signature<
>         IN_ALGORITHM<std::execution::then>,
>         struct WITH_FUNCTION(Fun),
>         struct WITH_ARGUMENTS(As...)
>       >("The function passed to std::execution::then is not callable "
>         "with the values sent by the predecessor sender.");
>     }
>   };
>   /* … */
> }
> ```

When the user of `then` makes a mistake, say like with the expression
"`just(42) | then([]() {…})`", they will get a helpful diagnostic like
the following (relevant bits highlighted):

<blockquote>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">
<span><b>&lt;source&gt;:658:3: </b><b><span style="color:red">error: </span></b><b>call to immediate function 'operator|&lt;just_sender&lt;int&gt;&gt;'
is not a constant expression</b></span>
  658 |   just(<span style="color:green">42</span>) | then([](){})
      | <b><span style="color:green">  ^</span></b>
<span><b><span style="color:green"></span></b><b>&lt;source&gt;:564:14: </b><b><span style="color:cyan">note: </span></b>'operator|&lt;just_sender&lt;int&gt;&gt;' is an immediate function be
cause its body contains a call to an immediate function '__type_check_sender&lt;the
n_sender&lt;just_sender&lt;int&gt;, (lambda at &lt;source&gt;:658:19)&gt;&gt;' and that call is not a
constant expression</span>
  564 |       <span style="color:blue">return</span> __type_check_sender(then_sender{{}, self.fn_, sndr});
      | <b><span style="color:green">             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></b>
<span><b><span style="color:green"></span></b><b>&lt;source&gt;:358:11: </b><b><span style="color:cyan">note: </span></b>unhandled exception of type '__sender_type_check_failure&lt;
const char *, <span style="background-color:yellow">IN_ALGORITHM&lt;then&gt;, WITH_FUNCTION ((lambda at &lt;source&gt;:658:19)), W
ITH_ARGUMENTS (int)&gt;' with content {&amp;"The function passed to std::execution::the
n is not callable with the values sent by the predecessor sender."[0]}</span> thrown fr
om here</span>
  358 |     <span style="color:blue">throw</span> __sender_type_check_failure&lt;Values...[<span style="color:green">0</span>], What...&gt;(values...);
      | <b><span style="color:green">          ^</span></b>
<b><span style="color:green"></span></b>1 error generated.
Compiler returned: 1</code></pre></div>
</blockquote>

The above is the _complete_ diagnostic, regardless of how deeply nested the type error
is. So long, megabytes of template spew!

Lambdas passed to `transform_completion_signatures` _should_ return a
`completion_signatures` specialization (although
`transform_completion_signatures` recovers gracefully when they do not). The
return type of `invalid_completion_signature` is `completion_signatures<>`. By
"returning" the result of calling `invalid_completion_signature`, the deduced
return type of the lambda is a `completion_signatures` type, as it should be.

A possible implementation of the `invalid_completion_signature` function is
shown below:

> ```cpp
> template <class... What, class... Args>
> struct @_sender-type-check-failure_@ : std::exception { // exposition only
>   constexpr @_sender-type-check-failure_@(Args... args) : @*args_*@{std::move(args)...} {}
>   constexpr char const* what() const noexcept override { return @_unspecified_@; };
>   std::tuple<Args...> @*args_*@; // exposition only
> };
>
> template <class... What, class... Args>
> [[noreturn, nodiscard]]
> consteval completion_signatures<> invalid_completion_signature(Args... args) {
>   throw @_sender-type-check-failure_@<What..., Args...>{std::move(args)...};
> }
> ```

`get_child_completion_signatures`
---------------------------------

In the `then_sender` above, computing a child sender's completion signatures is a little awkward:

> ```cpp
> // compute the completions of the (properly cv-qualified) child:
> using Child = decltype(std::forward_like<Self>(declval<Sndr&>()));
> auto child_completions = get_completion_signatures<Child, decltype(@_`FWD-ENV`_@(declval<Env>()))...>();
> ```

Computing the completions of child senders will need to be done by every sender
adaptor algorithm. We can make this simpler with a
`get_child_completion_signatures` helper function:

> ```cpp
> // compute the completions of the (properly cv-qualified) child:
> auto child_completions = get_child_completion_signatures<Self, Sndr, Env...>();
> ```

... where `get_child_completion_signatures` is defined as follows:

> ```cpp
> template <class Parent, class Child, class... Env>
> consteval auto get_child_completion_signatures() {
>   using @_cvref-child-type_@ = decltype(std::forward_like<Parent>(declval<Child&>()));
>   return get_completion_signatures<@_cvref-child-type_@, decltype(@_`FWD-ENV`_@(declval<Env>()))...>();
> }
> ```

Completion tag comparison
-------------------------

For convenience, we can make the completion tag types equality-comparable with
each other. When writing sender adaptor algorithms, code like the following will
be common:

> ```cpp
> []<class Tag, class... Args>(Tag(*)(Args...)) {
>   if constexpr (std::is_same_v<Tag, exec::set_value_t>) {
>     // Do something
>   }
>   else {
>     // Do something else
>   }
> }
> ```

Although certainly not hard, with reflection the tag type comparison becomes a
litte simpler:

> ```cpp
>   if constexpr (^^Tag == ^^exec::set_value_t>) {
> ```

We can make this even easier by simply making the completion tag types
equality-comparable, as follows:

> ```cpp
>   if constexpr (Tag() == exec::set_value) {
> ```

The author finds that this makes his code read better. Tag types would compare
equal to themselves and not-equal to the other two tag types.

`eptr_completion_if`
--------------------

The following is a trivial utility that the author finds he uses surprisingly
often. Frequently an async operation can complete exceptionally, but only
under certain conditions. In cases such as those, it is necessary to add a
`set_error_t(std::exception_ptr)` signature to the set of completions, but only
when the condition is met.

This is made simpler with the following variable template:

> ```cpp
> template <bool PotentiallyThrowing>
> inline constexpr auto eptr_completion_if =
>   std::conditional_t<PotentiallyThrowing,
>                      completion_signatures<set_error_t(exception_ptr)>,
>                      completion_signatures<>>();
> ```

Below is an example usage, from the `then` sender:

> ```cpp
> template <class Sndr, class Fun>
> template <class Self, class... Env>
> constexpr auto then_sender<Sndr, Fun>::get_completion_signatures() {
>   auto cs = get_child_completion_signatures<Self, Sndr, Env...>();
>   auto value_fn = []<class... As>() { /* … as shown in section "@[invalid_completion_signature](#invalid_completion_signature)@" */ };
>   constexpr bool nothrow = /* … false if Fun can throw for any set of the predecessor's values */;
>
>   // Use eptr_completion_if here as the "extra" set of completions that
>   // will be added to the ones returned from the transforms.
>   return transform_completion_signatures(cs, value_fn, {}, {}, eptr_completion_if<!nothrow>);
> }
> ```

Questions for LEWG
==================

Assuming we want to change how completion signatures are computed as proposed in
this paper, the author would appreciate LEWG's feedback about the suggested
additions.

1. Do we want to use `operator+` to join two `completion_signatures` objects?

2. Do we want to make `completion_signatures<Sigs...>` _`tuple-like`_ (where
    `completion_signatures<Sigs...>()` behaves like `tuple<Sigs*...>()`)?

3. Should we drop the `transform_completion_signatures` alias template?

4. Should we add a `make_completion_signatures` helper function that returns
    an instance of a `completion_signatures` type with its function types
    normalized and made unique?

5. Should we replace the `transform_completion_signatures` alias template with
    a `consteval` function that does the same thing but for values?

6. Do we want the `invalid_completion_signature` helper function to make it
    easy to generate good diagnostics when type-checking a sender fails.

7. Do we want the `get_child_completion_signatures` helper function to make
    is easy for sender adaptors to get a (properly _cv_-qualified) child
    sender's completion signatures?

8. Do we want to make the completion tag types (`set_value_t`, etc.)
    `constexpr` equality-comparable with each other?

9. Do we want the `eptr_completion_if` variable template, which is an object of
    type `completion_signatures<set_error_t(std::exception_ptr)>` or
    `completion_signatures<>` depending on a `bool` template parameter?

Implementation Experience
=========================

A significant fraction of `std::execution` has been implemented with this design
change. It can be found on [Compiler Explorer](https://godbolt.org/z/xGMMrrnYa)[^1] and in
[this GitHub gist](https://gist.github.com/ericniebler/0896776ab1c8f5b7f77d7094c0400df5)[^2].
This implementation includes all the design elements that would stress the completion
signature computation including:

* Both dependent and non-dependent senders and sender adaptors, with tests for
  both early and late diagnosis of type errors.

* Transforming completion signatures with the proposed
  `transform_completion_signatures` function template

* The exposition-only _`basic-sender`_ has been implemented with the changes
  `get_completion_signatures` customization syntax and the new
  ```@_`impls-for`_@<Tag>::@_`check-types`_@``` customization, which has been
  used to implement and type-check all the sender types, as specified.

* A sender that is implemented via a lowering to another sender type via a
  lazy `transform_sender` customization (`stopped_as_optional`).

* Using awaitables as senders and _vice versa_.

[^1]: [https://godbolt.org/z/xGMMrrnYa](https://godbolt.org/z/xGMMrrnYa)
[^2]: [https://gist.github.com/ericniebler/0896776ab1c8f5b7f77d7094c0400df5](https://gist.github.com/ericniebler/0896776ab1c8f5b7f77d7094c0400df5)

Proposed Wording
================

[This wording is relative to the current working draft with the addition of
[@P3164R3]]{.ednote}

[Change [exec.general] as follows:]{.ednote}


> [?]{.pnum} [For function type `R(Args...)`, let ```@_`NORMALIZE-SIG`_@(R(Args...))```
>  denote the type ```R(@_`remove-rvalue-reference-t`_@<Args>...)``` where
>  _`remove-rvalue-reference-t`_ is an alias template that removes an rvalue
>  reference from a type.]{.add}
>
> [7]{.pnum} For function types `F1` and `F2` [denoting `R1(Args1...)` and
> `R2(Args2...)`, respectively,]{.rm} ```@_`MATCHING-SIG`_@(F1, F2)``` is
> `true` if and only if <code>same_as<[`R1(Args1&&...),
> R2(Args2&&...)`]{.rm}[```@_NORMALIZE-SIG_@(F1),
> @_NORMALIZE-SIG_@(F2)```]{.add}></code> is `true`.
>
> [8]{.pnum} For a subexpression `err`, let `Err` be `decltype((err))` and let
> ```@_`AS-EXCEPT-PTR`_@(err)``` be [&hellip; as before]{.ednote}


[Change [execution.syn] as follows:]{.ednote}

> <b>Header `<execution>` synopsis [execution.syn]</b>
>
> ```cpp
> namespace std::execution {
>   @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
>
>   template<class Sndr, class... Env>
>     concept sender_in = @ _see below_ @;
>
>   @[`template<class Sndr>`{.cpp}]{.add}@
>     @@[`concept dependent_sender = @ _see below_@;`{.cpp}]{.add}@@
>
>   template<class Sndr, class Rcvr>
>     concept sender_to = @ _see below_@;
>
>   template<class... Ts>
>     struct @_`type-list`_@;                                           // exposition only
>
>   @[`// [exec.getcomplsigs], completion signatures`]{.rm}@
>   @[`struct get_completion_signatures_t;`]{.rm}@
>   @[`inline constexpr get_completion_signatures_t get_completion_signatures {};`]{.rm}@
>
>   @[`This alias is moved below and modified.`]{.ednote}@
>   @[`template<class Sndr, class... Env>`]{.rm}@
>       @[`requires sender_in<Sndr, Env...>`]{.rm}@
>     @@[```using completion_signatures_of_t = @_`call-result-t`_@<get_completion_signatures_t, Sndr, Env...>;```]{.rm}@@
>
>   template<class... Ts>
>     using @_`decayed-tuple`_@ = tuple<decay_t<Ts>...>;                // exposition only
>
>   @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
>
>   // [exec.util], sender and receiver utilities
>   // [exec.util.cmplsig] @[`completion signatures`]{.add}@
>   template<class Fn>
>     concept @_`completion-signature`_@ = @_`see below`_@;                   // exposition only
>
>   template<@_`completion-signature`_@... Fns>
>     struct completion_signatures @[`{}`]{.rm}@;
>
>   template<class Sigs>
>     concept @_`valid-completion-signatures`_@ = @_`see below`_@;            // exposition only
>
>   @@[```struct @_`dependent-sender-error`_@ {};```]{.add}@@                             @[_`// exposition only`{.cpp}_]{.add}@
>
>   @[`// [exec.getcomplsigs]`]{.add}@
>   @[`template<class Sndr, class... Env>`]{.add}@
>     @@[```consteval auto get_completion_signatures() -> @_`valid-completion-signatures`_@ auto;```]{.add}@@
>
>   @[`template<class Sndr, class... Env>`]{.add}@
>       @[`requires sender_in<Sndr, Env...>`]{.add}@
>     @[`using completion_signatures_of_t = decltype(get_completion_signatures<Sndr, Env...>());`]{.add}@
>
>   @@[`// [exec.util.cmplsig.trans]`]{.rm}@@
>   @@[`template<`]{.rm}@@
>     @@[```@_`valid-completion-signatures`_@ InputSignatures,```]{.rm}@@
>     @@[```@_`valid-completion-signatures`_@ AdditionalSignatures = completion_signatures<>,```]{.rm}@@
>     @@[```template<class...> class SetValue = @_`see below`_@,```]{.rm}@@
>     @@[```template<class> class SetError = @_`see below`_@,```]{.rm}@@
>     @@[```@_`valid-completion-signatures`_@ SetStopped = completion_signatures<set_stopped_t()>>```]{.rm}@@
>   @@[```using transform_completion_signatures = completion_signatures<@_`see below`_@>;```]{.rm}@@
>
>   @@[`template<`]{.rm}@@
>     @@[`sender Sndr,`]{.rm}@@
>     @@[`class Env = env<>,`]{.rm}@@
>     @@[```@_`valid-completion-signatures`_@ AdditionalSignatures = completion_signatures<>,```]{.rm}@@
>     @@[```template<class...> class SetValue = @_`see below`_@,```]{.rm}@@
>     @@[```template<class> class SetError = @_`see below`_@,```]{.rm}@@
>     @@[```@_`valid-completion-signatures`_@ SetStopped = completion_signatures<set_stopped_t()>>```]{.rm}@@
>       @@[`requires sender_in<Sndr, Env>`]{.rm}@@
>   @@[`using transform_completion_signatures_of =`]{.rm}@@
>     @@[`transform_completion_signatures<`]{.rm}@@
>       @@[`completion_signatures_of_t<Sndr, Env>,`]{.rm}@@
>       @@[`AdditionalSignatures, SetValue, SetError, SetStopped>;`]{.rm}@@
>
>   // [exec.run.loop], run_loop
>   class run_loop;
>
>   @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
>
> }
> ```

[Add the following paragraph after [execution.syn] para 3 (this is moved from [exec.snd.concepts])]{.ednote}

::: add

> [?]{.pnum} [A type models the exposition-only concept _`valid-completion-signatures`_ if
> it denotes a specialization of the `completion_signatures` class template.]{.add}

:::


[Modify [exec.snd.general] as follows:]{.ednote}

> [1]{.pnum} Subclauses [exec.factories] and [exec.adapt] define customizable algorithms
> that return senders. Each algorithm has a default implementation. Let
> `sndr` be the result of an invocation of such an algorithm or an object
> equal to the result ([concepts.equality]), and let `Sndr` be
> `decltype((sndr))`. Let `rcvr` be a receiver of type `Rcvr` with
> associated environment `env` of type `Env` such that `sender_to<Sndr,
> Rcvr>` is `true`. For the default implementation of the algorithm that
> produced `sndr`, connecting `sndr` to `rcvr` and starting the resulting
> operation state ([exec.async.ops]) necessarily results in the potential
> evaluation ([basic.def.odr]) of a set of completion operations whose first
> argument is a subexpression equal to `rcvr`. Let `Sigs` be a pack of
> completion signatures corresponding to this set of completion operations,
> and let `CS` be the type of the expression
> [`get_completion_signatures(sndr, env)`]{.rm}
> [`get_completion_signatures<Sndr, Env>()`]{.add}. Then `CS` is a
> specialization of the class template `completion_signatures`
> ([exec.util.cmplsig]), the set of whose template arguments is `Sigs`. If
> none of the types in `Sigs` are dependent on the type `Env`, then the
> expression [`get_completion_signatures(sndr)`]{.rm}
> [`get_completion_signatures<Sndr>()`]{.add} is well-formed and its type is
> `CS`. If a user-provided implementation of the algorithm that produced
> `sndr` is selected instead of the default:
>
> - [1.1]{.pnum} Any completion signature that is in the set of types
>   denoted by `completion_signatures_of_t<Sndr, Env>` and that is not part of
>   `Sigs` shall correspond to error or stopped completion operations, unless
>   otherwise specified.
>
> - [1.2]{.pnum} If none of the types in `Sigs` are dependent on the type
>   `Env`, then `completion_signatures_of_t<Sndr>` and
>   `completion_signatures_of_t<Sndr, Env>` shall denote the same type.


[In [exec.snd.expos], change para 2 as follows:]{.ednote}

> [2]{.pnum} For a queryable object `env`, ```@_`FWD-ENV`_@(env)``` is an
> expression whose type satisfies `queryable` such that for a query object `q`
> and a pack of subexpressions `as`, the expression
> ```@_`FWD-ENV`_@(env).query(q, as...)``` is ill-formed if
> `forwarding_query(q)` is `false`; otherwise, it is expression-equivalent to
> `env.query(q, as...)`. [The type ```@_`FWD-ENV-T`_@(Env)``` is
> ```decltype(@_`FWD-ENV`_@(declval<Env>()))```.]{.add}


[In [exec.snd.expos], insert the following paragraph after para 22 and before
para 23 (moving the exposition-only alias template out of para 24 and into its
own para so it can be used from elsewhere):]{.ednote}

::: add

> [23]{.pnum} Let _`valid-specialization`_ be the following alias template:
>
> > ```c++
> > template<template<class...> class T, class... Args>
> >   concept @_`valid-specialization`_@ = requires { typename T<Args...>; }; // exposition only
> > ```

:::


[In [exec.snd.expos] para 23 add the mandate below, and in para 24, change the
definition of the exposition-only _`basic-sender`_ as follows:]{.ednote}

> ```c++
> template<class Tag, class Data = see below, class... Child>
>   constexpr auto @_`make-sender`_@(Tag tag, Data&& data, Child&&... child);
> ```
>
> [23]{.pnum} _Mandates_: The following expressions are `true`:
>
> - [23.1]{.pnum} `semiregular<Tag>`
>
> - [23.2]{.pnum} ```@_`movable-value`_@<Data>```
>
> - [23.3]{.pnum} `(sender<Child> &&...)`

::: add

> - [23.4]{.pnum} [`dependent_sender<Sndr> || sender_in<Sndr>`, where `Sndr`
>   is ```@_`basic-sender`_@<Tag, Data, Child...>``` as defined below.]{.add}
>
>   _Recommended practice:_ When this mandate fails because
>   `get_completion_signatures<Sndr>()` would exit with an exception,
>   implementations are encouraged to include information about the
>   exception in the resulting diagnostic.

:::

> [24]{.pnum} _Returns_: A prvalue of type
> ```@_`basic-sender`_@<Tag, decay_t<Data>, decay_t<Child>...>``` that has
> been direct-list-initialized with the forwarded arguments, where
> _`basic-sender`_ is the following exposition-only class template except as
> noted below.
>
> > ```{.cpp}
> > namespace std::execution {
> >   template<class Tag>
> >   concept @_`completion-tag`_@ = // exposition only
> >     same_as<Tag, set_value_t> || same_as<Tag, set_error_t> || same_as<Tag, set_stopped_t>;
> >
> >   @[`template<template<class...> class T, class... Args>`]{.rm}@
> >   @@[```concept @_`valid-specialization`_@ = requires { typename T<Args...>; }; // exposition only```]{.rm}@@
> >
> >   struct @_`default-impls`_@ {  // exposition only
> >     static constexpr auto @_`get-attrs`_@ = @_`see below`_@;
> >     static constexpr auto @_`get-env`_@ = @_`see below`_@;
> >     static constexpr auto @_`get-state`_@ = @_`see below`_@;
> >     static constexpr auto @_`start`_@ = @_`see below`_@;
> >     static constexpr auto @_`complete`_@ = @_`see below`_@;
> >
> >     @[`template<class Sndr, class... Env>`]{.add}@
> >     @@[```static constexpr void @_`check-types`_@();```]{.add}@@
> >   };
> >
> >   @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
> >
> >   @[`template <class Sndr>`]{.add}@
> >   @@[```using @_`data-type`_@ = decltype(declval<Sndr>().template @_`get`_@<1>());     // exposition only```]{.add}@@
> >
> >   template <class Sndr, size_t I = 0>
> >   using @_`child-type`_@ = decltype(declval<Sndr>().template @_`get`_@<I+2>());     // exposition only
> >
> >   @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
> >
> >   @[`template<class Sndr, class... Env>`]{.rm}@
> >   @@[```using @_`completion-signatures-for`_@ = @_`see below`_@; // exposition only```]{.rm}@@
> >
> >   template<class Tag, class Data, class... Child>
> >   struct @_`basic-sender`_@ : @_`product-type`_@<Tag, Data, Child...> {  // exposition only
> >     using sender_concept = sender_t;
> >     using @_`indices-for`_@ = index_sequence_for<Child...>; // exposition only
> >
> >     decltype(auto) get_env() const noexcept {
> >       auto& [_, data, ...child] = *this;
> >       return @_`impls-for`_@<Tag>::@_`get-attrs`_@(data, child...);
> >     }
> >
> >     template<@_`decays-to`_@<@_`basic-sender`_@> Self, receiver Rcvr>
> >     auto connect(this Self&& self, Rcvr rcvr) noexcept(@_`see below`_@)
> >       -> @_`basic-operation`_@<Self, Rcvr> {
> >       return {std::forward<Self>(self), std::move(rcvr)};
> >     }
> >
> >     template<@_`decays-to`_@<@_`basic-sender`_@> Self, class... Env>
> >     @[`static constexpr`]{.add}@ auto get_completion_signatures(@[`this Self&& self, Env&&... env`]{.rm}@) @[noexcept]{.rm}[`;`]{.add}@
> >       @@[```-> @_`completion-signatures-for`_@<Self, Env...> {```]{.rm}@@
> >       @[`return {};`]{.rm}@
> >     @[`}`]{.rm}@
> >   };
> > }
> > ```


[In [exec.snd.expos], replace para 39 with the paragraphs shown below and
renumber subsequent paragraphs:]{.ednote}

> ::: rm
>
> [39]{.pnum} Let `Sndr` be a (possibly `const`-qualified) specialization _`basic-sender`_
> or an lvalue reference of such, let `Rcvr` be the type of a receiver with an
> associated environment of type `Env`. If the type
> ```@_`basic-operation`_@<Sndr, Rcvr>``` is well-formed, let `op` be an
> lvalue subexpression of that type. Then
> ```@_`completion-signatures-for`_@<Sndr, Env>``` denotes a specialization of
> `completion_signatures`, the set of whose template arguments corresponds to
> the set of completion operations that are potentially evaluated
> ([basic.def.odr]) as a result of evaluating `op.start()`. Otherwise,
> ```@_`completion-signatures-for`_@<Sndr, Env>``` is ill-formed. If
> ```@_`completion-signatures-for`_@<Sndr, Env>``` is well-formed and its type
> is not dependent upon the type `Env`,
> ```@_`completion-signatures-for`_@<Sndr>```  is well-formed and denotes the
> same type; otherwise, ```@_`completion-signatures-for`_@<Sndr>```  is
> ill-formed.
>
> :::
>
> ::: add
>
> ```c++
> template <class Sndr, class... Env>
>   static constexpr void @_`default-impls`_@::@_`check-types`_@();
> ```
>
> [?]{.pnum} Let `Is` be the pack of integral template arguments of the
> `integer_sequence` specialization denoted by ```@_`indices-for`_@<Sndr>```.
>
> [?]{.pnum} _Effects_: Equivalent to:
>
> > ```c++
> > (get_completion_signatures<@_`child-type`_@<Sndr, Is>, @_`FWD-ENV-T`_@(Env)...>(), ...)
> > ```
>
> [?]{.pnum} _Remarks_: For any types `T`, `S`, and pack `E`, let `e` be the
> expression ```@_`impls-for`_@<T>::@_`check-types`_@<S, E...>()```. Then
> exactly one of the following is `true`:
>
> - [?.1]{.pnum} `e` is ill-formed, or
>
> - [?.3]{.pnum} The evaluation of `e` exits with an exception, or
>
> - [?.2]{.pnum} `e` is a core constant expression.
>
> When `e` is a core constant expression, the types `S`, `E...` uniquely
> determine a set of completion signatures.
>
> ```c++
> template<class Tag, class Data, class... Child>
>   template <class Sndr, class... Env>
>     constexpr auto @_`basic-sender`_@<Tag, Data, Child...>::get_completion_signatures();
> ```
>
> [?]{.pnum} Let `Rcvr` be the type of a receiver whose environment has type
> `E`, where `E` is the first type in the list ```Env..., @_unspecified_@```.
> Let _`check-types`_ be the expression
> ```@_`impls-for`_@<Tag>::template @_`check-types`_@<Sndr, Env...>()```, and
> let `CS` be a type determined as follows:
>
> - [?.1]{.pnum} If _`check-types`_ is a core constant expression, let `op` be
>   an lvalue subexpression whose type is `connect_result_t<Sndr, Rcvr>`. Then
>   `CS` is the specialization of `completion_signatures` the set of whose
>   template arguments correspond to the set of completion operations that are
>   potentially evaluated ([basic.def.odr]) as a result of evaluating
>   `op.start()`.
>
> - [?.2]{.pnum} Otherwise, `CS` is `completion_signatures<>`.
>
> [?]{.pnum} _Constraints_: _`check-types`_ is a well-formed expression.
>
> [?]{.pnum} _Effects_: Equivalent to
>
> > ```c++
> > @_`check-types`_@;
> > return CS();
> > ```
>
> :::

[Change the specification of _`write-env`_ in [exec.snd.expos] para 40-43 as
follows:]{.ednote}

> ```c++
> template<sender Sndr, queryable Env>
>   constexpr auto @_`write-env`_@(Sndr&& sndr, Env&& env);         // exposition only
> ```
>
> [40]{.pnum} _`write-env`_ is an exposition-only sender adaptor that, when connected with
> a receiver `rcvr`, connects the adapted sender with a receiver whose
> execution environment is the result of joining the queryable argument `env`
> to the result of `get_env(rcvr)`.
>
> [41]{.pnum} Let _`write-env-t`_ be an exposition-only empty class type.
>
> [42]{.pnum} _Returns_:
>
> > ```c++
> > @_`make-sender`_@(@_`write-env-t`_@(), std::forward<Env>(env), std::forward<Sndr>(sndr))
> > ```
>
> [43]{.pnum} _Remarks_: The exposition-only class template _`impls-for`_
> ([exec.snd.general]) is specialized for _`write-env-t`_ as follows:
>
> > ```c++
> > template<>
> > struct @_`impls-for`_@<@_`write-env-t`_@> : @_`default-impls`_@ {
> >   @@[```static constexpr auto @_`join-env`_@(const auto& state, const auto& env) noexcept {```]{.add}@@
> >     @@[```return @_`see below`_@;```]{.add}@@
> >   @[`}`]{.add}@
> >
> >   static constexpr auto @_`get-env`_@ =
> >     [](auto, const auto& state, const auto& rcvr) noexcept {
> >       return @@[```@_`see below`_@```]{.rm}[```@_`join-env`_@(state, get_env(rcvr))```]{.add}@@;
> >     };
> >
> >   @[`template<class Sndr, class... Env>`]{.add}@
> >   @@[```static constexpr void @_`check-types`_@();```]{.add}@@
> > };
> > ```
>
> - [43.1]{.pnum} Invocation of
>   ```@_`impls-for`_@<@_`write-env-t`_@>​::@_[`​get-env`]{.rm}[`join-env`]{.add}_@```
>   returns an object `e` such that `decltype(e)` models `queryable` and
>   given a query object `q`, the expression `e.query(q)` is
>   expression-equivalent to `state.query(q)` if that expression is valid,
>   otherwise, `e.query(q)` is expression-equivalent to
>   ```@[`get_env(rcvr)`]{.rm}[`env`]{.add}@.query(q)```.
>
> ::: add
>
> - [43.2]{.pnum} [For type `Sndr` and pack `Env`, let `State` be
>   ```@_`data-type`_@<Sndr>``` and let `JoinEnv` be the pack
>   ```decltype(@_`join-env`_@(declval<State>(), declval<Env>()))```. Then
>   ```@_`impls-for`_@<@_`write-env-t`_@>​::@_`check-types`_@<Sndr, Env...>()``` is
>   expression-equivalent to
>   ```get_completion_signatures<@_`child-type`_@<Sndr>, JoinEnv...>()```.]{.add}
>
> :::

[Add the following new paragraphs to the end of [exec.snd.expos]]{.ednote}

> ::: add
>
> [?]{.pnum} <div>
>
> ```c++
> template<class... Fns>
> struct @_`overload-set`_@ : Fns... {
>   using Fns::operator()...;
> };
> ```
>
> </div>
>
> [The following is moved from [exec.on] para 6 and modified.]{.ednote}
>
> [?]{.pnum} <div>
>
> ```c++
> struct @_`not-a-sender`_@ {
>   using sender_concept = sender_t;
>
>   template<class Sndr>
>   static constexpr auto get_completion_signatures() -> completion_signatures<> {
>     throw @_unspecified_@;
>   }
> };
> ```
>
> </div>
>
> [?]{.pnum} <div>
>
> ```c++
> constexpr void @_`decay-copyable-result-datums(auto cs)`_@ {
>   cs.@_`for-each`_@([]<class Tag, class... Ts>(Tag(*)(Ts...)) {
>     if constexpr (!(is_constructible_v<decay_t<Ts>, Ts> &&...))
>       throw @_`unspecified`_@;
>   });
> }
> ```
>
> </div>
>
> :::


[Change [exec.snd.concepts] para 1 and add a new para after 1 as follows:]{.ednote}

> [1]{.pnum} The `sender` concept <span style="color:blue;font-style:italic">&hellip; as
> before &hellip;</span> to produce an operation state.
>
> > ```{.cpp}
> > namespace std::execution {
> >   @[`template<class Sigs>`]{.rm}@
> >     @@[```concept @_`valid-completion-signatures`_@ = @_`see below`_@;            // exposition only```]{.rm}@@
> >
> >   @[`template<auto>`]{.add}@
> >     @@[```concept @_`is-constant`_@ = true;```]{.add}@@                                 @[`// exposition only`{.cpp}]{.add}@
> >
> >   template<class Sndr>
> >     concept @_`is-sender`_@ =                                         // exposition only
> >       derived_from<typename Sndr::sender_concept, sender_t>;
> >
> >   template<class Sndr>
> >     concept @_`enable-sender`_@ =                                     // exposition only
> >       @_`is-sender`_@<Sndr> ||
> >       @_`is-awaitable`_@<Sndr, @_`env-promise`_@<env<>>>;                   // [exec.awaitable]
> >
> >   @[`template<class Sndr>`]{.add}@
> >     @@[```consteval bool @_`is-dependent-sender-helper`_@() try {```]{.add}@@           @[`// exposition only`{.cpp}]{.add}@
> >       @[`get_completion_signatures<Sndr>();`]{.add}@
> >       @[`return false;`]{.add}@
> >     @@[```} catch (@_`dependent-sender-error`_@&) {```]{.add}@@
> >       @[`return true;`]{.add}@
> >     @[`}`]{.add}@
> >
> >   template<class Sndr>
> >     concept sender =
> >       bool(@_`enable-sender`_@<remove_cvref_t<Sndr>>) &&
> >       requires (const remove_cvref_t<Sndr>& sndr) {
> >         { get_env(sndr) } -> @_`queryable`_@;
> >       } &&
> >       move_constructible<remove_cvref_t<Sndr>> &&
> >       constructible_from<remove_cvref_t<Sndr>, Sndr>;
> >
> >   template<class Sndr, class... Env>
> >     concept sender_in =
> >       sender<Sndr> &&
> >       (queryable<Env> &&...) &&
> >       @@[```@_`is-constant`_@<get_completion_signatures<Sndr, Env...>()>```]{.add}@@
> >       @[`requires (Sndr&& sndr, Env&&... env) {`]{.rm}@
> >         @[`{ get_completion_signatures(std::forward<Sndr>(sndr), std::forward<Env>(env)...) }`]{.rm}@
> >           @@[```-> @_`valid-completion-signatures`_@;```]{.rm}@@
> >       @[}]{.rm}@;
> >
> >   @[`template<class Sndr>`]{.add}@
> >     @[`concept dependent_sender =`]{.add}@
> >       @@[```sender<Sndr> && bool_constant<@_`is-dependent-sender-helper`_@<Sndr>()>::value;```]{.add}@@
> >
> >   template<class Sndr, class Rcvr>
> >     concept sender_to =
> >       sender_in<Sndr, env_of_t<Rcvr>> &&
> >       receiver_of<Rcvr, completion_signatures_of_t<Sndr, env_of_t<Rcvr>>> &&
> >       requires (Sndr&& sndr, Rcvr&& rcvr) {
> >         connect(std::forward<Sndr>(sndr), std::forward<Rcvr>(rcvr));
> >       };
> > }
> > ```
>
> ::: add
>
> - [?]{.pnum} [For a type `Sndr`, if `sender<Sndr>` is `true` and `dependent_sender<Sndr>`
>   is `false`, then `Sndr` is a non-dependent sender ([exec.async.ops]).]{.add}
>
> :::

[Strike [exec.snd.concepts] para 3 (this para is moved to [execution.syn]):]{.ednote}

::: rm

> [3]{.pnum} [A type models the exposition-only concept _`valid-completion-signatures`_ if
> it denotes a specialization of the `completion_signatures` class template.]{.rm}

:::


[Change [exec.getcomplsigs] as follows:]{.ednote}

> ::: rm
>
> [1]{.pnum} `get_completion_signatures` is a customization point object. Let
> `sndr` be an expression such that `decltype((sndr))` is `Sndr`, and let `env`
> be a pack of zero or one expression. If `sizeof...(env) == 0` is `true`, let
> `new_sndr` be `sndr`; otherwise, let `new_sndr` be the expression
> ```transform_sender(decltype(@_`get-domain-late`_@(sndr, env...)){}, sndr, env...)```.
>  Let `NewSndr` be `decltype((new_sndr))`. Then
> `get_completion_signatures(sndr, env...)` is expression-equivalent to
> `(void(sndr), void(env)..., CS())` except that `void(sndr)` and `void(env)...`
> are indeterminately sequenced, where `CS` is:
>
> - [1.1]{.pnum} `decltype(new_sndr.get_completion_signatures(env...))` if that
>   type is well-formed,
>
> - [1.2]{.pnum} Otherwise, if `sizeof...(env) == 1` is `true`, then
>   `decltype(new_sndr.get_completion_signatures())` if that expression is
>   well-formed,
>
> - [1.3]{.pnum} Otherwise, `remove_cvref_t<NewSndr>::completion_signatures`
>   if that type is well-formed,
>
> - [1.4]{.pnum} Otherwise, if
>   ```@_`is-awaitable`_@<NewSndr, @_`env-promise`_@<decltype((env))>...>```
>   is `true`, then:
>
>   ```c++
>   completion_signatures<
>     @_`SET-VALUE-SIG`_@(await-result-type<NewSndr, env-promise<Env>>),        //  ([exec.snd.concepts])
>     set_error_t(exception_ptr),
>     set_stopped_t()>
>   ```
>
> - [1.4]{.pnum} Otherwise, `CS` is ill-formed.
>
> :::


> ::: add
>
> ```c++
> template <class Sndr, class... Env>
>   consteval auto get_completion_signatures() -> @@```@_`valid-completion-signatures`_@ auto```@@;
> ```
>
> [?]{.pnum} Let ```@_`CHECKED-COMPLSIGS`_@(@_`e`_@)``` be _`e`_ if _`e`_ is a
> core constant expression whose type satisfies _`valid-completion-signatures`_;
> otherwise, it is the following expression:
>
> > ```c++
> > (@_`e`_@, throw @_`unspecified`_@, completion_signatures())
> > ```
>
> Let ```@_`get-complsigs`_@<Sndr, Env...>()``` be expression-equivalent to
> `remove_reference_t<Sndr>::template get_completion_signatures<Sndr, Env...>()`,
> let ```@_`nested-complsigs-t`_@<Sndr>``` be an alias for the type
> `typename remove_reference_t<Sndr>::completion_signatures`,
> and let `NewSndr` be `Sndr` if `sizeof...(Env) == 0` is `true`; otherwise,
> ```decltype(@_`s`_@)``` where _`s`_ is the following expression:
>
> > ```c++
> > transform_sender(
> >   @_`get-domain-late`_@(declval<Sndr>(), declval<Env>()...),
> >   declval<Sndr>(),
> >   declval<Env>()...)
> > ```
>
> [?]{.pnum} _Constraints_: `sizeof...(Env) <= 1` is `true`.
>
> [?]{.pnum} _Effects_: Equivalent to: `return @_e_@;` where _`e`_ is
> expression-equivalent to the following:
>
> - [?.1]{.pnum} ```@_`CHECKED-COMPLSIGS`_@(@_`get-complsigs`_@<NewSndr, Env...>())```
>   if ```@_`get-complsigs`_@<NewSndr, Env...>()``` is a well-formed expression.
>
> - [?.2]{.pnum} Otherwise,
>   ```@_`CHECKED-COMPLSIGS`_@(@_`get-complsigs`_@<NewSndr>())``` if
>   ```@_`get-complsigs`_@<NewSndr>()``` is a well-formed expression.
>
> - [?.3]{.pnum} Otherwise,
>   ```@_`CHECKED-COMPLSIGS`_@(@_`nested-complsigs-t`_@<NewSndr>())```
>   if ```@_`nested-complsigs-t`_@<NewSndr>()``` is a well-formed expression.
>
> - [?.4]{.pnum} Otherwise,
>
>   > ```c++
>   > completion_signatures<
>   >   @_`SET-VALUE-SIG`_@(@_`await-result-type`_@<NewSndr, @_`env-promise`_@<Env>...>),  //  ([exec.snd.concepts])
>   >   set_error_t(exception_ptr),
>   >   set_stopped_t()>
>   > ```
>
>   if ```@_`is-awaitable`_@<NewSndr, @_`env-promise`_@<Env>...>``` is `true`.
>
> - [?.5]{.pnum} Otherwise, ```throw @_`dependent-sender-error`_@()``` if
>   `sizeof...(Env) == 0` is `true`,
>
> - [?.6]{.pnum} Otherwise, ```throw @_`unspecified`_@```.
>
> :::
>
> ::: rm
>
> [2]{.pnum} [This para is no longer needed because the new `dependent_sender`
> concept covers it.]{.ednote} [If `get_completion_signatures(sndr)` is
> well-formed and its type denotes a specialization of the
> `completion_signatures` class template, then `Sndr` is a non-dependent sender
> type ([exec.async.ops]).]{.rm}
>
> :::
>
>
> [3]{.pnum} Given a type `Env`, if `completion_signatures_of_t<Sndr>` and
> `completion_signatures_of_t<Sndr, Env>` are both well-formed, they shall
> denote the same type.
>
> [4]{.pnum} Let `rcvr` be an rvalue whose type `Rcvr` models `receiver`, and let `Sndr` be the
> type of a sender such that `sender_in<Sndr, env_of_t<Rcvr>>` is `true`. Let
> `Sigs...` be the template arguments of the `completion_signatures`
> specialization named by `completion_signatures_of_t<Sndr, env_of_t<Rcvr>>`.
> Let `CSO` be a completion function. If sender `Sndr` or its operation state
> cause the expression `CSO(rcvr, args...)` to be potentially evaluated
> ([basic.def.odr]) then there shall be a signature `Sig` in `Sigs...` such that
>
> > ```c++
> > @_`MATCHING-SIG`_@(@_`decayed-typeof`_@<CSO>(decltype(args)...), Sig)
> > ```
>
> is `true` ([exec.general]).

[At the very bottom of [exec.connect], change the _Mandates_ of para 6 as follows:]{.ednote}

> [6]{.pnum} The expression `connect(sndr, rcvr)` is expression-equivalent to:
>
>   - [6.1]{.pnum} `new_sndr.connect(rcvr)` if that expression is well-formed.
>
>       _Mandates_: The type of the expression above satisfies `operation_state`.
>
>   - [6.2]{.pnum} Otherwise, ```@_`connect-awaitable`_@(new_sndr, rcvr)```.
>
>   _Mandates_: [`sender<Sndr> && receiver<Rcvr>`]{.rm} [The following are `true`:]{.add}
>
> ::: add
>
>   - [6.3]{.pnum} [`sender_in<Sndr, env_of_t<Rcvr>>`]{.add}
>
>   - [6.4]{.pnum} [`receiver_of<Rcvr, completion_signatures_of_t<Sndr, env_of_t<Rcvr>>>`]{.add}
>
> :::


[In [exec.read.env] para 3, make the following change:]{.ednote}

> [3]{.pnum} The exposition-only class template _`impls-for`_
> ([exec.snd.general]) is specialized for `read_env` as follows:
>
> > ```c++
> > namespace std::execution {
> >   template<>
> >   struct @_`impls-for`_@<@_`decayed-typeof`_@<read_env>> : @_`default-impls`_@ {
> >     static constexpr auto @_`start`_@ =
> >       [](auto query, auto& rcvr) noexcept -> void {
> >         @_`TRY-SET-VALUE`_@(std::move(rcvr), query(get_env(rcvr)));
> >       };
>>
> >     @[`template<class Sndr, class Env>`]{.add}@
> >     @@[```static constexpr void @_`check-types`_@();```]{.add}@@
> >   };
> > }
> > ```

::: add

> ```c++
> template<class Sndr, class Env>
> static constexpr void @_`check-types`_@();
> ```
>
> - [3.1]{.pnum} Let `Q` be ```decay_t<@_`data-type`_@<Sndr>>```.
>
> - [3.2]{.pnum} _Throws_: An exception of an unspecified type if the
>   expression `Q()(env)` is ill-formed or has type `void`, where `env`
>   is an lvalue subexpression whose type is `Env`.

:::


[Change [exec.schedule.from] para 4 and insert a new para between 6 and 7 as
follows:]{.ednote}

> [4]{.pnum} The exposition-only class template _`impls-for`_ ([exec.snd.general]) is
> specialized for `schedule_from_t` as follows:
>
> > ```c++
> > namespace std::execution {
> >   template<>
> >   struct @_`impls-for`_@<schedule_from_t> : @_`default-impls`_@ {
> >     static constexpr auto @_`get-attrs`_@ = @_`see below;`_@
> >     static constexpr auto @_`get-state`_@ = @_`see below;`_@
> >     static constexpr auto @_`complete`_@ = @_`see below;`_@
> >
> >     @[`template<class Sndr, class... Env>`]{.add}@
> >     @@[```static constexpr void @_`check-types`_@();```]{.add}@@
> >   };
> > }
> > ```
>
> [5]{.pnum} The member <span style="color:blue;font-style=italic">&hellip; as before &hellip;</span>
>
> [6]{.pnum} The member ```@_`impls-for`_@<schedule_from_t>::@_`get-state`_@```
> is initialized with a callable object equivalent to the following lambda:
>
> > ```c++
> > []<class Sndr, class Rcvr>(Sndr&& sndr, Rcvr& rcvr) noexcept(see below)
> >     requires sender_in<child-type<Sndr>, @@[```@_`FWD-ENV-T`_@(```]{.add}@@env_of_t<Rcvr>@[`)`]{.add}@> {
> >
> >   auto& [_, sch, child] = sndr;
> >   @<span style="color:blue;font-style=italic">&hellip; as before &hellip;</span>@
> > ```
>
> ::: add
>
> ```c++
> template<class Sndr, class... Env>
> static constexpr void @_`check-types`_@();
> ```
>
> [?]{.pnum} _Effects_: Equivalent to:
>
> > ```c++
> > get_completion_signatures<schedule_result_t<@_`data-type`_@<Sndr>>, @_`FWD-ENV-T`_@(Env)...>();
> > auto cs = get_completion_signatures<@_`child-type`_@<Sndr>, @_`FWD-ENV-T`_@(Env)...>();
> > @_`decay-copyable-result-datums`_@(cs); // see [exec.snd.expos]
> > ```
>
> :::
>
> [7]{.pnum} Objects of the local class _`state-type`_
> <span style="color:blue;font-style=italic">&hellip; as before &hellip;</span>
>
> [8]{.pnum} Let `Sigs` be a pack of the arguments to the `completion_signatures`
> specialization named by
> ```completion_signatures_of_t<@_`child-type`_@<Sndr>, @[_`FWD-ENV-T`_(]{.add}@env_of_t<Rcvr>@[`)`]{.add}@>```.
> Let _`as-tuple`_ be an alias template such that
> ```@_`as-tuple`_@<Tag(Args...)>``` denotes the type
> ```@_`decayed-tuple`_@<Tag, Args...>```. Then `variant_t` denotes the type
> ```variant<monostate, @_`as-tuple`_@<Sigs>...>```, except with duplicate
> types removed.

[Change [exec.on] para 6 as follows (_`not-a-sender`_ is moved to
[exec.snd.expos]):]{.ednote}

> [6]{.pnum} Otherwise: Let _`not-a-scheduler`_ be an unspecified empty class type[.]{.add}[, and
> let _`not-a-sender`_ be the exposition-only type:]{.rm}
>
> ::: rm
>
> > ```c++
> > struct @_`not-a-sender`_@ {
> >   using sender_concept = sender_t;
> >
> >   auto get_completion_signatures(auto&&) const {
> >     return @_see below_@;
> >   }
> > };
> > ```
>
> :::
>
> [where the member function `get_completion_signatures` returns an object
> of a type that is not a specialization of the `completion_signatures`
> class template.]{.rm}

[Delete [exec.on] para 9 as follows:]{.ednote}

::: rm

> [9]{.pnum} [_Recommended practice_: Implementations should use the return type of
> ```@_`not-a-sender`_@::get_completion_signatures``` to inform users that
> their usage of on is incorrect because there is no available scheduler onto
> which to restore execution.]{.rm}

:::

[Revert the change to [exec.then] made by P3164R3, and then change [exec.then]
para 4 as follows:]{.ednote}

> [4]{.pnum} The exposition-only class template *`impls-for`* ([exec.snd.general]) is
> specialized for *`then-cpo`* as follows:
>
> > ```c++
> > namespace std::execution {
> >   template<>
> >   struct @_`impls-for`_@<@_`decayed-typeof`_@<@_`then-cpo`_@>> : @_`default-impls`_@ {
> >     static constexpr auto complete =
> >       []<class Tag, class... Args>
> >         (auto, auto& fn, auto& rcvr, Tag, Args&&... args) noexcept -> void {
> >           if constexpr (same_as<Tag, @_`decayed-typeof`_@<@_`set-cpo`_@>>) {
> >             @_`TRY-SET-VALUE`_@(rcvr,
> >                           invoke(std::move(fn), std::forward<Args>(args)...));
> >           } else {
> >             Tag()(std::move(rcvr), std::forward<Args>(args)...);
> >           }
> >         };
> >
> >     @[`template<class Sndr, class... Env>`]{.add}@
> >     @@[```static constexpr void @_`check-types`_@();```]{.add}@@
> >   };
> > }
> > ```

::: add

> [?]{.pnum} <div>
>
> ```c++
> template<class Sndr, class... Env>
> static constexpr void @_`check-types`_@();
> ```
>
> </div>
>
> - [?.1]{.pnum} _Effects:_ Equivalent to:
>
>   ```c++
>   auto cs = get_completion_signatures<@_`child-type`_@<Sndr>, @_`FWD-ENV-T`_@(Env)...>();
>   auto fn = []<class... Ts>(set_value_t(*)(Ts...)) {
>     if constexpr (!invocable<remove_cvref_t<@_`data-type`_@<Sndr>>, Ts...>)
>       throw @_`unspecified`_@;
>   };
>   cs.@_`for-each`_@(@_`overload-set`_@{fn, [](auto){}});
>   ```

:::

[Revert the change to [exec.let] made by P3164R3, and then change [exec.let]
para 5 and insert a new para after 5 as follows:]{.ednote}

> [5]{.pnum} The exposition-only class template _`impls-for`_ ([exec.snd.general]) is
> specialized for _`let-cpo`_ as follows:
>
> > ```c++
> > namespace std::execution {
> >   template<class State, class Rcvr, class... Args>
> >   void @_`let-bind`_@(State& state, Rcvr& rcvr, Args&&... args);      // exposition only
> >
> >   template<>
> >   struct @_`impls-for`_@<@_`decayed-typeof`_@<@_`let-cpo`_@>> : @_`default-impls`_@ {
> >     static constexpr auto @_`get-state`_@ = @_`see below`_@;
> >     static constexpr auto @_`complete`_@ = @_`see below`_@;
> >
> >     @[`template<class Sndr, class... Env>`]{.add}@
> >     @@[```static constexpr void @_`check-types`_@();```]{.add}@@
> >   };
> > }
> > ```
>
> 6. Let _`receiver2`_ denote the following exposition-only class template:
>
>     > ```c++
>     > namespace std::execution {
>     >   @<span style="color:blue;font-style=italic">&hellip; as before &hellip;</span>@
>     > }
>     > ```
>
>     Invocation of the function ```@_`receiver2`_@::get_env``` returns an object `e` such that
>
>     1. `decltype(e)` models _`queryable`_ and
>
>     2. given a query object `q`, the expression `e.query(q)` is expression-equivalent
>        to ```@_`env`_@.query(q)``` if that expression is valid[,]{.rm}[;]{.add} otherwise[,
>        if the type of `q` satisfies _`forwarding-query`_,]{.add} `e.query(q)`
>        is expression-equivalent to ```get_env(@_`rcvr`_@).query(q)```[; otherwise, `e.query(q)`
>        is ill-formed]{.add}.

::: add

> [?]{.pnum} <div>
>
> ```c++
> template<class Sndr, class... Env>
> static constexpr void @_`check-types`_@();
> ```
>
> </div>
>
> - [?.1]{.pnum} _Effects:_ Equivalent to:
>
>   ```c++
>   using LetFn = remove_cvref_t<@_`data-type`_@<Sndr>>;
>   auto cs = get_completion_signatures<@_`child-type`_@<Sndr>, @_`FWD-ENV-T`_@(Env)...>();
>   auto fn = []<class... Ts>(@_`decayed-typeof`_@<@_`set-cpo`_@>(*)(Ts...)) {
>     if constexpr (!@_`is-valid-let-sender`_@)
>       throw @_`unspecified`_@;
>   };
>   cs.@_`for-each`_@(@_`overload-set`_@(fn, [](auto){}));
>   ```
>
>   where _`is-valid-let-sender`_ is `true` if and only if all of the following
>   are `true`:
>
>   - `(constructible_from<decay_t<Ts>, Ts> &&...)`
>   - `invocable<LetFn, decay_t<Ts>&...>`
>   - `sender<invoke_result_t<LetFn, decay_t<Ts>&...>>`
>   - `sizeof...(Env) == 0 || sender_in<invoke_result_t<LetFn, decay_t<Ts>&...>, Env...>`

:::

[Make a drive-by fix to [exec.let] para 8 as follows:]{.ednote}

> [8]{.pnum} Let `Sigs` be a pack of the arguments to the `completion_signatures`
> specialization named by
> ```completion_signatures_of_t<@_`child-type`_@<Sndr>, @[_`FWD-ENV-T`_(]{.add}@env_of_t<Rcvr>@[`)`]{.add}@>```.
> Let `LetSigs` be a pack of those types in `Sigs` with a return type of
> ```@_`decayed-typeof`_@<@_`set-cpo`_@>```. Let _`as-tuple`_ be an alias template
> such that ```@_`as-tuple`_@<Tag(Args...)>``` denotes the type
> ```@_`decayed-tuple`_@<Args...>```. Then `args_variant_t` denotes the type
> ```variant<monostate, @_`as-tuple`_@<LetSigs>...>``` except with duplicate types
> removed.


[Revert the change to [exec.bulk] made by P3164R3, and then change [exec.bulk]
para 3 and insert a new para after 5 as follows:]{.ednote}

> [3]{.pnum} The exposition-only class template _`impls-for`_ ([exec.snd.general]) is
> specialized for `bulk_t` as follows:
>
> > ```c++
> > namespace std::execution {
> >   template<>
> >   struct @_`impls-for`_@<bulk_t> : @_`default-impls`_@ {
> >     static constexpr auto @_`complete`_@ = @_`see below`_@;
> >
> >     @[`template<class Sndr, class... Env>`]{.add}@
> >     @@[```static constexpr void @_`check-types`_@();```]{.add}@@
> >   };
> > }
> > ```
>
> [4]{.pnum} The member ```@_`impls-for`_@<bulk_t>::@_`complete`_@``` is
>     <span style="color:blue;font-style=italic">&hellip; as before &hellip;</span>
>
> [5]{.pnum} <span style="color:blue;font-style=italic">&hellip; as before &hellip;</span>

::: add

> [?]{.pnum} <div>
>
> ```c++
> template<class Sndr, class... Env>
> static constexpr void @_`check-types`_@();
> ```
>
> </div>
>
> - [?.1]{.pnum} _Effects:_ Equivalent to:
>
>   ```c++
>   auto cs = get_completion_signatures<@_`child-type`_@<Sndr>, @_`FWD-ENV-T`_@(Env)...>();
>   auto fn = []<class... Ts>(set_value_t(*)(Ts...)) {
>     if constexpr (!invocable<remove_cvref_t<@_`data-type`_@<Sndr>>, Ts...>)
>       throw @_`unspecified`_@;
>   };
>   cs.@_`for-each`_@(@_`overload-set`_@{fn, [](auto){}});
>   ```

:::


[Revert the change to [exec.split] made by P3164R3, and then change [exec.split]
para 3 and insert a new para after 3 as follows:]{.ednote}


> [3]{.pnum} The name `split` denotes a pipeable sender adaptor object. [For a subexpression
> `sndr`, let `Sndr` be `decltype((sndr))`. If ```sender_in<Sndr,
> @_`split-env`_@>``` is `false`, `split(sndr)` is ill-formed.]{.rm}

::: add

> [?]{.pnum} The exposition-only class template _`impls-for`_ ([exec.snd.general]) is
> specialized for `split_t` as follows:
>
> > ```c++
> > namespace std::execution {
> >   template<>
> >   struct @_`impls-for`_@<split_t> : @_`default-impls`_@ {
> >     template<class Sndr>
> >     static constexpr void @_`check-types`_@() {
> >       auto cs = get_completion_signatures<@_`child-type`_@<Sndr>, @_`split-env`_@>();
> >       @_`decay-copyable-result-datums`_@(cs); // see [exec.snd.expos]
> >     }
> >   };
> > }
> > ```

:::

[Change [exec.when.all] paras 2-9 and insert two new paras after 4 as
follows:]{.ednote}

> [2]{.pnum} The names `when_all` and `when_all_with_variant` denote customization point
> objects. Let `sndrs` be a pack of subexpressions, let `Sndrs` be a pack of
> the types `decltype((sndrs))...`, and let `CD` be the type
> ```common_type_t<decltype(@_`get-domain-early`_@(sndrs))...>``` [, and let
> `CD2` be `CD` if `CD` is well-formed, and `default_domain`
> otherwise.]{.add}. The expressions `when_all(sndrs...)` and
> `when_all_with_variant(sndrs...)` are ill-formed if any of the following
> is true:
>
> - [2.1]{.pnum} `sizeof...(sndrs)` is `0`, or
>
> - [2.2]{.pnum} `(sender<Sndrs> && ...)` is `false`[, or]{.rm}[.]{.add}
>
> ::: rm
>
> - [2.3]{.pnum} [`CD` is ill-formed.]{.rm}
>
> :::
>
> [3]{.pnum} The expression `when_all(sndrs...)` is expression-equivalent to:
>
> > ```c++
> > transform_sender(@[`CD()`]{.rm}[`CD2()`]{.add}@, @_`make-sender`_@(when_all, {}, sndrs...))
> > ```
>
> [4]{.pnum} The exposition-only class template _`impls-for`_ ([exec.snd.general]) is
> specialized for `when_all_t` as follows:
>
> > ```c++
> > namespace std::execution {
> >   template<>
> >   struct @_`impls-for`_@<when_all_t> : @_`default-impls`_@ {
> >     static constexpr auto @_`get-attrs`_@ = @_`see below`_@;
> >     static constexpr auto @_`get-env`_@ = @_`see below`_@;
> >     static constexpr auto @_`get-state`_@ = @_`see below`_@;
> >     static constexpr auto @_`start`_@ = @_`see below`_@;
> >     static constexpr auto @_`complete`_@ = @_`see below`_@;
> >
> >     @[`template<class Sndr, class... Env>`]{.add}@
> >     @@[```static constexpr void @_`check-types`_@();```]{.add}@@
> >   };
> > }
> > ```
>
> ::: add
>
> [?]{.pnum} [Let `make-when-all-env` be the following exposition-only function template:]{.add}
>
> > ```c++
> > template<class Env>
> > constexpr auto @_`make-when-all-env`_@(inplace_stop_source& stop_src, Env&& env) noexcept {
> >   return @_`see below`_@;
> > }
> > ```
>
> :::
>
> Returns an object `e` such that <span style="color:blue;font-style:italic">The
> following itemized list has been moved here from para 6 and modified.</span>
>
> - [?.1]{.pnum} `decltype(e)` models `queryable`, and
>
> - [?.2]{.pnum} `e.query(get_stop_token)` is expression-equivalent to
>   `stop_src.get_token()`, and
>
> - [?.3]{.pnum} given a query object `q` with type other than _cv_
>   `stop_token_t` [and whose type satisfies _`forwarding-query`_]{.add},
>   `e.query(q)` is expression-equivalent to `env.query(q)`.
>
> [Let _`when-all-env`_ be an alias template such that
> ```@_`when-all-env`_@<Env>``` denotes the type
>  ```decltype(@_`make-when-all-env`_@(declval<inplace_stop_source&>(), declval<Env>()))```.]{.add}

::: add

> [?]{.pnum} <div>
>
> ```c++
> template<class Sndr, class... Env>
> static constexpr void @_`check-types`_@();
> ```
>
> </div>
>
> - [?.1]{.pnum} [Let `Is` be the pack of integral template arguments
>   of the `integer_sequence` specialization denoted by
>   ```@_`indices-for`_@<Sndr>```.]{.add}
>
> - [?.2]{.pnum} [_Effects_: Equivalent to:]{.add}
>
>   ```c++
>   auto fn = []<class Child>() {
>     auto cs = get_completion_signatures<Child, @_`when-all-env`_@<Env>...>();
>     if constexpr (cs.@_`count-of`_@(set_value) >= 2)
>       throw @_`unspecified`_@;
>     @_`decay-copyable-result-datums`_@(cs); // see [exec.snd.expos]
>   };
>   (fn.template operator()<@_`child-type`_@<Sndr, Is>>(), ...);
>   ```
>
> - [?.3]{.pnum} [_Throws_: Any exception thrown as a result of evaluating the
>   _Effects_, or an exception of an unspecified type when `CD` is
>   ill-formed.]{.add}

:::

> [5]{.pnum} The member ```@_`impls-for`_@<when_all_t>::@_`get-attrs`_@``` <span
> style="color:blue;text-style:italic">&hellip; as before &hellip;</span>
>
> [6]{.pnum} The member ```@_`impls-for`_@<when_all_t>::@_`get-env`_@``` is initialized
> with a callable object equivalent to the following lambda expression:
>
> > ```c++
> > []<class State, class Rcvr>(auto&&, State& state, const Receiver& rcvr) noexcept {
> >   return @@[```@_`see below`_@```]{.rm}[```@_`make-when-all-env`_@(state.@_`stop-src`_@, get_env(rcvr))```]{.add}@@;
> > }
> > ```

::: rm

> [Returns an object `e` such that]{.rm}
>
> - [6.1]{.pnum} [`decltype(e)` models `queryable`, and]{.rm}
>
> - [6.2]{.pnum} [`e.query(get_stop_token)` is expression-equivalent to
>   ```state.@_`stop-src`_@.get_token()```, and]{.rm}
>
> - [6.3]{.pnum} [given a query object `q` with type other than _cv_
>   `stop_token_t`, `e.query(q)` is expression-equivalent to
>   ```get_env(rcvr).query(q)```.]{.rm}

:::

> [7]{.pnum} The member ```@_`impls-for`_@<when_all_t>::@_`get-state`_@``` is
> initialized with a callable object equivalent to the following lambda
> expression:
>
> > ```c++
> > []<class Sndr, class Rcvr>(Sndr&& sndr, Rcvr& rcvr) noexcept(@_e_@) -> decltype(@_e_@) {
> >   return @_e_@;
> > }
> > ```
>
> where _`e`_ is the expression
>
> > ```c++
> > std::forward<Sndr>(sndr).apply(@_`make-state`_@<Rcvr>())
> > ```
>
> and where _`make-state`_ is the following exposition-only class template:
>
> > ```c++
> > @[`template<class Sndr, class Env>`]{.rm}@
> > @@[```concept @_`max-1-sender-in`_@ = sender_in<Sndr, Env> &&```]{.rm}@@                @[`// exposition only`]{.rm}@@
> >   @[`(tuple_size_v<value_types_of_t<Sndr, Env, tuple, tuple>> <= 1);`]{.rm}@
> >
> > enum class disposition { started, error, stopped };             // exposition only
> >
> > template<class Rcvr>
> > struct make-state {
> >   template<@@[```@_`max-1-sender-in`_@<env_of_t<Rcvr>>```]{.rm}[class]{.add}@@... Sndrs>
> >   auto operator()(auto, auto, Sndrs&&... sndrs) const {
> >     using values_tuple = see below;
> >     using errors_variant = see below;
> >     using stop_callback = stop_callback_for_t<stop_token_of_t<env_of_t<Rcvr>>, on-stop-request>;
> > @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
> > ```
>
> [8]{.pnum} Let _`copy-fail`_ be <span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>
>
> [9]{.pnum} The alias `values_tuple` denotes the type
>
> > ```c++
> > tuple<value_types_of_t<Sndrs, @@[```@_`FWD-ENV-T`_@(```]{.add}@@env_of_t<Rcvr>@[`)`]{.add}@, decayed-tuple, optional>...>
> > ```
>
> if that type is well-formed; otherwise, `tuple<>`.


[Change [exec.when.all] para 14 as follows:]{.ednote}

> [14]{.pnum} The expression `when_all_with_variant(sndrs...)` is
> expression-equivalent to:
>
> > ```c++
> > transform_sender(@[`CD()`]{.rm}[`CD2()`]{.add}@, @_`make-sender`_@(when_all_with_variant, {}, sndrs...));
> > ```

[Change [exec.into.variant] paras 4-5 as follows (with the change to para 5
being a drive-by fix):]{.ednote}

> [4]{.pnum} The exposition-only class template _`impls-for`_ ([exec.snd.general])
> is specialized for _`into_variant`_ as follows:
>
> > ```c++
> > namespace std::execution {
> >   template<>
> >   struct @_`impls-for`_@<into_variant_t> : @_`default-impls`_@ {
> >     static constexpr auto @_`get-state`_@ = @_`see below`_@;
> >     static constexpr auto @_`complete`_@ = @_`see below`_@;
> >
> >     @[`template<class Sndr, class... Env>`]{.add}@
> >     @@[```static constexpr void @_`check-types`_@() {```]{.add}@@
> >       @@[```auto cs = get_completion_signatures<@_`child-type`_@<Sndr>, @_`FWD-ENV-T`_@(Env)...>();```]{.add}@@
> >       @@[```@_`decay-copyable-result-datums`_@(cs);```]{.add}@@  // see [exec.snd.expos]
> >     @[`}`]{.add}@
> >   };
> > }
> > ```
>
> [5]{.pnum} The member ```@_`impls-for`_@<into_variant_t>::@_`get-state`_@```
> is initialized with a callable object equivalent to the following lambda:
>
> > ```c++
> > []<class Sndr, class Rcvr>(Sndr&& sndr, Rcvr& rcvr) noexcept
> >   -> type_identity<value_types_of_t<@_`child-type`_@<Sndr>, @@[```@_`FWD-ENV-T`_@(```]{.add}@@env_of_t<Rcvr>@[`)`]{.add}@>> {
> >   return {};
> > }
> > ```


[Revert the change to [exec.stopped.opt] made by P3164R3, and make the following
changes instead. Note: this includes the proposed resolution to
[cplusplus/sender-receiver#311](https://github.com/cplusplus/sender-receiver/issues/311)]{.ednote}

> [2]{.pnum} The name `stopped_as_optional` denotes a pipeable sender adaptor
> object. For a subexpression `sndr`, let `Sndr` be `decltype((sndr))`. The expression
> `stopped_as_optional(sndr)` is expression-equivalent to:
>
> > ```c++
> > transform_sender(@_`get-domain-early`_@(sndr), @_`make-sender`_@(stopped_as_optional, {}, sndr))
> > ```
>
> except that `sndr` is only evaluated once.
>
> ::: add
>
> [?]{.pnum} [The exposition-only class template _`impls-for`_ ([exec.snd.general]) is specialized
> for `stopped_as_optional_t` as follows:]{.add}
>
> > ```c++
> > template<>
> > struct @_`impls-for`_@<stopped_as_optional_t> : @_`default-impls`_@ {
> >   template<class Sndr, class... Env>
> >   static constexpr void @_`check-types`_@() {
> >     @_`default-impls`_@::@_`check-types`_@<Sndr, Env...>();
> >     if constexpr (!requires {
> >       requires (!same_as<void, @_`single-sender-value-type`_@<@_`child-type`_@<Sndr>, @_`FWD-ENV-T`_@(Env)...>>); })
> >       throw @_unspecified_@;
> >   }
> > };
> > ```
>
> :::
>
> [3]{.pnum} Let `sndr` and `env` be subexpressions such that `Sndr` is `decltype((sndr))`
> and `Env` is `decltype((env))`. If ```@_`sender-for`_@<Sndr, stopped_as_optional_t>``` is `false`[,
> or if the type ```@_`single-sender-value-type`_@<Sndr, Env>``` is ill-formed or `void`,]{.rm} then
> the expression `stopped_as_optional.transform_sender(sndr, env)` is ill-formed;
> [otherwise, if ```sender_in<@_`child-type`_@<Sndr>, @_`FWD-ENV-T`_@(Env)>``` is `false`,
> the expression `stopped_as_optional.transform_sender(sndr, env)` is equivalent to
> ```@_`not-a-sender`_@()```; ]{.add} otherwise, it is equivalent to:
>
> ```c++
> auto&& [_, _, child] = sndr;
> using V = @_`single-sender-value-type`_@<@@[```@_`child-type`_@<```]{.add}@@Sndr@[`>`]{.add}@, @@[```@_`FWD-ENV-T`_@(```]{.add}@@Env@[`)`]{.add}@>;
> return let_stopped(
>     then(std::forward_like<Sndr>(child),
>          []<class... Ts>(Ts&&... ts) noexcept(is_nothrow_constructible_v<V, Ts...>) {
>            return optional<V>(in_place, std::forward<Ts>(ts)...);
>          }),
>     []() noexcept { return just(optional<V>()); });
> ```


[Change [exec.util.cmplsig] para 8 and add a new para after 8 as follows:]{.ednote}


> [8]{.pnum} <div>
>
> ```c++
> namespace std::execution {
>   template<@_`completion-signature`_@... Fns>
>     struct completion_signatures {
>       @@[```template<class Tag>```]{.add}@@
>       @@[```static constexpr size_t @_`count-of`_@(Tag) { return @_`see below`_@; }```]{.add}@@
>
>       @@[```template<class Fn>```]{.add}@@
>         @@[```static constexpr void @_`for-each`_@(Fn&& fn) { // exposition only```]{.add}@@
>           @@[```(std::forward<Fn>(fn)(static_cast<Fns*>(nullptr)), ...);```]{.add}@@
>         @@[```}```]{.add}@@
>     };
>
>   @<span style="color:blue;text-style:italic">&hellip; as before &hellip;</span>@
> }
> ```
>
> </div>

::: add

> [?]{.pnum} [For a subexpression `tag`, let `Tag` be the decayed type of `tag`.
> ```completion_signatures<Fns...>::@_`count-of`_@(tag)``` returns the count of
> function types in `Fns...` that are of the form `Tag(Ts...)` where `Ts` is a
> pack of types.]{.add}

:::

[Remove subclause [exec.util.cmplsig.trans].]{.ednote}


Proposed Wording for the Nice-to-haves
======================================

[Make the completion tags equality comparable with each other. Insert a new
paragraph after [exec.rcvr.concepts] as follows:]{.ednote}

> ::: add
> 
> **[33.7.?]{.pnum} Completion tags [exec.set]**
> 
> [1]{.pnum} The types `set_value_t`, `set_error_t`, and `set_stopped_t` are
> completion tag types ([exec.async.ops]). Each models `equality_comparable`,
> and each models `equality_comparable_with` the other two, with like types
> comparing equal and unlike types comparing not equal. For two completion tag
> objects `a` and `b`, `a == b` and `a != b` are core constant expressions and
> are not potentially throwing. [`set_value_t() == set_value_t()` is `true` and
> `set_value_t() == set_error_t()` is `false`.]{.example}
> 
> :::


[Instead of the change suggested above to [exec.util.complsig] para 8, split
para 8 into two after `struct completion_signatures` and modify as
follows:]{.ednote}

> [8]{.pnum} <div>
>
> ```c++
> namespace std::execution {
>   template<@_`completion-signature`_@... Fns>
>     struct completion_signatures {
>       @[`completion_signatures() = default;`]{.add}@
>
>       @[`constexpr explicit completion_signatures(Fns*...) noexcept`]{.add}@
>         @[`requires (0 != sizeof...(Fns)) {}`]{.add}@
>
>       @[`static constexpr size_t size() noexcept { return sizeof...(Fns); }`]{.add}@
>
>       @[`template<class... Others>`]{.add}@
>         @[`static constexpr bool contains(completion_signatures<Others...>) noexcept;`]{.add}@
>
>       @[`template<class Fn>`]{.add}@
>         @[`static constexpr auto filter(Fn) noexcept;`]{.add}@
>
>       @[`template<class Tag>`]{.add}@
>         @[`static constexpr auto select(Tag) noexcept;`]{.add}@
>
>       @@[```template<class MapFn, @_`callable`_@<@_`call-result-t`_@<MapFn, Fns*>...> ReduceFn>```]{.add}@@
>         @[`static constexpr auto transform_reduce(MapFn map, ReduceFn reduce);`]{.add}@
>
>       @[`template<class... Others>`]{.add}@
>         @[`constexpr auto operator+(completion_signatures<Others...>) noexcept;`]{.add}@
>
>       @[`template<class... Others>`]{.add}@
>         @[`constexpr bool operator==(completion_signatures<Others...> other) noexcept {`]{.add}@
>           @[`return size() == other.size() && contains(other);`]{.add}@
>         @[`}`]{.add}@
>     };
>
>   @[`template<size_t I, class... Fns>`]{.add}@
>     @[`constexpr auto get(completion_signatures<Fns...>) noexcept -> Fns...[I]* {`]{.add}@
>       @[`return nullptr;`]{.add}@
>     @[`}`]{.add}@
> }
>
> @[`namespace std {`]{.add}@
>   @[`using execution::get;`]{.add}@
>
>   @[`template<class... Fns>`]{.add}@
>     @[`struct tuple_size<execution::completion_signatures<Fns...>>`]{.add}@
>       @[`: integral_constant<size_t, sizeof...(Fns)> {};`]{.add}@
>
>   @[`template<size_t I, class... Fns>`]{.add}@
>     @[`struct tuple_element<I, execution::completion_signatures<Fns...>> {`]{.add}@
>       @[`using type = Fns...[I]*;`]{.add}@
>     @[`};`]{.add}@
> @[`}`]{.add}@
> ```
>
> </div>
>
> ::: add
>
> - [8.1]{.pnum} _Mandates_: For the specialization
>   `completion_signatures<Fns...>`, the types
>   ```@_`NORMALIZE-SIG`_@(Fns)...``` are unique.
>
> > ```c++
> > template<class... Others>
> > constexpr bool contains(completion_signatures<Others...>) noexcept;
> > ```
> 
> - [8.2]{.pnum} _Returns_: `true` if and only if for all types `T` in
>   `Others...` the expression ```(@_`MATCHING-SIG`_@(T, Fns) ||...)``` is
>   `true`.
>
> > ```c++
> > template<class Fn>
> > constexpr auto filter(Fn) noexcept;
> > ```
> 
> - [8.3]{.pnum} For a type `Ret` and pack `Args`, let
>   ```@_`maybe-completion`_@<Ret(Args...)>``` denote the type
>   `completion_signatures<Ret(Args...)>` if
>   ```@_`callable`_@<Fn, Ret(*)(Args...)>``` is `true`, and
>   `completion_signatures<>` otherwise.
>
> - [8.4]{.pnum} _Returns_:
>   ```(completion_signatures() +...+ @_`maybe-completion`_@<Fns>())```.
>
> > ```c++
> > template<class Tag>
> > constexpr auto select(Tag) noexcept;
> > ```
> 
> - [8.5]{.pnum} _Returns_: ```filter([]<class... Ts>(Tag(*)(Ts...)) {})```.
>
> > ```c++
> > template<class MapFn, @_`callable`_@<@_`call-result-t`_@<MapFn, Fns*>...> ReduceFn>
> > constexpr auto transform_reduce(MapFn map, ReduceFn reduce);
> > ```
> 
> - [8.6]{.pnum} _Returns_: ```reduce(map(static_cast<Fns*>(nullptr))...)```.
>
> > ```c++
> > template<class... Others>
> > constexpr auto operator+(completion_signatures<Others...>) noexcept;
> > ```
> 
> - [8.7]{.pnum} _Returns_: `completion_signatures<Us...>()`, where `Us` is the
>   pack of the types in ```@_`NORMALIZE-SIG`_@(Fns)...``` and
>   ```@_`NORMALIZE-SIG`_@(Others)...``` with duplicate types removed.
>
> > ```c++
> > template<class... Others>
> > constexpr bool operator==(completion_signatures<Others...> other) const noexcept;
> > ```
> 
> - [8.7]{.pnum} _Returns_: `size() == other.size() && contains(other)`.
>
> :::
>
> [The following is split from what is currently para 8 in the Working Draft.]{.ednote}
>
> [9]{.pnum} <div>
>
> ```c++
> namespace std::execution {
>   template<class Sndr, class Env = env<>,
>           template<class...> class Tuple = @_`decayed-tuple`_@,
>           template<class...> class Variant = @_`variant-or-empty`_@>
>       requires sender_in<Sndr, Env>
>     using value_types_of_t =
>       @_`gather-signatures`_@<set_value_t, completion_signatures_of_t<Sndr, Env>, Tuple, Variant>;
> 
>   template<class Sndr, class Env = env<>,
>           template<class...> class Variant = @_`variant-or-empty`_@>
>       requires sender_in<Sndr, Env>
>     using error_types_of_t =
>       @_`gather-signatures`_@<set_error_t, completion_signatures_of_t<Sndr, Env>,
>                         type_identity_t, Variant>;
> 
>   template<class Sndr, class Env = env<>>
>       requires sender_in<Sndr, Env>
>     constexpr bool sends_stopped =
>       !same_as<@_`type-list`_@<>,
>               @_`gather-signatures`_@<set_stopped_t, completion_signatures_of_t<Sndr, Env>,
>                                 @_`type-list`_@, @_`type-list`_@>>;
> 
> }
> ```
>
> </div>



[After [exec.util.cmplsig], insert a two new sections as follows:]{.ednote}

::: add

> **[33.10.?]{.pnum} `execution​::make_completion_signatures` [exec.util.cmplsig.make]**
> 
> > ```cpp
> > template <@_`completion-signature`_@... ExplicitSigs, @_`completion-signature`_@... DeducedSigs>
> >   constexpr auto make_completion_signatures(DeducedSigs*... sigs) noexcept
> >     -> @_`valid-completion-signatures`_@ auto;
> > ```
> 
> - [1]{.pnum} _Returns_: `completion_signatures<Ts...>()`, where `Ts` is a pack of the
>   types ```@_`NORMALIZE-SIG`_@(ExplicitSigs)..., @_`NORMALIZE-SIG`_@(DeducedSigs)...```
>   with duplicate types removed.
>
>
> **[33.10.?]{.pnum} `execution​::invalid_completion_signature` [exec.util.cmplsig.invalid]**
> 
> > ```cpp
> > template <class... Types, class... Values>
> >   [[noreturn, nodiscard]]
> >   consteval auto invalid_completion_signature(Values... values)
> >     -> completion_signatures<>;
> > ```
>
> - [1]{.pnum} `invalid_completion_signature` is used to report type errors
>   encountered while computing a sender's completion signatures.
>
> - [2]{.pnum} \[_Example 1_: A `current_scheduler` algorithm might use
>   `invalid_completion_signature` in its sender type as follows:
>
>   ```c++
>   template <const auto&> struct IN_ALGORITHM;
>   extern const struct current_scheduler_t current_scheduler; // an algorithm
>   
>   template <class Sndr, class Env>
>   constexpr auto current_scheduler_sender::get_completion_signatures() {
>     if constexpr (invocable<get_scheduler_t, Env>) {
>       using Result = invoke_result_t<get_scheduler_t, Env>;
>       return completion_signatures<set_value_t(Result)>();
>     } else {
>       // Oh no, the user made an error! Tell them about it.
>       return invalid_completion_signature<
>         IN_ALGORITHM<current_scheduler>,
>         struct NO_SCHEDULER_IN_THE_CURRENT_ENVIRONMENT,
>         struct WITH_ENVIRONMENT(Env)
>       >("The current execution environment does not have a value "
>         "for the get_scheduler query.");
>     }
>   }
>   ```
>
>   -- _end example_\]
>
> - [3]{.pnum} _Effects_: Equivalent to ```return (throw @_`unspecified`_@, completion_signatures());```.
>
> - [4]{.pnum} _Throws_: An exception of an unspecified type derived from
>   `exception`.
>
> - [5]{.pnum} _Recommended practice_: Implementations are encouraged to throw
>   an exception such that the template parameters and function arguments of
>   `invalid_completion_signature` appear in the compiler diagnostic should the
>   exception propagate out of a `consteval` context.


:::


[Replace the section [exec.util.cmplsig.trans] in the Working Draft with the
following:]{.ednote}

> **[33.10.2]{.pnum} `execution::transform_completion_signatures` [exec.util.cmplsig.trans]**
>
> [1]{.pnum} `transform_completion_signatures` is [an alias]{.rm} [a
> function]{.add} template used to transform one set of completion signatures
> into another. It takes a set of completion signatures and several other
> [template]{.rm} arguments that apply modifications to each completion
> signature in the set to generate [an instance of]{.add} a new specialization
> of `completion_signatures`.
>
> [2]{.pnum} \[_Example 1_: Given a sender [type]{.add} `Sndr` and an
> environment `Env`, adapt the completion signatures of `Sndr` by lvalue-ref
> qualifying the values, adding an additional `exception_ptr` error completion
> if it is not already there, and leaving the other completion signatures alone.
> 
> > ```c++ 
> > template<class... Args>
> >   using my_set_value_t =
> >     completion_signatures<
> >       set_value_t(add_lvalue_reference_t<Args>...)>;
> > 
> > @[`using`]{.rm}[`auto`]{.add}@ my_completion_signatures =
> >   transform_completion_signatures@[`<`]{.rm}[`(`]{.add}@
> >     @@```@[`get_`]{.add}@completion_signatures@[`_of_t`]{.rm}@<Sndr, Env>@[`()`]{.add}@```@@,
> >     @[`[]<class... Args>() { return my_set_value_t<Args...>(); },`]{.add}@
> >     @[`{},  // no-op error signature transform`]{.add}@
> >     @[`{},  // no-op stopped signature transform`]{.add}@
> >     completion_signatures<set_error_t(exception_ptr)>@[`());`]{.add}[`,`]{.rm}@
> >     @[`my_set_value_t>;`]{.rm}@
> > ```
>
> -- _end example_\]
> 
> [Replace the remaining paragraphs of [exec.util.cmplsig.trans] with the following:]{.ednote}
> 
> ::: add
> 
> [3]{.pnum} This subclause makes use of the following exposition-only entities:
> 
> > ```c++
> > template<class Tag>
> >   constexpr auto @_`pass-thru-transform`_@ = []<class... Ts>() noexcept {
> >     return completion_signatures<Tag(Ts...)>();
> >   };
> >
> > constexpr auto @_`concat-completions`_@ = [](auto... cs) noexcept {
> >   return (completion_signatures() +...+ cs);
> > };
> > ```
> 
> - [3.1]{.pnum} For a subexpression `fn` and a pack of types `Args`, let
>   ```@_`TRANSFORM-EXPR`_@(fn, Args)``` be expression-equivalent to `fn()` if
>   `sizeof...(Args) == 0` is `true` and `fn.template operator()<Args...>()`
>   otherwise. Let ```@_`APPLY-TRANSFORM`_@(fn, Args)``` be
>   expression-equivalent to:
>
>   - [3.1.1]{.pnum} ```@_`TRANSFORM-EXPR`_@(fn, Args)``` if that expression is
>     well-formed and has a type that satisfies _`valid-completion-signatures`_.
>
>   - [3.1.2]{.pnum} Otherwise,
>     ```(@_`TRANSFORM-EXPR`_@(fn, Args), throw @_`unspecified`_@, completion_signatures())```
>     if that expression is well-formed.
>
>   - [3.1.3]{.pnum} Otherwise, ```(throw @_`unspecified`_@, completion_signatures())```.
> 
> [4]{.pnum} <div>
> 
> ```c++
> template<
>     @_`valid-completion-signatures`_@ Completions,
>     class ValueTransform = decltype(@_`pass-thru-transform`_@<set_value_t>),
>     class ErrorTransform = decltype(@_`pass-thru-transform`_@<set_error_t>),
>     class StoppedTransform = decltype(@_`pass-thru-transform`_@<set_stopped_t>),
>     @_`valid-completion-signatures`_@ ExtraCompletions = completion_signatures<>>
>   constexpr auto transform_completion_signatures(
>       Completions completions,
>       ValueTransform value_transform = {},
>       ErrorTransform error_transform = {},
>       StoppedTransform stopped_transform = {},
>       ExtraCompletions extra_completions = {});
> ```
>
> </div>
>
> - [4.1]{.pnum} _Effects_: Equivalent to
> 
>   > ```c++
>   > auto transform = [=]<class Tag, class... Args>(Tag(*)(Args...)) {
>   >   if constexpr (same_as<Tag, set_value_t>)
>   >     return @_`APPLY-TRANSFORM`_@(value_transform, Args);
>   >   else if constexpr (same_as<Tag, set_error_t>)
>   >     return @_`APPLY-TRANSFORM`_@(error_transform, Args);
>   >   else
>   >     return @_`APPLY-TRANSFORM`_@(stopped_transform, Args);
>   > };
>   >
>   > return completions.transform_reduce(transform, @_`concat-completions`_@)
>   >   + extra_completions;
>   > ```
> 
> - [4.2]{.pnum } _Recommended practice_: Users are encouraged to throw descriptive
>   exceptions from their transformation functions when they encounter errors
>   during type computation.
> 
> :::


[Replace the section [exec.util.cmplsig.trans] in the Working Draft with the
following:]{.ednote}




<span style="color:blue;font-style:italic">To-Do</span>


Acknowledgements
================

I would like to thank Hana Dusíková for her work making constexpr exceptions a
reality for C++26. Thanks are also due to David Sankel for his encouragement to
investigate using constexpr exceptions as an alternative to TMP hackery, and for
giving feedback on an early draft of this paper.

---
references:
  - id: P3164R3
    citation-label: P3164R3
    title: "Improving diagnostics for sender expressions"
    author:
      - family: Niebler
        given: Eric
    URL: https://wg21.link/p3164r3
---
