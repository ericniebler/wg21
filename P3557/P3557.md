---
title: "High-Quality Sender Diagnostics with Constexpr Exceptions"
document: D3557R0
date: today
audience:
  - "LEWG Library Evolution"
author:
  - name: Eric Niebler
    email: <eric.niebler@gmail.com>
toc: true
---

<div style="text-align: right;">
_"Only the exceptional paths bring exceptional glories!"_<br/>
--- Mehmet Murat Ildan
</div>

Introduction
============

The hardest part of writing a sender algorithm is often the computation of its
completion signatures, an intricate meta-programming task. Using sender
algorithms incorrectly leads to large, incomprehensible errors deep within the
completion-signatures meta-program. What is needed is a way to propagate type
errors automatically to the API boundary where they can be reported concisely,
much the way exceptions do for runtime errors.

Support for exceptions during constant-evaluation was recently accepted into the
Working Draft for C++26. We can take advantage of this powerful new feature to
easily propagate type errors during the computation of a sender's completion
signatures. This significantly improves the diagnostics users are likely to
encounter while also simplifying the job of writing new sender algorithms.

Executive Summary
=================

This paper proposes the following changes to the working draft with the
addition of [@P3164R3]. Subsequent sections will address the motivation
and the designs in detail.

1. Change `std::execution::get_completion_signatures` from a customization
  point object that accepts a sender and (optionally) an environment to
  a `consteval` function template that takes no arguments, as follows:

::: cmptable

### Before
```cpp
inline constexpr struct get_completion_signatures_t {
  template <class Sndr, class... Env>
  auto operator()(Sndr&&, Env&&...) const -> @_`see below`_@;
} get_completion_signatures {};
```

### After
```cpp
template <class Sndr, class... Env>
consteval auto get_completion_signatures()
  -> @_`valid-completion-signatures`_@ auto;
```

:::

2. Change the mechanism by which senders customize `get_completion_signatures`
  from a member function that accepts the _cv_-qualified sender object and an
  optional environment object to a `static constexpr` function template that
  take the sender and environment types as template parameters.

::: cmptable

### Before
```cpp
struct my_sender {
  template <class Self, class... Env>
    requires @_`some-predicate`_@<Self, Env...>
  auto get_completion_signatures(this Self&&, Env&&) {
    return completion_signatures</* … */>();
  }
  ...
};
```

### After
```cpp
struct my_sender {
  template <class Self, class... Env>
  static constexpr auto get_completion_signatures() {
    if constexpr (!@_`some-predicate`_@<Self, Env...>) {
      throw @_`a-helpful-diagnostic`_@(); // <--- LOOK!
    }
    return completion_signatures</* … */>();
  }
  ...
};
```

:::

3. Change the `sender_in<Sender, Env...>` concept to test that
  `get_completion_signatures<Sndr, Env...>()` is a constant expression.

::: cmptable

### Before
```cpp
template<class Sndr, class... Env>
concept sender_in =
  sender<Sndr> &&
  (queryable<Env> &&...) &&
  requires (Sndr&& sndr, Env&&... env) {
    { get_completion_signatures(
        std::forward<Sndr>(sndr),
        std::forward<Env>(env)...) }
            -> @_`valid-completion-signatures`_@;
  };
```

### After
```cpp
template <auto>
concept @_`is-constant`_@ = true; // exposition only

template<class Sndr, class... Env>
concept sender_in =
  sender<Sndr> &&
  (queryable<Env> &&...) &&
  @_`is-constant`_@<get_completion_signatures<Sndr, Env...>()>;
```

:::

4. In the exposition-only _`basic-sender`_ class template, specify under what
  conditions its `get_completion_signatures` static member function is
  ill-formed when called without an `Env` template parameter (see proposed
  wording for details).

5. Add a `dependent_sender` concept that is modeled by sender types that do not
  know how they will complete independent of their execution environment.

6. \[Optional]: Remove the `transform_completion_signatures` alias template.

The following additions are suggested by this paper to make working with
completion signatures in `constexpr` code easier. None of these additions is
strictly necessary.

* Extend the [`completion_signatures`](#completion_signatures) class template
  with `constexpr` operations that make the manipulation of completion
  signatures more ergonomic. These extensions are:

  - Combining two sets of completion signatures with `operator+`.

  - Treating an instance of a completion signatures specialization as a tuple
    of function pointers. For example, `completion_signatures<set_value_t(int), set_stopped_t()>{}`
    would be usable as if it were `tuple<set_value_t(*)(), set_stopped_t(*)()>{nullptr, nullptr}`,
    which makes `std::apply` useful for munging completion signatures.

  - Adding CTAD to `completion_signatures` to deduce the signature types from a
    list of function pointers. Together with the above item, the following is
    the identity transform, given a `completion_signatures` object `cs`:

    > ```cpp
    > auto cs2 = std::apply([](auto... sigs){ return completion_signatures{sigs...}; }, cs);
    > static_assert(^^decltype(cs) == ^^decltype(cs2));
    > ```

* Add a [`make_completion_signatures`](#make_completion_signatures) helper
  function that takes signatures as template arguments or as function arguments
  or both. The returned value would have signatures that have been normalized,
  sorted ([@P2830R7]), and made unique.


* Add a [`get_child_completion_signatures`](#get_child_completion_signatures)
  function template that makes it easy for a sender adaptor to get the completion
  signatures of the child sender with the proper _cv_ qualification. It is
  simply:

  > ```cpp
  > template <class Parent, class Child, class... Env>
  > consteval auto get_child_completion_signatures() {
  >   using CvChild = decltype(std::forward_like<Parent>(declval<Child&>()));
  >   return get_completion_signatures<CvChild, Env...>();
  > }
  > ```

* Reintroduce
  [`transform_completion_signatures`](#transform_completion_signatures) as a
  `constexpr` function template that accepts lambdas as transforms. For example,
  the following code removes all error completions from a set, `cs`:

  > ```cpp
  > auto cs2 = transform_completion_signatures(
  >   cs,
  >   {}, // accept the default value completion transform
  >   []<class Error>() { return completion_signatures{}; });
  > ```

  See [`transform_completion_signatures`](#transform_completion_signatures) for
  a design description and reference implementation of the
  `transform_completion_signatures` function template.

* Add an [`invalid_completion_signature`](#invalid_completion_signature)
  `consteval` function template whose return type is `completion_signatures<>`
  but that throws an unspecified exception type that contains diagnostic
  information. A typical use would look like this:

  > ```cpp
  > template <class Q>
  > template <class Self, class Env>
  > static constexpr auto read_env_sender<Q>::get_completion_signatures() {
  >   namespace exec = std::execution;
  >   if constexpr (!std::invocable<Q, Env>) {
  >     // return type deduced to be completion_signatures<> but function exits
  >     // with an exception that contains the relevant diagnostic information.
  >     return exec::invalid_completion_signature<
  >        _IN_ALGORITHM<read_env>,
  >        _WITH_QUERY(Q),
  >        _WITH_ENVIRONMENT(Env)
  >     >("The environment does not provide a value for the given query type.");
  >   } else {
  >     using Result = std::invoke_result_t<Q, Env>;
  >     return exec::completion_signatures<exec::set_value_t(Result)>();
  >   }
  > }
  > ```

Revision History
================

R0
----
* Initial revision

Motivation
==========

This paper exists principly to improve the experience of users who make type
errors in their sender expressions by leveraging exceptions during constant-
evaluation. It is a follow-on of [@P3164R2], which defines a category of
"non-dependent" senders that can and must be type-checked early.

Senders have a construction phase and a subsequent connection phase. Prior to
P3164, all type-checking of senders happened at the connection phase (when a
sender is connected to a receiver). P3164 mandates that the sender algorithms
type-check non-dependent senders, moving the diagnostic closer to the source of
the error.

This paper addresses the _quality_ of those diagnostics and the diagnostics
users encounter when a dependent sender fails type-checking at connection time.

Senders are expression trees, and type errors can happen deep within their
structure. If programmed naively, ill-formed senders would generate megabytes of
incomprehensible diagnostics. The challenge is to report type errors _concisely_
and _comprehensibly_, at the right level of abstraction.

Doing this requires propagating domain-specific descriptions of type errors out
of the completion signatures meta-program so they can be reported concisely.
Such error detection and propagation is very cumbersome in template
meta-programming.

The C++ solution to error propagation is exceptions. With the adoption of
[@P3068R6], C++26 has gained the ability to throw and catch exceptions during
constant-evaluation. If we express the computation of completion signatures as a
`constexpr` meta-program, we can use exceptions to propagate type errors. This
greatly improves diagnostics and even simplifies the code that computes
completion signatures.

This paper proposes changes to `std::execution` that make the computation
of a sender's completion signatures an evaluation of a `constexpr` function.
It also specifies the conditions under which the computation is to exit
with an exception.

Proposed Design, Necessary Changes
==================================

`get_completion_signatures`
---------------------------

In the Working Draft, a sender's completion signatures are determined by the
type of the expression `std::execution::get_completion_signatures(sndr, env)`
(or, after P3164, `std::execution::get_completion_signatures(sndr)` for
non-dependent senders). Only the type of the expression matters; the expression
itself is never evaluated.

In the design proposed by this paper, the `get_completion_signatures` expression
must be constant-evaluated in order use exceptions to report errors. To
make it ammenable to constant evaluation, it must not accept arguments with
runtime values, so the expression is changed to
`std::execution::get_completion_signatures<Sndr, Env...>()`, where
`get_completion_signatures` is a `consteval` function.

If an unhandled exception propagates out of `get_completion_signatures` the
program is ill-formed (because `get_completion_signatures` is `consteval`). The
diagnostic displays the type and value of the exception.

`std::execution::get_completion_signatures<Sndr, Env...>()` in turn calls
<code>remove_reference_t&lt;Sndr>::template get_completion_signatures&lt;Sndr,
Env\...>()</code>, which computes the completion signatures or throws as
appropriate, as shown below:

> ```cpp
> namespace exec = std::execution;
>
> struct void_sender {
>   using sender_concept = exec::sender_t;
>
>   template <class Self, class... Env>
>   static constexpr auto get_completion_signatures() {
>     return exec::completion_signatures<exec::set_value_t()>();
>   }
>
>   /* … more … */
> };
> ```

To better support the `constexpr` value-oriented programming style, calls to
`get_completion_signatures` from a `constexpr` function are never ill-formed,
and they always have a `completion_signatures` type. `get_completion_signatures`
reports errors by failing to be a constant expression.

### Non-non-dependent senders

[@P3164R3] introduces the concept of non-dependent senders: senders that have
the same completion signatures regardless of the receiver's execution
environment. For a sender type `DependentSndr` whose completions _do_ depend on
the environment, what should happen when the sender's completions are queried
without an environment? That is, what should the semantics be for
`get_completion_signatures<DependentSndr>()`?

`get_completion_signatures<DependentSndr>()` should follow the general rule: it
should be well-formed in a `constexpr` function, and it should have a
`completion_signatures` type. That way, sender adaptors do not need to do
anything special when computing the completions of child senders that are
dependent. So `get_completion_signatures<DependentSndr>()` should throw.

If `get_completion_signatures<Sndr>()` throws for dependent senders, and it also
throws for non-dependent senders that fail to type-check, how then do we
distinguish between valid dependent and invalid non-dependent senders? We can
distinguish by checking the type of the exception.

An example will help. Consider the `read_env(q)` sender, a dependent sender that
sends the result of calling `q` with the receiver's environment. It cannot
compute its completion signatures without an environment. The natural way for
the `read_env` sender to express that is to require an `Env` parameter to its
customization of `get_completion_signatures`:

> ```cpp
> namespace exec = std::execution;
>
> template <class Query>
> struct read_env_sender {
>   using sender_concept = exec::sender_t;
>
>   template <class Self, class Env> // NOTE: Env is not optional!
>   static constexpr auto get_completion_signatures() {
>     if constexpr (!std::invocable<Query, Env>) {
>       throw @_`exception-type-goes-here`_@();
>     } else {
>       using Result = std::invoke_result_t<Query, Env>;
>       return exec::completion_signatures<exec::set_value_t(Result)>();
>     }
>   }
>
>   /* … more … */
> };
> ```

That makes `read_env_sender<Q>::get_completion_signatures<Sndr>()` an ill-formed
expression, which the `get_completion_signatures` function can detect. In such
cases, it would throw an exception of a special type that it can catch later
when distinguishing between dependent and non-dependent senders.

### Implementation

Since the design has several parts, reading the implementation of
`get_completion_signatures` is probably the easiest way to understand it. The
implementation is shown below with comments describing the parts.

> ```cpp
> // Some exposition-only helpers:
> template <template <class...> class C, class... Ts>
> using @_`well-formed-type`_@ =  // exposition only
>   requires { typename C<Ts...>; };
>
> template <class Sndr, class... Env>
> using @_`completion-signatures-of`_@ =  // exposition only
>   decltype(remove_reference_t<Sndr>::template get_completion_signatures<Sndr, Env...>());
>
> // A sender is dependent when its get_completion_signatures customization
> // cannot be called without an environment parameter.
> template <class Sndr, class... Env>
> concept @_`dependent-sender-without-env`_@ =  // exposition only
>   (sizeof...(Env) == 0) &&
>   !@_`well-formed-type`_@<@_`completion-signatures-of`_@, Sndr>;
>
> template <completion_signatures>
> concept @_`has-constexpr-completions-helper`_@ = true; // exposition only
>
> // A concept that tests that a sender's customization of get_completion_signatures
> // is well-formed, a constant expression, and has a type that is a specialization
> // of completion_signatures<>.
> template <class Sndr, class... Env>
> concept @_`has-constexpr-completions`_@ =   // exposition only
>   @_`has-constexpr-completions-helper`_@<
>     remove_reference_t<Sndr>::template get_completion_signatures<Sndr, Env...>()>;
>
> // This is a special exception type that will be thrown by
> // std::execution::get_completion_signatures when trying to query a dependent
> // sender for its non-dependent completions.
> struct @_`dependent-sender-error`_@ { };  // exposition only
>
> // Given a sender and zero or one environment, compute the sender's completion
> // signatures. Calls to this function are always well-formed and have a type
> // that is a specialization of completion_signatures.
> template <class Sndr, class... Env>
> constexpr auto @_`get-completion-signatures-impl`_@() {
>   using @_`sndr-type`_@ = remove_reference_t<Sndr>;
>
>   if constexpr (@_`has-constexpr-completions`_@<Sndr, Env...>) {
>     // In the happy case where Sndr's customization is well-formed, a constant
>     // expression, and has a completion_signatures<> type, just return the
>     // result of calling the customization.
>     return @_`sndr-type`_@::template get_completion_signatures<Sndr, Env...>();
>   }
>   else if constexpr (@_`dependent-sender-without-env`_@<Sndr, Env...>) {
>     // If Sndr is dependent and we don't have an environment, throw an exception,
>     // but ensure that the return type of this function is a specialization
>     // of completion_signatures.
>     return (throw @_`dependent-sender-error`_@(), completion_signatures());
>   }
>   else if constexpr (!@_`well-formed-type`_@<@_`completion-signatures-of`_@, Sndr, Env...>>) {
>     // For some reason, the Sndr's customization cannot be called even with an
>     // environment. This is a library bug; it should always be callable from
>     // a constexpr context. Report the library bug by throwing an exception,
>     // taking care to ensure the return type is a completion_signatures type.
>     return (throw @_`unspecified`_@, completion_signatures());
>   }
>   else {
>     // Otherwise, we reach here under the following conditions:
>     // - The call to Sndr's customization cannot be constant-evaluated (possibly
>     //   because it throws), or
>     // - Its return type is not a completion_signatures type.
>     //
>     // We want to call the call the Sndr's customization so that if it throws
>     // an exception, that exception's information will appear in the diagnostic.
>     // If it doesn't throw, _we_ should throw to let the developer know that
>     // their customization returned an invalid type. And again, ensure that
>     // the return type is a completion_signatures type.
>     return (@_`sndr-type`_@::template get_completion_signatures<Sndr, Env...>(),
>             throw @_`unspecified`_@,
>             completion_signatures());
>   }
> }
>
> // Applies a late sender transformation if appropriate, then computes the
> // completion signatures. Calls to this function are always well-formed and
> // have a type that is a specialization of completion_signatures.
> template <class Sndr, class... Env>
> consteval auto get_completion_signatures() {
>   if constexpr (sizeof...(Env) == 0) {
>     return @_`get-completion-signatures-impl`_@<Sndr>();
>   }
>   else {
>     // Apply a late sender transform:
>     using NewSndr = decltype(transform_sender(/* … */));
>     return @_`get-completion-signatures-impl`_@<NewSndr, Env...>();
>   }
> }
> ```

Given this definition of `get_completion_signatures`, we can implement
a `dependent_sender` concept as follows:

> ```cpp
> // Returns true when get_completion_signatures<Sndr>() throws a
> // dependent-sender-error. Returns false when
> // get_completion_signatures<Sndr>() returns normally (Sndr is non-dependent),
> // or when it throws any other kind of exception (Sndr fails type-checking).
> template <class Sndr>
> consteval bool @_`is-dependent-sender-helper`_@() {
>   try {
>     get_completion_signatures<Sndr>();
>   } catch (@_`dependent-sender-error`_@&) {
>     return true;
>   }
>   return false;
> }
>
> template <class Sndr>
> concept dependent_sender =
>   sender<Sndr> && std::bool_constant<@_`is-dependent-sender-helper`_@<Sndr>()>::value;
> ```

After the adoption of [@P3164R3], the sender algorithms are all required to
return senders that are either dependent or else that type-check successfully.
One way to implement this is with the following helper:

> ```cpp
> template <class Sndr>
> constexpr auto __type_check_sender(Sndr sndr) {
>   if constexpr (!dependent_sender<Sndr>) {
>     // This line will fail to compile if Sndr fails its type checking. We
>     // don't want to perform this type checking when Sndr is dependent, though.
>     // Without an environment, the sender doesn't know its completions.
>     get_completion_signatures<Sndr>();
>   }
>   return sndr;
> }
> ```

Sender algorithms could use this helper when returning the new sender.
For example, the `then` algorithm might look something like this:

> ```cpp
> inline constexpr struct then_t : __pipeable_sender_adaptor<then_t> {
>   template <sender Sndr, class Fn>
>   auto operator()(Sndr sndr, Fn fn) const {
>     return __type_check_sender(__then_sender{std::move(sndr), std::move(fn)});
>   }
> } then {};
> ```

`sender_in`
-----------

With the above changes, we need to tweak the `sender_in` concept to require
that `get_completion_signatures<Sndr, Env...>()` is a constant expression.

The changes to `sender_in` relative to [@P3164R3] are as follows:

> ```cpp
> @[`template <auto>`]{.add}@
>   @@[`concept @_is-constant_@ = true; @_// exposition only_@`]{.add}@@
>
> template<class Sndr, class... Env>
>   concept sender_in =
>     sender<Sndr> &&
>     (sizeof...(Env) <= 1)
>     (queryable<Env> &&...) &&
>     @@[`@_is-constant_@<get_completion_signatures<Sndr, Env...>()>;`]{.add}@@
>     @[`requires (Sndr&& sndr, Env&&... env) {`]{.rm}@
>       @[`{ get_completion_signatures(std::forward<Sndr>(sndr), std::forward<Env>(env)...) }`]{.rm}@
>         @@[`-> @_valid-completion-signatures_@;`]{.rm}@@
>     @[`};`]{.rm}@
> ```

_`basic-sender`_
----------------

The sender algorithms are expressed in terms of the exposition-only class
template _`basic-sender`_. The mechanics of computing completion signatures is
not specified, however, so very little change there is needed to implement this
proposal.

We do, however, have to say when
<code><em>basic-sender</em>::get_completion_signatures&lt;Sndr>()</code> is
ill-formed. In [@P3164R3], non-dependent senders are dealt with by discussing
whether or not a sender's potentially-evaluated completion operations are
dependent on the type of the receiver's environment. In this paper, we make a
similar appeal when specifying whether or not
<code><em>basic-sender</em>::get_completion_signatures&lt;Sndr>()</code> is
well-formed.

`dependent_sender`
------------------

Users who write their own sender adaptors will also want to perform early
type-checking of senders that are not dependent. Therefore, they need a way
to determine whether or not a sender is dependent.

In the section [`get_completion_signatures`](#get_completion_signatures) we show
how the concept `dependent_sender` can be implemented in terms of this paper's
`get_completion_signatures` function template. By making this a public-facing
concept, we give sender adaptor authors a way to do early type-checking, just
like the standard adaptors.

Proposed Design, Nice-to-haves
==============================

`completion_signatures`
-----------------------

Computing completions signatures is now to be done using `constexpr`
meta-programming by manipulating values using ordinary imperative C++ rather
than template meta-programming. To better support this style of programming,
it is helpful to add `constexpr` operations that manipulate instances of
specializations of the `completion_signatures` class template.

For example, it should be possible to take the union of two sets of completion
signatures. `operator+` seems like a natural choice for that:

> ```cpp
> completion_signatures<set_value_t(int), set_error_t(exception_ptr)> cs1;
> completion_signatures<set_stopped_t(), set_error_t(exception_ptr)> cs2;
>
> auto cs3 = cs1 + cs2; // completion_signatures<set_value_t(int),
>                       //                       set_error_t(exception_ptr),
>                       //                       set_stopped_t()>
> ```

It can also be convenient for `completion_signature` specializations to model
[_`tuple-like`_](https://en.cppreference.com/w/cpp/utility/tuple/tuple-like).
Although tuple elements cannot have funtion type, they can have function
_pointer_ type. With this proposal, an object like
`completion_signatures<set_value_t(int), set_stopped_t()>{}` behaves like
`tuple<set_value_t(*)(int), set_stopped_t(*)()>{nullptr, nullptr}` (except that
it wouldn't actually have to store the `nullptr`s). That would make it possible
to manipulate completion signatures using `std::apply`:

> ```cpp
> auto cs = /* … */;
>
> // Add an lvalue reference to all arguments of all signatures:
> auto add_ref =     []<class T, class... As>(T(*)(As...)) -> T(*)(As&...) { return {}; };
> auto add_ref_all = [=](auto... sigs) { return make_completion_signatures(add_ref(sigs)...); };
>
> return std::apply(add_ref_all, cs);
> ```

The code above uses another nice-to-have feature: a `make_completion_signatures`
helper function that deduces the signatures from the arguments, removes any
duplicates, and returns a new instance of `completion_signatures`.

Consider trying to do all the above using template meta-programming. &#x1F62C;

`make_completion_signatures`
----------------------------

The `make_completion_signatures` helper function described just above would allow
users to build a `completion_signatures` object from a bunch of signature types,
or from function pointer objects, or a combination of both:

> ```cpp
> // Returns a default-initialized object of type completion_signatures<Sigs...>,
> // where Sigs is the set union of the normalized ExplicitSigs and DeducedSigs.
> template <@_`completion-signature`_@... ExplicitSigs, @_`completion-signature`_@... DeducedSigs>
> constexpr auto make_completion_signatures(DeducedSigs*... sigs) noexcept
>   -> @_`valid-completion-signatures`_@ auto;
> ```

To "normalize" a completion signature means to strip rvalue references from the
arguments. So, `set_value_t(int&&, float&)` becomes `set_value_t(int, float&)`.
`make_completions_signatures` first normalizes all the signatures and then
removes duplicates. ([@P2830R7] lets us order types, so making the set unique
will be _O_(_n_ log _n_).)

`transform_completion_signatures`
---------------------------------

The current Working Draft has a utility to make type transformations of
completion signature sets simpler: the alias template
`transform_completion_signatures`. It looks like this:

> ```cpp
> template <class... As>
> using @_value-transform-default_@ = completion_signatures<set_value_t(As...)>;
>
> template <class Error>
> using @_error-transform-default_@ = completion_signatures<set_error_t(Error)>;
>
> template <@_valid-completion-signatures_@ Completions,
>           @_valid-completion-signatures_@ OtherCompletions = completion_signatures<>,
>           template <class...> class ValueTransform = @_value-transform-default_@,
>           template <class> class ErrorTransform = @_error-transform-default_@,
>           @_valid-completion-signatures_@ StoppedCompletions = completion_signatures<set_stopped_t()>>
> using transform_completion_signatures = /*see below*/;
> ```

Anything that can be done with `transform_completion_signatures` can be done in
`constexpr` using `std::apply`, a lambda with `if constexpr`, and `operator+` of
`completion_signature` objects. In fact, we could even implement
`transform_completion_signatures` itself that way:

> ```cpp
> template </* … as before … */>
> using transform_completion_signatures =
>   std::constant_wrapper< // see @@[@P2781R5]@@
>     std::apply(
>       [](auto... sigs) {
>         return ([]<class T, class... As>(T (*)(As...)) {
>           if constexpr (^^T == ^^set_value_t) { // use reflection to test type equality
>             return ValueTransform<As...>();
>           } else if constexpr (^^T == ^^set_error_t) {
>             return ErrorTransform<As...[0]>();
>           } else {
>             return StoppedCompletions();
>           }
>         }(sigs) +...+ completion_signatures());
>       },
>       Completions()
>     ) + OtherCompletions()
>   >::value_type;
> ```

This paper proposes dropping the `transform_completion_signatures` type alias
since it is not in the ideal form for `constexpr` meta-programming, and since
`std::apply` is good enough (sort of).

However, should we decide to keep the functionality of
`transform_completion_signatures`, we can reexpress it as a `constexpr` function
that accepts transforms as lambdas:

> ```cpp
> constexpr auto @_value-transform-default_@ = []<class... As>() { return completion_signatures<set_value_t(As...)>(); };
> constexpr auto @_error-transform-default_@ = []<class Error>() { return completion_signatures<set_error_t(Error)>(); };
>
> template <@_valid-completion-signatures_@ Completions,
>           class ValueTransform = decltype(@_value-transform-default_@),
>           class ErrorTransform = decltype(@_error-transform-default_@),
>           @_valid-completion-signatures_@ StoppedCompletions = completion_signatures<set_stopped_t()>,
>           @_valid-completion-signatures_@ OtherCompletions = completion_signatures<>>
> consteval auto transform_completion_signatures(Completions completions,
>                                                ValueTransform value_transform = {},
>                                                ErrorTransform error_transform = {},
>                                                StoppedCompletions stopped_completions = {},
>                                                OtherCompletions other_completions = {})
>   -> @_valid-completion-signatures_@ auto;
> ```

The above form of `transform_completion_signatures` is more natural to use from
within a `constexpr` function. It also makes it simple to accept the default for
some arguments as shown below:

> ```cpp
> // Transform just the error completion signatures:
> auto cs2 = transform_completion_signatures(cs, {}, []<class E>() { return /* … */; });
>                                            //  ^^  Accept the default value transform
> ```

Since accepting the default transforms is simple, we are able to move the
infrequently used `OtherCompletions` argument to the end of the argument list.

Although the signature of this `transform_completion_signatures` function looks
frightful, the implementation is quite straightforward, and seeing it might
make it less scary:

> ```cpp
> template <class... As, class Fn>
> consteval auto __apply_transform(const Fn& fn) {
>   if constexpr (!requires {{fn.template operator()<As...>()} -> __valid_completion_signatures;})
>     return invalid_completion_signature< @...@ >( @...@ ); // see below
>   else
>     return fn.template operator()<As...>();
> }
>
> template < /* @...@ as shown above @...@ */ >
> consteval auto transform_completion_signatures(Completions completions,
>                                                ValueTransform value_transform,
>                                                ErrorTransform error_transform,
>                                                StoppedCompletions stopped_completions,
>                                                OtherCompletions other_completions) {
>   auto transform1 = [=]<class T, class... As>(Tag(*)(As...)) {
>     if constexpr (Tag() == set_value) // see "@[Completion tag comparison](#completion-tag-comparison)@" below
>       return __apply_transform<As...>(value_transform);
>     else if constexpr (Tag() == set_error)
>       return __apply_transform<As...>(error_transform);
>     else
>       return stopped_completions;
>   };
>
>   auto transform_all = [=](auto*... sigs) {
>     return (transform1(sigs) +...+ completion_signatures());
>   };
>
>   return std::apply(transform_all, completions) + other_completions;
> }
> ```

Like `get_completion_signatures`, `transform_completion_signatures` always
returns a specialization of `completion_signatures` and reports errors by
throwing exceptions. It expects the lambdas passed to it to do likewise (but
handles it gracefully if they don't).

`invalid_completion_signature`
------------------------------

The reason for the design change is to permit the reporting of type errors using
exceptions. Let's look at an example where it would be desirable to throw an
exception from `get_completion_signatures`: the `then` algorithm. We will use
this example to motivate the rest of the design changes.

The `then` algorithm attaches a continuation to an async operation that executes
when the operation completes successfully. With this proposal, a `then_sender`'s
`get_completion_signatures` customization might be implemented as follows:

> ```cpp
> template <class Sndr, class Fun>
> template <class Self, class... Env>
> constexpr auto then_sender<Sndr, Fun>::get_completion_signatures() {
>   // compute the completions of the (properly cv-qualified) child:
>   using Child = decltype(std::forward_like<Self>(declval<Sndr&>()));
>   auto child_completions = get_completion_signatures<Child, Env...>();
>
>    // This lambda is used to transform value completion signatures:
>   auto value_transform = []<class... As>() {
>     if constexpr (std::invocable<Fun, As...>) {
>       using Result = std::invoke_result_t<Fun, As...>;
>       return completion_signatures<set_value_t(Result)>();
>     } else {
>       // Oh no, the user made an error! Tell them about it.
>       throw @_`some-exception-object`_@;
>     }
>   };
>
>   // Transform just the value completions:
>   return transform_completion_signatures(child_completions, value_transform);
> }
> ```

We would like to make it dead simple to throw an exception that will convey a
domain-specific diagnostic to the user. That way, the authors of sender
algorithms will be more likely to do so.

The `invalid_completion_signature` helper function is designed to make generating
meaningful diagnostics easy. As an example, here is how the `then_sender`'s
`completion_signatures` customization might use it:

> ```cpp
> template <const auto&> struct IN_ALGORITHM;
>
> template <class Sndr, class Fun>
> template <class Self, class... Env>
> constexpr auto then_sender<Sndr, Fun>::get_completion_signatures() {
>   /* … */
>   // This lambda is used to transform value completion signatures:
>   auto value_transform = []<class... As>() {
>     if constexpr (std::invocable<Fun, As...>) {
>       using Result = std::invoke_result_t<Fun, As...>;
>       return completion_signatures<set_value_t(Result)>();
>     } else {
>       // Oh no, the user made an error! Tell them about it.
>       return invalid_completion_signature<
>         IN_ALGORITHM<std::execution::then>,
>         struct WITH_FUNCTION(Fun),
>         struct WITH_ARGUMENTS(As...)
>       >("The function passed to std::execution::then is not callable "
>         "with the values sent by the predecessor sender.");
>     }
>   };
>   /* … */
> }
> ```

When the user of `then` makes a mistake, say like with the expression
"`just(42) | then([]() {…})`", they will get a helpful diagnostic like
the following (relevant bits highlighted):

<blockquote>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">
<span><b>&lt;source&gt;:658:3: </b><b><span style="color:red">error: </span></b><b>call to immediate function 'operator|&lt;just_sender&lt;int&gt;&gt;'
is not a constant expression</b></span>
  658 |   just(<span style="color:green">42</span>) | then([](){})
      | <b><span style="color:green">  ^</span></b>
<span><b><span style="color:green"></span></b><b>&lt;source&gt;:564:14: </b><b><span style="color:cyan">note: </span></b>'operator|&lt;just_sender&lt;int&gt;&gt;' is an immediate function be
cause its body contains a call to an immediate function '__type_check_sender&lt;the
n_sender&lt;just_sender&lt;int&gt;, (lambda at &lt;source&gt;:658:19)&gt;&gt;' and that call is not a
constant expression</span>
  564 |       <span style="color:blue">return</span> __type_check_sender(then_sender{{}, self.fn_, sndr});
      | <b><span style="color:green">             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></b>
<span><b><span style="color:green"></span></b><b>&lt;source&gt;:358:11: </b><b><span style="color:cyan">note: </span></b>unhandled exception of type '__sender_type_check_failure&lt;
const char *, <span style="background-color:yellow">IN_ALGORITHM&lt;then&gt;, WITH_FUNCTION ((lambda at &lt;source&gt;:658:19)), W
ITH_ARGUMENTS (int)&gt;' with content {&amp;"The function passed to std::execution::the
n is not callable with the values sent by the predecessor sender."[0]}</span> thrown fr
om here</span>
  358 |     <span style="color:blue">throw</span> __sender_type_check_failure&lt;Values...[<span style="color:green">0</span>], What...&gt;(values...);
      | <b><span style="color:green">          ^</span></b>
<b><span style="color:green"></span></b>1 error generated.
Compiler returned: 1</code></pre></div>
</blockquote>

The above is the _complete_ diagnostic, regardless of how deeply nested the type error
is. So long, megabytes of template spew!

Lambdas passed to `transform_completion_signatures` _should_ return a
`completion_signatures` specialization (although
`transform_completion_signatures` recovers gracefully when they do not). The
return type of `invalid_completion_signature` is `completion_signature<>`. By
"returning" the result of calling `invalid_completion_signature`, the deduced
return type of the lambda is a `completion_signatures` type, as it should be.

A possible implementation of the `invalid_completion_signature` function is
shown below:

> ```cpp
> template <class... What, class... Args>
> struct @_sender-type-check-failure_@ : std::exception { // exposition only
>   constexpr @_sender-type-check-failure_@(Args... args) : @*args_*@{std::move(args)...} {}
>   constexpr char const* what() const noexcept override { return @_unspecified_@; };
>   std::tuple<Args...> @*args_*@; // exposition only
> };
>
> template <class... What, class... Args>
> [[noreturn, nodiscard]]
> consteval completion_signatures<> invalid_completion_signature(Args... args) {
>   throw @_sender-type-check-failure_@<What..., Args...>{std::move(args)...};
> }
> ```

`get_child_completion_signatures`
---------------------------------

In the `then_sender` above, computing a child sender's completion signatures is a little awkward:

> ```cpp
> // compute the completions of the (properly cv-qualified) child:
> using Child = decltype(std::forward_like<Self>(declval<Sndr&>()));
> auto child_completions = get_completion_signatures<Child, Env...>();
> ```

Computing the completions of child senders will need to be done by every sender
adaptor algorithm. We can make this simpler with a
`get_child_completion_signatures` helper function:

> ```cpp
> // compute the completions of the (properly cv-qualified) child:
> auto child_completions = get_child_completion_signatures<Self, Sndr, Env...>();
> ```

... where `get_child_completion_signatures` is defined as follows:

> ```cpp
> template <class Parent, class Child, class... Env>
> consteval auto get_child_completion_signatures() {
>   using @_cvref-child-type_@ = decltype(std::forward_like<Parent>(declval<Child&>()));
>   return get_completion_signatures<@_cvref-child-type_@, Env...>();
> }
> ```

Completion tag comparison
-------------------------

For convenience, we can make the completion tag types equality-comparable with
each other. When writing sender adaptor algorithms, code like the following will
be common:

> ```cpp
> []<class Tag, class... Args>(Tag(*)(Args...)) {
>   if constexpr (std::is_same_v<Tag, exec::set_value_t>) {
>     // Do something
>   }
>   else {
>     // Do something else
>   }
> }
> ```

Although certainly not hard, with reflection the tag type comparison becomes a
litte simpler:

> ```cpp
>   if constexpr (^^Tag == ^^exec::set_value_t>) {
> ```

We can make this even easier by simply making the completion tag types
equality-comparable, as follows:

> ```cpp
>   if constexpr (Tag() == exec::set_value) {
> ```

The author finds that this makes his code read better. Tag types would compare
equal to themselves and not-equal to the other two tag types.

`eptr_completion_if`
--------------------

The following is a trivial utility that the author finds he uses surprisingly
often. Frequently an async operation can complete exceptionally, but only
under certain conditions. In cases such as those, it is necessary to add a
`set_error_t(std::exception_ptr)` signature to the set of completions, but only
when the condition is met.

This is made simpler with the following variable template:

> ```cpp
> template <bool PotentiallyThrowing>
> inline constexpr auto eptr_completion_if =
>   std::conditional_t<PotentiallyThrowing,
>                      completion_signatures<set_error_t(exception_ptr)>,
>                      completion_signatures<>>();
> ```

Below is an example usage, from the `then` sender:

> ```cpp
> template <class Sndr, class Fun>
> template <class Self, class... Env>
> constexpr auto then_sender<Sndr, Fun>::get_completion_signatures() {
>   auto cs = get_child_completion_signatures<Self, Sndr, Env...>();
>   auto value_fn = []<class... As>() { /* … as shown in section "@[invalid_completion_signature](#invalid_completion_signature)@" */ };
>   constexpr bool nothrow = /* … false if Fun can throw for any set of the predecessor's values */;
>
>   // Use eptr_completion_if here as the "extra" set of completions that
>   // will be added to the ones returned from the transforms.
>   return transform_completion_signatures(cs, value_fn, {}, {}, eptr_completion_if<!nothrow>);
> }
> ```

Questions for LEWG
==================

Assuming we want to change how completion signatures are computed as proposed in
this paper, the author would appreciate LEWG's feedback about the suggested
additions.

1. Do we want to use `operator+` to join two `completion_signature` objects?

2. Do we want to make `completion_signatures<Sigs...>` _`tuple-like`_ (where
    `completion_signatures<Sigs...>()` behaves like `tuple<Sigs*...>()`)?

3. Should we drop the `transform_completion_signatures` alias template?

4. Should we add a `make_completion_signatures` helper function that returns
    an instance of a `completion_signatures` type with its function types
    normalized and made unique?

5. Should we replace the `transform_completion_signatures` alias template with
    a `consteval` function that does the same thing but for values?

6. Do we want the `invalid_completion_signature` helper function to make it
    easy to generate good diagnostics when type-checking a sender fails.

7. Do we want the `get_child_completion_signatures` helper function to make
    is easy for sender adaptors to get a (properly _cv_-qualified) child
    sender's completion signatures?

8. Do we want to make the completion tag types (`set_value_t`, etc.)
    `constexpr` equality-comparable with each other?

9. Do we want the `eptr_completion_if` variable template, which is an object of
    type `completion_signatures<set_error_t(std::exception_ptr)>` or
    `completion_signatures<>` depending on a `bool` template parameter?

Implementation Experience
=========================

The design proposed in this paper has been prototyped and can be found
on [Compiler Explorer](https://godbolt.org/z/Y1vPcn6Kr)[^1].

[^1]: [https://godbolt.org/z/Y1vPcn6Kr](https://godbolt.org/z/Y1vPcn6Kr)

Proposed Wording
================

[This wording is relative to the current working draft with the addition of
[@P3164R3]]{.ednote}

[Change [exec.general] as follows:]{.ednote}

> 7. [For function type `R(Args...)`, let ```@_`NORMALIZE-SIG`_@(R(Args...))```
>    denote the type ```R(@_`remove-rvalue-reference-t`_@<Args>...)``` where
>    _`remove-rvalue-reference-t`_ is an alias template that removes an rvalue
>    reference from a type.]{.add}
>
> 7. For function types `F1` and `F2` [denoting `R1(Args1...)` and
>    `R2(Args2...)`, respectively,]{.rm} ```@_`MATCHING-SIG`_@(F1, F2)``` is
>    `true` if and only if <code>same_as<[`R1(Args1&&...),
>    R2(Args2&&...)`]{.rm}[```@_NORMALIZE-SIG_@(F1),
>    @_NORMALIZE-SIG_@(F2)```]{.add}></code> is `true`.
>
> 8. For a subexpression `err`, let `Err` be `decltype((err))` and let
>    ```@_`AS-EXCEPT-PTR`_@(err)``` be [&hellip; as before]{.ednote}


[Change [execution.syn] as follows:]{.ednote}

> <b>Header `<execution>` synopsis [execution.syn]</b>
>
> ```cpp
> namespace std::execution {
>   @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
>
>   template<class Sndr, class... Env>
>     concept sender_in = @ _see below_ @;
>
>   @[`template<class Sndr>`{.cpp}]{.add}@
>     @@[`concept dependent_sender = @ _see below_@;`{.cpp}]{.add}@@
>
>   template<class Sndr, class Rcvr>
>     concept sender_to = @ _see below_@;
>
>   template<class... Ts>
>     struct @_`type-list`_@;                                           // exposition only
>
>   @[`// [exec.getcomplsigs], completion signatures`]{.rm}@
>   @[`struct get_completion_signatures_t;`]{.rm}@
>   @[`inline constexpr get_completion_signatures_t get_completion_signatures {};`]{.rm}@
>
>   @[`This alias is moved below and modified.`]{.ednote}@
>   @[`template<class Sndr, class... Env>`]{.rm}@
>       @[`requires sender_in<Sndr, Env...>`]{.rm}@
>     @@[```using completion_signatures_of_t = @_`call-result-t`_@<get_completion_signatures_t, Sndr, Env...>;```]{.rm}@@
>
>   template<class... Ts>
>     using @_`decayed-tuple`_@ = tuple<decay_t<Ts>...>;                // exposition only
>
>   @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
>
>   // [exec.util], sender and receiver utilities
>   // [exec.util.cmplsig] @[`completion signatures`]{.add}@
>   template<class Fn>
>     concept @_`completion-signature`_@ = @_`see below`_@;                   // exposition only
>
>   template<@_`completion-signature`_@... Fns>
>     struct completion_signatures @[`{}`]{.rm}@;
>
>   template<class Sigs>
>     concept @_`valid-completion-signatures`_@ = @_`see below`_@;            // exposition only
>
>   @@[```struct @_`dependent-sender-error`_@ {};```]{.add}@@                             @[_`// exposition only`{.cpp}_]{.add}@
>
>   @[`// [exec.getcomplsigs]`]{.add}@
>   @[`template<class Sndr, class... Env>`]{.add}@
>     @@[```consteval auto get_completion_signatures() -> @_`valid-completion-signatures`_@ auto;```]{.add}@@
>
>   @[`template<class Sndr, class... Env>`]{.add}@
>       @[`requires sender_in<Sndr, Env...>`]{.add}@
>     @[`using completion_signatures_of_t = decltype(get_completion_signatures<Sndr, Env...>());`]{.add}@
>
>   @@[`// [exec.util.cmplsig.trans]`]{.rm}@@
>   @@[`template<`]{.rm}@@
>     @@[```@_`valid-completion-signatures`_@ InputSignatures,```]{.rm}@@
>     @@[```@_`valid-completion-signatures`_@ AdditionalSignatures = completion_signatures<>,```]{.rm}@@
>     @@[```template<class...> class SetValue = @_`see below`_@,```]{.rm}@@
>     @@[```template<class> class SetError = @_`see below`_@,```]{.rm}@@
>     @@[```@_`valid-completion-signatures`_@ SetStopped = completion_signatures<set_stopped_t()>>```]{.rm}@@
>   @@[```using transform_completion_signatures = completion_signatures<@_`see below`_@>;```]{.rm}@@
>
>   @@[`template<`]{.rm}@@
>     @@[`sender Sndr,`]{.rm}@@
>     @@[`class Env = env<>,`]{.rm}@@
>     @@[```@_`valid-completion-signatures`_@ AdditionalSignatures = completion_signatures<>,```]{.rm}@@
>     @@[```template<class...> class SetValue = @_`see below`_@,```]{.rm}@@
>     @@[```template<class> class SetError = @_`see below`_@,```]{.rm}@@
>     @@[```@_`valid-completion-signatures`_@ SetStopped = completion_signatures<set_stopped_t()>>```]{.rm}@@
>       @@[`requires sender_in<Sndr, Env>`]{.rm}@@
>   @@[`using transform_completion_signatures_of =`]{.rm}@@
>     @@[`transform_completion_signatures<`]{.rm}@@
>       @@[`completion_signatures_of_t<Sndr, Env>,`]{.rm}@@
>       @@[`AdditionalSignatures, SetValue, SetError, SetStopped>;`]{.rm}@@
>
>   // [exec.run.loop], run_loop
>   class run_loop;
>
>   @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
>
> }
> ```

[Add the following paragraph after [execution.syn] para 3 (this is moved from [exec.snd.concepts])]{.ednote}

::: add

> 4. [A type models the exposition-only concept _`valid-completion-signatures`_ if
>    it denotes a specialization of the `completion_signatures` class template.]{.add}

:::


[Modify [exec.snd.general] as follows:]{.ednote}

> 1. Subclauses [exec.factories] and [exec.adapt] define customizable algorithms
>     that return senders. Each algorithm has a default implementation. Let
>     `sndr` be the result of an invocation of such an algorithm or an object
>     equal to the result ([concepts.equality]), and let `Sndr` be
>     `decltype((sndr))`. Let `rcvr` be a receiver of type `Rcvr` with
>     associated environment `env` of type `Env` such that `sender_to<Sndr,
>     Rcvr>` is `true`. For the default implementation of the algorithm that
>     produced `sndr`, connecting `sndr` to `rcvr` and starting the resulting
>     operation state ([exec.async.ops]) necessarily results in the potential
>     evaluation ([basic.def.odr]) of a set of completion operations whose first
>     argument is a subexpression equal to `rcvr`. Let `Sigs` be a pack of
>     completion signatures corresponding to this set of completion operations,
>     and let `CS` be the type of the expression
>     [`get_completion_signatures(sndr, env)`]{.rm}
>     [`get_completion_signatures<Sndr, Env>()`]{.add}. Then `CS` is a
>     specialization of the class template `completion_signatures`
>     ([exec.util.cmplsig]), the set of whose template arguments is `Sigs`. If
>     none of the types in `Sigs` are dependent on the type `Env`, then the
>     expression [`get_completion_signatures(sndr)`]{.rm}
>     [`get_completion_signatures<Sndr>()`]{.add} is well-formed and its type is
>     `CS`. If a user-provided implementation of the algorithm that produced
>     `sndr` is selected instead of the default:
>
>     - [1.1]{.pnum} Any completion signature that is in the set of types
>       denoted by `completion_signatures_of_t<Sndr, Env>` and that is not part of
>       `Sigs` shall correspond to error or stopped completion operations, unless
>       otherwise specified.
>
>     - [1.2]{.pnum} If none of the types in `Sigs` are dependent on the type
>       `Env`, then `completion_signatures_of_t<Sndr>` and
>       `completion_signatures_of_t<Sndr, Env>` shall denote the same type.

[In [exec.snd.expos], insert the following paragraph after para 22 and before
para 23 (moving the exposition-only alias template out of para 24 and into its
own para so it can be used from elsewhere):]{.ednote}

::: add

> 23. Let _`valid-specialization`_ be the following alias template:
>
>     ```c++
>     template<template<class...> class T, class... Args>
>       concept @_`valid-specialization`_@ = requires { typename T<Args...>; }; // exposition only
>     ```

:::


[In [exec.snd.expos] para 23 add the mandate below, and in para 24, change the
definition of the exposition-only _`basic-sender`_ as follows:]{.ednote}

> ```c++
> template<class Tag, class Data = see below, class... Child>
> constexpr auto @_`make-sender`_@(Tag tag, Data&& data, Child&&... child);
> ```
> 
> 23. _Mandates_: The following expressions are `true`:
> 
>     - [23.1]{.pnum} `semiregular<Tag>`
> 
>     - [23.2]{.pnum} ```@_`movable-value`_@<Data>```
> 
>     - [23.3]{.pnum} `(sender<Child> &&...)`
> 
>     <div class="add">
> 
>     - [23.4]{.pnum} [`dependent_sender<Sndr> || sender_in<Sndr>`, where `Sndr`
>       is ```@_`basic-sender`_@<Tag, Data, Child...>``` as defined below.]{.add}
>
>       _Recommended practice:_ When this mandate fails because
>       `get_completion_signatures<Sndr>()` would exit with an exception,
>       implementations are encouraged to include information about the
>       exception in the resulting diagnostic.
> 
>     </div>
>
> 24. _Returns_: A prvalue of type
>     ```@_`basic-sender`_@<Tag, decay_t<Data>, decay_t<Child>...>``` that has
>     been direct-list-initialized with the forwarded arguments, where
>     _`basic-sender`_ is the following exposition-only class template except as
>     noted below.
>
>     ```{.cpp}
>     namespace std::execution {
>       template<class Tag>
>       concept @_`completion-tag`_@ = // exposition only
>         same_as<Tag, set_value_t> || same_as<Tag, set_error_t> || same_as<Tag, set_stopped_t>;
>
>       @[`template<template<class...> class T, class... Args>`]{.rm}@
>       @@[```concept @_`valid-specialization`_@ = requires { typename T<Args...>; }; // exposition only```]{.rm}@@
>
>       struct @_`default-impls`_@ {  // exposition only
>         static constexpr auto @_`get-attrs`_@ = @_`see below`_@;
>         static constexpr auto @_`get-env`_@ = @_`see below`_@;
>         static constexpr auto @_`get-state`_@ = @_`see below`_@;
>         static constexpr auto @_`start`_@ = @_`see below`_@;
>         static constexpr auto @_`complete`_@ = @_`see below`_@;
>
>         @[`template<class Sndr, class... Env>`]{.add}@
>         @@[```static constexpr void @_`check-types`_@();```]{.add}@@
>       };
>
>       @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
>
>       @[`template <class Sndr>`]{.add}@
>       @@[```using @_`data-type`_@ = decltype(declval<Sndr>().template @_`get`_@<1>());     // exposition only```]{.add}@@
>
>       template <class Sndr, size_t I = 0>
>       using @_`child-type`_@ = decltype(declval<Sndr>().template @_`get`_@<I+2>());     // exposition only
>
>       @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
>
>       @[`template<class Sndr, class... Env>`]{.rm}@
>       @@[```using @_`completion-signatures-for`_@ = @_`see below`_@; // exposition only```]{.rm}@@
>
>       template<class Tag, class Data, class... Child>
>       struct @_`basic-sender`_@ : @_`product-type`_@<Tag, Data, Child...> {  // exposition only
>         using sender_concept = sender_t;
>         using @_`indices-for`_@ = index_sequence_for<Child...>; // exposition only
>
>         decltype(auto) get_env() const noexcept {
>           auto& [_, data, ...child] = *this;
>           return @_`impls-for`_@<Tag>::@_`get-attrs`_@(data, child...);
>         }
>
>         template<@_`decays-to`_@<@_`basic-sender`_@> Self, receiver Rcvr>
>         auto connect(this Self&& self, Rcvr rcvr) noexcept(@_`see below`_@)
>           -> @_`basic-operation`_@<Self, Rcvr> {
>           return {std::forward<Self>(self), std::move(rcvr)};
>         }
>
>         template<@_`decays-to`_@<@_`basic-sender`_@> Self, class... Env>
>         @[`static consteval`]{.add}@ auto get_completion_signatures(@[`this Self&& self, Env&&... env`]{.rm}@) @[noexcept]{.rm}[`;`]{.add}@
>           @@[```-> @_`completion-signatures-for`_@<Self, Env...> {```]{.rm}@@
>           @[`return {};`]{.rm}@
>         @[`}`]{.rm}@
>       };
>     }
>     ```


[In [exec.snd.expos], replace para 39 with the paragraphs shown below and
renumber subsequent paragraphs:]{.ednote}

> ::: rm
>
> 39. Let `Sndr` be a (possibly `const`-qualified) specialization _`basic-sender`_
>     or an lvalue reference of such, let `Rcvr` be the type of a receiver with an
>     associated environment of type `Env`. If the type
>     ```@_`basic-operation`_@<Sndr, Rcvr>``` is well-formed, let `op` be an
>     lvalue subexpression of that type. Then
>     ```@_`completion-signatures-for`_@<Sndr, Env>``` denotes a specialization of
>     `completion_signatures`, the set of whose template arguments corresponds to
>     the set of completion operations that are potentially evaluated
>     ([basic.def.odr]) as a result of evaluating `op.start()`. Otherwise,
>     ```@_`completion-signatures-for`_@<Sndr, Env>``` is ill-formed. If
>     ```@_`completion-signatures-for`_@<Sndr, Env>``` is well-formed and its type
>     is not dependent upon the type `Env`,
>     ```@_`completion-signatures-for`_@<Sndr>```  is well-formed and denotes the
>     same type; otherwise, ```@_`completion-signatures-for`_@<Sndr>```  is
>     ill-formed.
>
> :::
>
> ::: add
>
> ```c++
> template <class Sndr, class... Env>
>   static constexpr void @_`default-impls`_@::@_`check-types`_@();
> ```
>
> 39. Let `FwdEnv` be the pack of types ```decltype(@_`FWD-ENV`_@(declval<Env>()))```,
>     and let `Is` be the pack of integral template arguments of the `integer_sequence`
>     specialization denoted by ```@_`indices-for`_@<Sndr>```.
>
> 40. _Effects_: Equivalent to:
>
>     ```c++
>     (@_`get-completion-signatures`_@<@_`child-type`_@<Sndr, Is>, FwdEnv...>(), ...)
>     ```
>
> ```c++
> template<class Tag, class Data, class... Child>
>   template <class Sndr, class... Env>
>     static consteval auto @_`basic-sender`_@<Tag, Data, Child...>::get_completion_signatures();
> ```
>
> 41. Let `Rcvr` be the type of a receiver whose environment has type `E`, where
>     `E` is the first type in the list ```Env..., @_unspecified_@```. Let `CS`
>     be a type determined as follows:
>
>     - [39.1]{.pnum} If the following expression is well-formed and a core
>       constant expression:
>
>       ```c++
>       @_`impls-for`_@<Tag>::template @_`check-types`_@<Sndr, Env...>()
>       ```
>
>       let `op` be an lvalue subexpression whose type is
>       `connect_result_t<Sndr, Rcvr>`. Then `CS` is the specialization of
>       `completion_signatures` the set of whose template arguments correspond
>       to the set of completion operations that are potentially evaluated
>       ([basic.def.odr]) as a result of evaluating `op.start()`.
>
>     - [39.2]{.pnum} Otherwise, `CS` is `completion_signatures<>`.
>
> 42. _Effects_: Equivalent to
>
>     ```c++
>     @_`impls-for`_@<Tag>::template @_`check-types`_@<Sndr, Env...>();
>     return CS();
>     ```
>
> 43. _Throws_: An exception of an unspecified type if the expression
>     ```@_`impls-for`_@<Tag>::template @_`check-types`_@<Sndr, Env...>()``` is
>     ill-formed.
>
> :::

[Change the specification of _`write-env`_ in [exec.snd.expos] para 40-43 as
follows (para numbers have changed because of prior edits):]{.ednote}

> ```c++
> template<sender Sndr, queryable Env>
>   constexpr auto @_`write-env`_@(Sndr&& sndr, Env&& env);         // exposition only
> ```
>
> 44. _`write-env`_ is an exposition-only sender adaptor that, when connected with
>     a receiver `rcvr`, connects the adapted sender with a receiver whose
>     execution environment is the result of joining the queryable argument `env`
>     to the result of `get_env(rcvr)`.
>
> 45. Let _`write-env-t`_ be an exposition-only empty class type.
>
> 46. _Returns_:
>
>     ```c++
>     @_`make-sender`_@(@_`write-env-t`_@(), std::forward<Env>(env), std::forward<Sndr>(sndr))
>     ```
>
> 47. _Remarks_: The exposition-only class template _`impls-for`_
>     ([exec.snd.general]) is specialized for _`write-env-t`_ as follows:
>
>     ```c++
>     template<>
>     struct @_`impls-for`_@<@_`write-env-t`_@> : @_`default-impls`_@ {
>       @@[```static constexpr auto @_`join-env`_@(const auto& state, const auto& env) noexcept {```]{.add}@@
>         @@[```return @_`see below`_@;```]{.add}@@
>       @[`}`]{.add}@
>
>       static constexpr auto @_`get-env`_@ =
>         [](auto, const auto& state, const auto& rcvr) noexcept {
>           return @@[```@_`see below`_@```]{.rm}[```@_`join-env`_@(state, get_env(rcvr))```]{.add}@@;
>         };
>
>       @[`template<class Sndr, class... Env>`]{.add}@
>       @@[```static constexpr void @_`check-types`_@();```]{.add}@@
>     };
>     ```
>
>     - [47.1]{.pnum} Invocation of
>       ```@_`impls-for`_@<@_`write-env-t`_@>​::@_[`​get-env`]{.rm}[`join-env`]{.add}_@```
>       returns an object `e` such that `decltype(e)` models `queryable` and
>       given a query object `q`, the expression `e.query(q)` is
>       expression-equivalent to `state.query(q)` if that expression is valid,
>       otherwise, `e.query(q)` is expression-equivalent to
>       ```@[`get_env(rcvr)`]{.rm}[`env`]{.add}@.query(q)```.
>
>     <div class="add">
>
>     - [47.2]{.pnum} [For type `Sndr` and pack `Env`, let `State` be
>       ```@_`data-type`_@<Sndr>``` and let `JoinEnv` be the pack
>       ```decltype(@_`join-env`_@(declval<State>(), declval<Env>()))```. Then
>       ```@_`impls-for`_@<@_`write-env-t`_@>​::@_`check-types`_@<Sndr, Env...>()``` is
>       expression-equivalent to
>       ```@_`get-completion-signatures`_@<@_`child-type`_@<Sndr>, JoinEnv...>()```.]{.add}
>
>     </div>

[Add the following new paragraphs to the end of [exec.snd.expos]]{.ednote}

> ::: add
>
> <ol start="48" type="1">
> <li>
> 
> ```c++
> template<class... Fns>
> struct @_`overload-set`_@ : Fns... {
>   using Fns::operator()...;
> };
> ```
> 
> </li>
> </ol>
>
> :::



[Change [exec.snd.concepts] para 1 as follows:]{.ednote}

> 1. The `sender` concept <span style="color:blue;font-style:italic">&hellip; as
>     before &hellip;</span> to produce an operation state.
>
>     ```{.cpp}
>     namespace std::execution {
>       @[`template<class Sigs>`]{.rm}@
>         @@[```concept @_`valid-completion-signatures`_@ = @_`see below`_@;            // exposition only```]{.rm}@@
>
>       @[`template<auto>`]{.add}@
>         @@[```concept @_`is-constant`_@ = true;```]{.add}@@                                 @[`// exposition only`{.cpp}]{.add}@
>
>       template<class Sndr>
>         concept @_`is-sender`_@ =                                         // exposition only
>           derived_from<typename Sndr::sender_concept, sender_t>;
>
>       template<class Sndr>
>         concept @_`enable-sender`_@ =                                     // exposition only
>           @_`is-sender`_@<Sndr> ||
>           @_`is-awaitable`_@<Sndr, @_`env-promise`_@<env<>>>;                   // [exec.awaitable]
>
>       @[`template<class Sndr>`]{.add}@
>         @@[```consteval bool @_`is-dependent-sender-helper`_@() try {```]{.add}@@           @[`// exposition only`{.cpp}]{.add}@
>           @[`get_completion_signatures<Sndr>();`]{.add}@
>           @[`return false;`]{.add}@
>         @@[```} catch (@_`dependent-sender-error`_@&) {```]{.add}@@
>           @[`return true;`]{.add}@
>         @[`}`]{.add}@
>
>       template<class Sndr>
>         concept sender =
>           bool(@_`enable-sender`_@<remove_cvref_t<Sndr>>) &&
>           requires (const remove_cvref_t<Sndr>& sndr) {
>             { get_env(sndr) } -> @_`queryable`_@;
>           } &&
>           move_constructible<remove_cvref_t<Sndr>> &&
>           constructible_from<remove_cvref_t<Sndr>, Sndr>;
>
>       template<class Sndr, class... Env>
>         concept sender_in =
>           sender<Sndr> &&
>           (queryable<Env> &&...) &&
>           @@[```@_`is-constant`_@<get_completion_signatures<Sndr, Env...>()>```]{.add}@@
>           @[`requires (Sndr&& sndr, Env&&... env) {`]{.rm}@
>             @[`{ get_completion_signatures(std::forward<Sndr>(sndr), std::forward<Env>(env)...) }`]{.rm}@
>               @@[```-> @_`valid-completion-signatures`_@;```]{.rm}@@
>           @[}]{.rm}@;
>
>       @[`template<class Sndr>`]{.add}@
>         @[`concept dependent_sender =`]{.add}@
>           @@[```sender<Sndr> && bool_constant<@_`is-dependent-sender-helper`_@<Sndr>()>::value;```]{.add}@@
>
>       template<class Sndr, class Rcvr>
>         concept sender_to =
>           sender_in<Sndr, env_of_t<Rcvr>> &&
>           receiver_of<Rcvr, completion_signatures_of_t<Sndr, env_of_t<Rcvr>>> &&
>           requires (Sndr&& sndr, Rcvr&& rcvr) {
>             connect(std::forward<Sndr>(sndr), std::forward<Rcvr>(rcvr));
>           };
>     }
>     ```

[Strike [exec.snd.concepts] para 3 (this para is moved to [execution.syn]):]{.ednote}

::: rm

> 3. [A type models the exposition-only concept _`valid-completion-signatures`_ if
>    it denotes a specialization of the `completion_signatures` class template.]{.rm}

:::


[Change [exec.getcomplsigs] as follows:]{.ednote}

> ::: rm
>
> 1. `get_completion_signatures` is a customization point object. Let sndr be an
>     expression such that `decltype((sndr))` is `Sndr`, and let `env` be a pack
>     of zero or one expression. If `sizeof...(env) == 0` is `true`, let
>     `new_sndr` be `sndr`; otherwise, let `new_sndr` be the expression
>     ```transform_sender(decltype(@_`get-domain-late`_@(sndr, env...)){}, sndr, env...)```.
>     Let `NewSndr` be `decltype((new_sndr))`. Then
>     `get_completion_signatures(sndr, env...)` is expression-equivalent to
>     `(void(sndr), void(env)..., CS())` except that `void(sndr)` and
>     `void(env)...` are indeterminately sequenced, where `CS` is:
>
>     - [1.1]{.pnum} `decltype(new_sndr.get_completion_signatures(env...))` if that
>       type is well-formed,
>
>     - [1.2]{.pnum} Otherwise, if `sizeof...(env) == 1` is `true`, then
>       `decltype(new_sndr.get_completion_signatures())` if that expression is
>       well-formed,
>
>     - [1.3]{.pnum} Otherwise, `remove_cvref_t<NewSndr>::completion_signatures`
>       if that type is well-formed,
>
>     - [1.4]{.pnum} Otherwise, if
>       ```@_`is-awaitable`_@<NewSndr, @_`env-promise`_@<decltype((env))>...>```
>       is `true`, then:
>
>       ```c++
>       completion_signatures<
>         @_`SET-VALUE-SIG`_@(await-result-type<NewSndr, env-promise<Env>>),        //  ([exec.snd.concepts])
>         set_error_t(exception_ptr),
>         set_stopped_t()>
>       ```
>
>     - [1.4]{.pnum} Otherwise, `CS` is ill-formed.
>
> :::


> ::: add
>
> ```c++
> template <class Sndr, class... Env>
>   consteval auto get_completion_signatures() -> @@```@_`valid-completion-signatures`_@ auto```@@;
> ```
>
> 1. Let `NewSndr` be `Sndr` if `sizeof...(Env) == 1` is `false`; otherwise,
>    `decltype(new_sndr)` where `new_sndr` is the following expression:
>
>     ```c++
>     transform_sender(
>       decltype(@_`get-domain-late`_@(declval<Sndr>(), declval<Env>()...)){},
>       declval<Sndr>(),
>       declval<Env>()...)
>     ```
>
> 2. _Requires_: `sizeof...(Env) <= 1` is `true`.
>
> 3. _Effects_: Given the following exposition-only entities:
>
>     ```c++
>     template<class Sndr, class... Env>
>       using @_`completion-signatures-result-t`_@ =                  // exposition only
>         decltype(remove_reference_t<Sndr>::template get_completion_signatures<Sndr, Env...>());
>
>     template<class Sndr, class... Env>
>       concept @_`dependent-sender-without-env`_@ =                  // exposition only
>         (sizeof...(Env) == 0) && !requires { typename @_`completion-signatures-result-t`_@<Sndr>; };
>
>     template<completion_signatures>
>       concept @_`has-constexpr-completions-helper`_@ = true;        // exposition only
>
>     template<class Sndr, class... Env>
>       concept @_`has-constexpr-completions`_@ =                     // exposition only
>         @_`has-constexpr-completions-helper`_@<
>           remove_reference_t<Sndr>::template get_completion_signatures<Sndr, Env...>()>;
>
>     template<class Sndr, class... Env>
>       constexpr auto @_`get-completion-signatures`_@() {
>         return @_`get-compl-sigs-expr`_@; // see below
>       }
>     ```
>
>     Equivalent to: `return @_get-completion-signatures_@<NewSndr, Env...>();`
>     where _`get-compl-sigs-expr`_ is expression-equivalent to the following:
>
>     - [3.1]{.pnum} `remove_reference_t<Sndr>::template get_completion_signatures<Sndr, Env...>()`
>       if ```@_`has-constexpr-completions`_@<Sndr, Env...>``` is `true`.
>
>     - [3.2]{.pnum} `remove_reference_t<Sndr>::template get_completion_signatures<Sndr>()`
>       if ```sizeof...(Env) == 1 && @_`has-constexpr-completions`_@<Sndr>``` is `true`.
>
>     - [3.3]{.pnum} Otherwise, `remove_cvref_t<NewSndr>::completion_signatures`
>       if that type is well-formed,
>
>     - [3.4]{.pnum} Otherwise, ```(throw @_`dependent-sender-error`_@(), completion_signatures())```
>       if ```@_`dependent-sender-without-env`_@<Sndr, Env...>``` is `true`.
>
>     - [3.5]{.pnum} Otherwise, ```(throw @_`unspecified`_@, completion_signatures())``` if
>       ```requires { typename @_`completion-signatures-result-t`_@<Sndr, Env...>; }``` is `false`.
>
>     - [3.6]{.pnum} Otherwise:
>
>         ```c++
>         (remove_reference_t<Sndr>::template get_completion_signatures<Sndr, Env>(),
>          throw @_`unspecified`_@,
>          completion_signatures())
>         ```
> :::
>
> 4. If [`get_completion_signatures(sndr)` is well-formed and its type denotes a
>    specialization of the `completion_signatures` class
>    template]{.rm}[```@_`has-constexpr-completions`_@<Sndr>``` is
>    `true`]{.add}, then `Sndr` is a non-dependent sender type ([async.ops]).
>
> 5. Given a type `Env`, if `completion_signatures_of_t<Sndr>` and
>    `completion_signatures_of_t<Sndr, Env>` are both well-formed, they shall
>    denote the same type.
>
> 6. Let `rcvr` be an rvalue whose type `Rcvr` models `receiver`, and let `Sndr` be the
>    type of a sender such that `sender_in<Sndr, env_of_t<Rcvr>>` is `true`. Let
>    `Sigs...` be the template arguments of the `completion_signatures`
>    specialization named by `completion_signatures_of_t<Sndr, env_of_t<Rcvr>>`.
>    Let `CSO` be a completion function. If sender `Sndr` or its operation state
>    cause the expression `CSO(rcvr, args...)` to be potentially evaluated
>    ([basic.def.odr]) then there shall be a signature `Sig` in `Sigs...` such that
>
>     > ```c++
>     > @_`MATCHING-SIG`_@(@_`decayed-typeof`_@<CSO>(decltype(args)...), Sig)
>     > ```
>
>     is `true` ([exec.general]).

[At the very bottom of [exec.connect], change the _Mandates_ of para 6 as follows:]{.ednote}

6. The expression `connect(sndr, rcvr)` is expression-equivalent to:

    - [6.1]{.pnum} `new_sndr.connect(rcvr)` if that expression is well-formed.

        _Mandates_: The type of the expression above satisfies `operation_state`.

    - [6.2]{.pnum} Otherwise, ```@_`connect-awaitable`_@(new_sndr, rcvr)```.

    _Mandates_: [`sender<Sndr> && receiver<Rcvr>` is `true`.]{.rm}[The following are all `true`:]{.add}

    <div class="add">

    - [6.3]{.pnum} `sender<Sndr>`,

    - [6.4]{.pnum} `receiver<Rcvr>`, and

    - [6.5]{.pnum} ```@_`has-constexpr-completions`_@<Sndr, env_of_t<Rcvr>>```.

    </div>



[In [exec.read.env] para 3, make the following change:]{.ednote}

> 3. The exposition-only class template _`impls-for`_
>     ([exec.snd.general]) is specialized for `read_env` as follows:
>
>     ```c++
>     namespace std::execution {
>       template<>
>       struct @_`impls-for`_@<@_`decayed-typeof`_@<read_env>> : @_`default-impls`_@ {
>         static constexpr auto @_`start`_@ =
>           [](auto query, auto& rcvr) noexcept -> void {
>             @_`TRY-SET-VALUE`_@(std::move(rcvr), query(get_env(rcvr)));
>           };
>
>         @[`template<class Sndr, class Env>`]{.add}@
>         @@[```static constexpr void @_`check-types`_@();```]{.add}@@
>       };
>     }
>     ```
>
>     <div class="add">
>
>     ```c++
>     template<class Sndr, class Env>
>     static constexpr void @_`check-types`_@();
>     ```
>
>     - [3.1]{.pnum} Let `Q` be ```decay_t<@_`data-type`_@<Sndr>>```.
>
>     - [3.2]{.pnum} _Throws_: An exception of an unspecified type if the
>       expression `Q()(env)` is ill-formed or has type `void`, where `env`
>       is an lvalue subexpression whose type is `Env`.
>
>     </div>

[Change [exec.shedule.from] para 4 and insert a new para between 6 and 7 as
follows:]{.ednote}

> 4. The exposition-only class template _`impls-for`_ ([exec.snd.general]) is
>     specialized for `schedule_from_t` as follows:
>
>     ```c++
>     namespace std::execution {
>       template<>
>       struct @_`impls-for`_@<schedule_from_t> : @_`default-impls`_@ {
>         static constexpr auto @_`get-attrs`_@ = @_`see below;`_@
>         static constexpr auto @_`get-state`_@ = @_`see below;`_@
>         static constexpr auto @_`complete`_@ = @_`see below;`_@
>
>         @[`template<class Sndr, class... Env>`]{.add}@
>         @@[```static constexpr void @_`check-types`_@();```]{.add}@@
>       };
>     }
>     ```
>
> 5. The member <span style="color:blue;font-style=italic">&hellip; as before &hellip;</span>
>
> 6. The member <span style="color:blue;font-style=italic">&hellip; as before &hellip;</span>
>
> ::: add
>
> ```c++
> template<class Sndr, class... Env>
> static constexpr void @_`check-types`_@();
> ```
>
> 7. _Effects_: Equivalent to:
>
>     ```c++
>     @_`get-completion-signatures`_@<schedule_result_t<@_`data-type`_@<Sndr>>>,
>                               decltype(@_`FWD-ENV`_@(declval<Env>()))...>();
>     @_`default-impls`_@::@_`check-types`_@<Sndr, Env...>();
>     ```
>
> :::
>
> 8. Objects of the local class _`state-type`_
>     <span style="color:blue;font-style=italic">&hellip; as before &hellip;</span>


[Change [exec.on] para 6 as follows:]{.ednote}

> 6. Otherwise: Let _`not-a-scheduler`_ be an unspecified empty class type, and
>     let _`not-a-sender`_ be the exposition-only type:
>
>     ```c++
>     struct @_`not-a-sender`_@ {
>       using sender_concept = sender_t;
>
>       @[`template<class Sndr>`]{.add}@
>       @[`static constexpr`]{.add}@ auto get_completion_signatures(@[`auto&&`]{.rm}@) @[`const`]{.rm}[`-> completion_signatures<>`]{.add}@ {
>         @@[```return @_see below_@;```]{.rm}@@
>         @@[```throw @_unspecified_@;```]{.add}@@
>       }
>     };
>     ```
>
>     [where the member function `get_completion_signatures` returns an object
>     of a type that is not a specialization of the `completion_signatures`
>     class template.]{.rm}

[Delete [exec.on] para 9 as follows:]{.ednote}

::: rm

> 9. [_Recommended practice_: Implementations should use the return type of
>     ```@_`not-a-sender​`_@::​get_completion_signatures``` to inform users that
>     their usage of on is incorrect because there is no available scheduler onto
>     which to restore execution.]{.rm}

:::

[Revert the change to [exec.then] made by P3164R3, and then change [exec.then]
para 4 as follows:]{.ednote}

> 4. The exposition-only class template *`impls-for`* ([exec.snd.general]) is
>     specialized for *`then-cpo`* as follows:
> 
>     ```c++
>     namespace std::execution {
>       template<>
>       struct @_`impls-for`_@<@_`decayed-typeof`_@<@_`then-cpo`_@>> : @_`default-impls`_@ {
>         static constexpr auto complete =
>           []<class Tag, class... Args>
>             (auto, auto& fn, auto& rcvr, Tag, Args&&... args) noexcept -> void {
>               if constexpr (same_as<Tag, @_`decayed-typeof`_@<@_`set-cpo`_@>>) {
>                 @_`TRY-SET-VALUE`_@(rcvr,
>                               invoke(std::move(fn), std::forward<Args>(args)...));
>               } else {
>                 Tag()(std::move(rcvr), std::forward<Args>(args)...);
>               }
>             };
>     
>         @[`template<class Sndr, class... Env>`]{.add}@
>         @@[```static constexpr void @_`check-types`_@();```]{.add}@@
>       };
>     }
>     ```

::: add

> <ol start="5" type="1"><li>
>
> ```c++
> template<class Sndr, class... Env>
> static constexpr void @_`check-types`_@();
> ```
> 
> - [5.1]{.pnum} _Effects:_ Equivalent to:
> 
>   ```c++
>   auto cs = get_completion_signatures<@_`child-type`_@<Sndr, 0>, Env...>();
>   auto fn = []<class... Ts>(set_value_t(*)(Ts...)) {
>     if constexpr (!invocable<remove_cvref_t<@_`data-type`_@<Sndr>>, Ts...>)
>       throw @_`unspecified`_@;
>   };
>   cs.@_`for-each`_@(@_`overload-set`_@{fn, [](auto){}});
>   ```
>
> </li></ol>

:::

[Revert the change to [exec.let] made by P3164R3, and then change [exec.let]
para 4 and insert a new para after 4 as follows:]{.ednote}

> 5. The exposition-only class template _`impls-for`_ ([exec.snd.general]) is
>     specialized for _`let-cpo`_ as follows:
> 
>     ```c++
>     namespace std::execution {
>       template<class State, class Rcvr, class... Args>
>       void @_`let-bind`_@(State& state, Rcvr& rcvr, Args&&... args);      // exposition only
> 
>       template<>
>       struct @_`impls-for`_@<@_`decayed-typeof`_@<@_`let-cpo`_@>> : @_`default-impls`_@ {
>         static constexpr auto @_`get-state`_@ = @_`see below`_@;
>         static constexpr auto @_`complete`_@ = @_`see below`_@;
> 
>         @[`template<class Sndr, class... Env>`]{.add}@
>         @@[```static constexpr void @_`check-types`_@();```]{.add}@@
>       };
>     }
>     ```

::: add

> <ol start="6" type="1"><li>
>
> ```c++
> template<class Sndr, class... Env>
> static constexpr void @_`check-types`_@();
> ```
> 
> - [6.1]{.pnum} _Effects:_ Equivalent to:
> 
>   ```c++
>   using LetFn = remove_cvref_t<@_`data-type`_@<Sndr>>;
>   auto cs = get_completion_signatures<@_`child-type`_@<Sndr>, Env...>();
>   auto fn = []<class... Ts>(@_`decayed-typeof`_@<@_`set-cpo`_@>(*)(Ts...)) {
>     if constexpr (!invocable<LetFn, Ts...>)
>       throw @_`unspecified`_@;
>     else if constexpr (!sender<invoke_result_t<LetFn, Ts...>>)
>       throw @_`unspecified`_@;
>   };
>   cs.@_`for-each`_@(@_`overload-set`_@(fn, [](auto){}));
>   ```
>
> </li></ol>

:::


[Revert the change to [exec.bulk] made by P3164R3, and then change [exec.bulk]
para 3 and insert a new para after 5 as follows:]{.ednote}

> 3. The exposition-only class template _`impls-for`_ ([exec.snd.general]) is
>     specialized for `bulk_t` as follows:
> 
>     ```c++
>     namespace std::execution {
>       template<>
>       struct @_`impls-for`_@<bulk_t> : @_`default-impls`_@ {
>         static constexpr auto @_`complete`_@ = @_`see below`_@;
> 
>         @[`template<class Sndr, class... Env>`]{.add}@
>         @@[```static constexpr void @_`check-types`_@();```]{.add}@@
>       };
>     }
>     ```
>
> 4. The member ```@_`impls-for`_@<bulk_t>::@_`complete`_@``` is
>     <span style="color:blue;font-style=italic">&hellip; as before &hellip;</span>
>
> 5. <span style="color:blue;font-style=italic">&hellip; as before &hellip;</span>

::: add

> <ol start="6" type="1"><li>
>
> ```c++
> template<class Sndr, class... Env>
> static constexpr void @_`check-types`_@();
> ```
> 
> - [6.1]{.pnum} _Effects:_ Equivalent to:
> 
>   ```c++
>   auto cs = get_completion_signatures<@_`child-type`_@<Sndr>, Env...>();
>   auto fn = []<class... Ts>(set_value_t(*)(Ts...)) {
>     if constexpr (!invocable<remove_cvref_t<@_`data-type`_@<Sndr>>, Ts...>)
>       throw @_`unspecified`_@;
>   };
>   cs.@_`for-each`_@(@_`overload-set`_@{fn, [](auto){}});
>   ```
>
> </li></ol>

:::


[Revert the change to [exec.split] made by P3164R3, and then change [exec.split]
para 3 and insert a new para after 3 as follows:]{.ednote}


> 3. The name `split` denotes a pipeable sender adaptor object. [For a subexpression
>     `sndr`, let `Sndr` be `decltype((sndr))`. If ```sender_in<Sndr,
>     @_`split-env`_@>``` is `false`, `split(sndr)` is ill-formed.]{.rm}

::: add

> 4. The exposition-only class template _`impls-for`_ ([exec.snd.general]) is
>     specialized for `split_t` as follows:
> 
>     ```c++
>     namespace std::execution {
>       template<>
>       struct @_`impls-for`_@<split_t> : @_`default-impls`_@ {
>         template<class Sndr>
>         static constexpr void @_`check-types`_@() {
>           @_`default-impls`_@::@_`check-types`_@<Sndr, @_`split-env`_@>();
>         }
>       };
>     }
>     ```

:::

[Change [exec.when.all] paras 2-4 and insert two new paras after 4 as
follows:]{.ednote}

> 2. The names `when_all` and `when_all_with_variant` denote customization point
>     objects. Let `sndrs` be a pack of subexpressions, let `Sndrs` be a pack of
>     the types `decltype((sndrs))...`, and let `CD` be the type
>     ```common_type_t<decltype(@_`get-domain-early`_@(sndrs))...>``` [, and let
>     `CD2` be `CD` if `CD` is well-formed, and `default_domain`
>     otherwise.]{.add}. The expressions `when_all(sndrs...)` and
>     `when_all_with_variant(sndrs...)` are ill-formed if any of the following
>     is true:
> 
> > - [2.1]{.pnum} `sizeof...(sndrs)` is `0`, or
> >
> > - [2.2]{.pnum} `(sender<Sndrs> && ...)` is `false`[, or]{.rm}[.]{.add}
> 
> ::: rm
> 
> > - [2.3]{.pnum} [`CD` is ill-formed.]{.rm}
> 
> :::
>
> 3. The expression `when_all(sndrs...)` is expression-equivalent to:
>
>     ```c++
>     transform_sender(@[`CD()`]{.rm}[`CD2()`]{.add}@, @_`make-sender`_@(when_all, {}, sndrs...))
>     ```
>
> 4. The exposition-only class template _`impls-for`_ ([exec.snd.general]) is
>    specialized for `when_all_t` as follows:
> 
>     ```c++
>     namespace std::execution {
>       template<>
>       struct @_`impls-for`_@<when_all_t> : @_`default-impls`_@ {
>         static constexpr auto @_`get-attrs`_@ = @_`see below`_@;
>         static constexpr auto @_`get-env`_@ = @_`see below`_@;
>         static constexpr auto @_`get-state`_@ = @_`see below`_@;
>         static constexpr auto @_`start`_@ = @_`see below`_@;
>         static constexpr auto @_`complete`_@ = @_`see below`_@;
>
>         @[`template<class Sndr, class... Env>`]{.add}@
>         @@[```static constexpr void @_`check-types`_@();```]{.add}@@
>       };
>     }
>     ```
> 
> ::: add
> 
> 5. Let `make-when-all-env` be the following exposition-only function template:
> 
>     ```c++
>     template<class Env>
>     constexpr auto @_`make-when-all-env`_@(inplace_stop_source& stop_src, Env&& env) noexcept {
>       return @_`see below`_@;
>     }
>     ```
> :::
>
> > 
> > <span style="color:blue;font-style:italic">The following itemized list has
> > been moved here unmodified from para 6.</span> Returns an object `e` such
> > that
> > 
> > - [5.1]{.pnum} `decltype(e)` models `queryable`, and
> > 
> > - [5.2]{.pnum} `e.query(get_stop_token)` is expression-equivalent to
> >   `stop_src.get_token()`, and
> > 
> > - [5.3]{.pnum} given a query object `q` with type other than _cv_
> >   `stop_token_t`, `e.query(q)` is expression-equivalent to `env.query(q)`.
> >
> > [Let _`when-all-env`_ be an alias template such that
> > ```@_`when-all-env`_@<Env>``` denotes the type
> >  ```decltype(@_`make-when-all-env`_@(declval<inplace_stop_source&>(), declval<Env>()))```.]{.add}

::: add

> <ol start="6" type="1"><li>
> 
> ```c++
> template<class Sndr, class... Env>
> static constexpr void @_`check-types`_@();
> ```
> 
> - [6.1]{.pnum} Let `Is` be the pack of integral template arguments
>   of the `integer_sequence` specialization denoted by
>   ```@_`indices-for`_@<Sndr>```.
>
> - [6.2]{.pnum} _Effects_: Equivalent to:
>
>   ```c++
>   auto fn = []<class Child>() {
>     auto cs = get_completion_signatures<Child, Env...>();
>     if constexpr (cs.template @_`count`_@<set_value_t> >= 2)
>       throw @_`unspecified`_@;
>   };
>   (fn.template operator()<@_`child-type`_@<Sndr, Is>>(), ...);
>   ```
> 
> - [6.3]{.pnum} _Throws_: Any exception thrown as a result of evaluating the
>     _Effects_, or an exception of an unspecified type when `CD` is ill-formed.

:::


[Change [exec.util.cmplsig] para 8 as follows:]{.ednote}


> <ol start="8" type="1"><li>
> 
> ```c++
> namespace std::execution {
>   template<@_`completion-signature`_@... Fns>
>     struct completion_signatures {
>       @@[```template<class Tag>```]{.add}@@
>       @@[```static constexpr size_t @_`count`_@ = @_`see below`_@;```]{.add}@@
>
>       @@[```template<class Fn>```]{.add}@@
>         @@[```static constexpr void @_`for-each`_@(Fn&& fn) { // exposition only```]{.add}@@
>           @@[```(std::forward<Fn>(fn)(static_cast<Fns*>(nullptr)), ...);```]{.add}@@
>         @@[```}```]{.add}@@
>     };
> 
>   @<span style="color:blue;text-style:italic">&hellip; as before &hellip;</span>@
> }
> ```
>
> </li></ol>

::: add

> 9. For a type `Tag`, `completion_signatures<Fns...>::count<Tag>` is
>    initialized with the count of function types in `Fns...` that are of the
>    form `Tag(Ts...)` where `Ts` is a pack of types.

:::




Acknowledgements
================

I would like to thank Hana Dusíková for her work making constexpr exceptions a
reality for C++26. Thanks are also due to David Sankel for his encouragement to
investigate using constexpr exceptions as an alternative to TMP hackery, and for
giving feedback on an early draft of this paper.

---
references:
  - id: P3164R3
    citation-label: P3164R3
    title: "Improving diagnostics for sender expressions"
    author:
      - family: Niebler
        given: Eric
    URL: https://wg21.link/p3164r3
---
