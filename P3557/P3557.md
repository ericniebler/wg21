---
title: "Rethinking Completion Signatures for C++26"
document: P3557R0
date: today
audience:
  - "LEWG Library Evolution"
author:
  - name: Eric Niebler
    email: <eric.niebler@gmail.com>
toc: true
---

<div style="text-align: right;">
_"Some witty quote."_<br/>
--- me
</div>

Introduction
============

The hardest part of writing a sender algorithm is often the computation of its
completion signatures, an intricate meta-programming task. Using sender
algorithms incorrectly leads to large, incomprehensible errors deep within the
completion-signatures meta-program. What is needed is a way to propagate type
errors automatically to the API boundary where they can be reported concisely,
much the way exceptions do for runtime errors.

Support for exceptions during constant-evaluation was recently accepted into the
Working Draft for C++26. We can take advantage of this powerful new feature to
easily propagate type errors during the computation of a sender's completion
signatures. This significantly improves the diagnostics users are likely to
encounter while also simplifying the job of writing new sender algorithms.

<!--
https://godbolt.org/z/haKxGhn86
-->

Executive Summary
=================

This paper proposes the following changes to the working draft:

* TODO.

Revision History
================

R0
----
* Initial revision

Discussion
==========

Motivation
----------

This paper exists principly to improve the experience of users who make type
errors in their sender expressions by leveraging exceptions during constant-
evaluation. It is a follow-on of [@P3164R2], which defines a category of
"non-dependent" senders that can and must be type-checked early.

Senders have a construction phase and a subsequent connection phase. Prior to
P3164, all type-checking of senders happened at the connection phase (when a
sender is connected to a receiver). P3164 mandates that the sender algorithms
type-check non-dependent senders, moving the diagnostic closer to the source of
the error.

This paper addresses the _quality_ of those diagnostics and the diagnostics
users encounter when a dependent sender fails type-checking at connection time.

Senders are expression trees, and type errors can happen deep within their
structure. If programmed naively, ill-formed senders would generate megabytes of
incomprehensible diagnostics. The challenge is to report type errors _concisely_
and _comprehensibly_, at the right level of abstraction.

Doing this requires propagating domain-specific descriptions of type errors out
of the completion signatures meta-program so they can be reported concisely.
Such error detection and propagation is very cumbersome in template
meta-programming.

The C++ solution to error propagation is exceptions. With the adoption of
[@P3068R6], C++26 has gained the ability to throw and catch exceptions during
constant-evaluation. If we express the computation of completion signatures as a
`constexpr` meta-program, we can use exceptions to propagate type errors. This
greatly improves diagnostics and even simplifies the code that computes
completion signatures.

This paper proposes changes to `std::execution` that make the computation
of a sender's completion signatures an evaluation of a `constexpr` function.
It also specifies the conditions under which the computation is to exit
with an exception.

Design Considerations
---------------------

### A consideration

TODO

Another Section
---------------


Proposed Design
===============

`get_completion_signatures`
---------------------------

In the Working Draft, a sender's completion signatures are determined by the
type of the expression `std::execution::get_completion_signatures(sndr, env)`
(or, after P3164, `std::execution::get_completion_signatures(sndr)` for
non-dependent senders). Only the type of the expression matters; the expression
itself is never evaluated. 

In the design proposed by this paper, the expression gets constant-evaluated. To
make it ammenable to constant evaluation, it must not accept arguments with
runtime values, so the expression is changed to
`std::execution::get_completion_signatures<Sndr [, Env]>()`, where
`get_completion_signatures` is a `consteval` function. If an unhandled exception
would propagate out of `get_completion_signatures` the program is ill-formed,
and the diagnostic displays the type and value of the exception.

`std::execution::get_completion_signatures<Sndr [, Env]>()` in turn calls
<code>remove_reference_t&lt;Sndr>::template get_completion_signatures&lt;Sndr [, Env]>()</code>,
which computes the completion signatures.

To better support the `constexpr` value-oriented programming style, _calls to
`get_completion_signatures` should never be ill-formed_. Given a pack `Env` with
zero or one types in it, when `sender<Sndr> && (queryable<Env> &&...)` is true,
the type `decltype(get_completion_signatures<Sndr, Env...>())` should always be
well-formed and should always name a specialization of
`completion_signatures`. `get_completion_signatures` reports errors by failing
to be a constant expression by throwing an unhandled exception.

Since `get_completion_signatures` is a `consteval` function, failing to be a
constant expression makes the program ill-formed.

`completion_signatures`
-----------------------

Computing completions signatures is now to be done using `constexpr`
meta-programming by manipulating values using ordinary imperative C++ rather
than template meta-programming. To better support this style of programming,
it is helpful to add `constexpr` operations that manipulate instances of
specializations of the `completion_signatures` class template.

For example, it should be possible to take the union of two sets of completion
signatures. `operator+` seems like a natural choice:

> ```cpp
> completion_signatures<set_value_t(int), set_error_t(exception_ptr)> cs1;
> completion_signatures<set_stopped_t(), set_error_t(exception_ptr)> cs2;
> 
> auto cs3 = cs1 + cs2; // completion_signatures<set_value_t(int),
>                       //                       set_error_t(exception_ptr),
>                       //                       set_stopped_t()>
> ```

It can also be convenient for `completion_signature` specializations to model
[_`tuple-like`_](https://en.cppreference.com/w/cpp/utility/tuple/tuple-like).
Although tuple elements cannot have funtion type, they can have function
_pointer_ type. With this proposal, an object like
`completion_signatures<set_value_t(int), set_stopped_t()>{}` behaves like
`tuple<set_value_t(*)(int), set_stopped_t(*)()>{nullptr, nullptr}` (except that
it wouldn't actually have to store the `nullptr`s). That would make it possible
to manipulate completion signatures using `std::apply`:

> ```cpp
> auto cs = /*...*/;
>
> // Add an lvalue reference to all arguments of all signatures:
> auto add_ref =     []<class T, class... As>(T(*)(As...)) -> T(*)(As&...) { return {}; };
> auto add_ref_all = [=](auto... sigs) { return make_completion_signatures(add_ref(sigs)...); };
>
> return std::apply(add_ref_all, cs);
> ```

The code above uses another new feature: a `make_completion_signatures` helper
function that deduces the signatures from the arguments, removes any duplicates,
and returns a new instance of `completion_signatures`.

Consider trying to do all the above using template meta-programming. &#x1F62C;

`transform_completion_signatures`
---------------------------------

The current Working Draft has a utility to make type transformations of
completion signature sets simpler: the alias template
`transform_completion_signatures`. It looks like this:

> ```cpp
> template <class... As>
> using @_value-transform-default_@ = completion_signatures<set_value_t(As...)>;
>
> template <class Error>
> using @_error-transform-default_@ = completion_signatures<set_error_t(Error)>;
>
> template <@_valid-completion-signatures_@ Completions,
>           @_valid-completion-signatures_@ OtherCompletions = completion_signatures<>,
>           template <class...> class ValueTransform = @_value-transform-default_@,
>           template <class> class ErrorTransform = @_error-transform-default_@,
>           @_valid-completion-signatures_@ StoppedCompletions = completion_signatures<set_stopped_t()>>
> using transform_completion_signatures = /*see below*/;
> ```

Anything that can be done with `transform_completion_signatures` can be done in
`constexpr` using `std::apply`, a lambda with `if constexpr`, and `operator+` of
`completion_signature` objects. In fact, we could even implement
`transform_completion_signatures` that way:

> ```cpp
> template </* ... as before... */>
> using transform_completion_signatures =
>   std::constant_wrapper< // see @@[@P2781R5]@@
>     std::apply(
>       [](auto... sigs) {
>         return ([]<class T, class... As>(T (*)(As...)) {
>           if constexpr (^^T == ^^set_value_t) { // use reflection to test type equality
>             return ValueTransform<As...>();
>           } else if constexpr (^^T == ^^set_error_t) {
>             return ErrorTransform<As...[0]>();
>           } else {
>             return StoppedCompletions();
>           }
>         }(sigs) +...+ completion_signatures());
>       },
>       Completions()
>     ) + OtherCompletions()
>   >::value_type;
> ```

We could consider dropping `transform_completion_signatures` completely,
simplifying the proposal.

Should we decide to keep the functionality of `transform_completion_signatures`,
we can recast it into a `constexpr` function that accepts transforms as lambdas:

> ```cpp
> constexpr auto @_value-transform-default_@ = []<class... As>() { return completion_signatures<set_value_t(As...)>(); };
> constexpr auto @_error-transform-default_@ = []<class Error>() { return completion_signatures<set_error_t(Error)>(); };
> 
> template <@_valid-completion-signatures_@ Completions,
>           class ValueTransform = decltype(@_value-transform-default_@),
>           class ErrorTransform = decltype(@_error-transform-default_@),
>           @_valid-completion-signatures_@ StoppedCompletions = completion_signatures<set_stopped_t()>,
>           @_valid-completion-signatures_@ OtherCompletions = completion_signatures<>>
> consteval auto transform_completion_signatures(Completions completions,
>                                                ValueTransform value_transform = {},
>                                                ErrorTransform error_transform = {},
>                                                StoppedCompletions stopped_completions = {},
>                                                OtherCompletions other_completions = {})
>   -> @_valid-completion-signatures_@ auto;
> ```

The above form of `transform_completion_signatures` is more natural to use from
within a `constexpr` function. It also makes it simple to accept the default for
some arguments as shown below:

> ```cpp
> // Transform just the error completion signatures:
> auto cs2 = transform_completion_signatures(cs, {}, []<class E>() { return /*...*/; });
>                                            //  ^^  Accept the default value transform
> ```

Since accepting the default transforms is simple, we are able to move the
infrequently used `OtherCompletions` argument to the end of the argument list.

Like `get_completion_signatures`, `transform_completion_signatures` always
returns a specialization of `completion_signatures` and reports errors by
throwing exceptions. It expects the lambdas passed to it to do likewise.

`sender_in`
-----------

With the above changes, we need to tweak the `sender_in` concept to require
that `get_completion_signatures<Sndr, Env...>()` is a constant expression.

The changes to `sender_in` relative to [@P3164R3] are as follows:

> ```cpp
> @[`template <auto>`]{.add}@
>   @@[`concept @_is-constant_@ = true; @_// exposition only_@`]{.add}@@
> 
> template<class Sndr, class... Env>
>   concept sender_in =
>     sender<Sndr> &&
>     (sizeof...(Env) <= 1)
>     (queryable<Env> &&...) &&
>     @@[`@_is-constant_@<get_completion_signatures<Sndr, Env...>()> &&`]{.add}@@
>     requires @[`(Sndr&& sndr, Env&&... env)`]{.rm}@ {
>       { get_completion_signatures@[`<Sndr, Env...>`]{.add}@(@[`std::forward<Sndr>(sndr), std::forward<Env>(env)...`]{.rm}@) }
>         -> @_valid-completion-signatures_@;
>     };
> ```

`invalid_completion_signature`
------------------------------

The reason for the design change is to permit the reporting of type errors using
exceptions. Let's look at an example where it would be desirable to throw an
exception from `get_completion_signatures`: the `then` algorithm. We will use
this example to motivate the rest of the design changes.

The `then` algorithm attaches a continuation to an async operation that executes
when the operation completes successfully. With this proposal, a `then_sender`
might be implemented (in part) as follows:

> ```cpp
> template <class Sndr, class Fun>
> struct then_sender {
>   using sender_concept = sender_t;
> 
>   template <class Self, class... Env>
>   static constexpr auto get_completion_signatures() {
>     // compute the completions of the (properly cv-qualified) child:
>     using Child = decltype(std::forward_like<Self>(declval<Sndr&>()));
>     auto child_completions = get_completion_signatures<Child, Env...>();
> 
>     // This lambda is used to transform value completion signatures:
>     auto value_transform = []<class... As>() {
>       if constexpr (std::invocable<Fun, As...>) {
>         using Result = std::invoke_result_t<Fun, As...>;
>         return completion_signatures<set_value_t(Result)>();
>       } else {
>         // Oh no, the user made an error! Tell them about it.
>         throw @_`some-exception-object`_@;
>       }
>     };
>
>     // Transform just the value completions:
>     return transform_completion_signatures(child_completions, value_transform);
>   }
>
>   @_<span style="color:blue">...`other implementation details here`...</span>_@
> };
> ```

Lambdas passed to `transform_completion_signatures` should always return a
`completion_signatures` specialization. When the `else` branch of the `constexpr
if` is taken, the return type of the lambda is `void`. It will never actually
_return_ `void` since it doesn't return at all in that case, but in C++ all
expressions must have a type, even `throw` expressions.

We can tidy this up by changing `throw ...;`{.cpp} to the following:

> ```cpp
> return std::execution::invalid_completion_signature();
> ```

That expression has type `completion_signatures<>` but exits with an exception.
The `invalid_completion_signature` function is defined as follows:

> ```cpp
> template <class... What, class... Args>
> struct @_sender-type-check-failure_@ : std::exception { @_`// exposition only`{.cpp}_@
>   constexpr @_sender-type-check-failure_@(Args... args) : @*args_*@{std::move(args)...} {}
>   constexpr char const* what() const noexcept override { return @_unspecified_@; };
>   std::tuple<Args...> @*args_*@; @_`// exposition only`{.cpp}_@
> };
> 
> template <class... What, class... Args>
> [[noreturn]] consteval completion_signatures<> invalid_completion_signature(Args... args) {
>   throw @_sender-type-check-failure_@<What..., Args...>{std::move(args)...};
> }
> ```

The template parameters and arguments can be used to communicate domain-specific
information about the nature of the failure. For instance, in the example above,
we might do the following:

> ```cpp
> return std::execution::invalid_completion_signature<
>   struct IN_THE_THEN_ALGORITHM,
>   struct THE_SPECIFIED_FUNCTION_IS_NOT_CALLABLE_WITH_THE_VALUES_SENT_BY_THE_PREDECESSOR,
>   struct WITH_FUNCTION(Fun),
>   struct WITH_ARGUMENTS(As...)>();
> ```

`get_child_completion_signatures`
---------------------------------

In the `then_sender` above, computing a child sender's completion signatures is a little awkward:

> ```cpp
> // compute the completions of the (properly cv-qualified) child:
> using Child = decltype(std::forward_like<Self>(declval<Sndr&>()));
> auto child_completions = get_completion_signatures<Child, Env...>();
> ```

Computing the completions of child senders will need to be done by every sender
adaptor algorithm. We can make this simpler with a
`get_child_completion_signatures` helper function:

> ```cpp
> // compute the completions of the (properly cv-qualified) child:
> auto child_completions = get_child_completion_signatures<Self, Sndr, Env...>();
> ```

... where `get_child_completion_signatures` is defined as follows:

```cpp
template <class Parent, class Child, class... Env>
consteval auto get_child_completion_signatures() {
  using @_cvref-child-type_@ = decltype(std::forward_like<Parent>(declval<Child&>()));
  return get_completion_signatures<@_cvref-child-type_@, Env...>();
}
```




Questions for LEWG
==================

1. Should we drop `transform_completion_signatures` (see discussion here TODO LINK)?


Implementation Experience
=========================

TODO

The design proposed below has been prototyped and can be found
on [Compiler Explorer](https://godbolt.org/z/976b1G45a)[^1].

[^1]: [https://godbolt.org/z/976b1G45a](https://godbolt.org/z/976b1G45a)

Proposed Wording
================

[Change [exec.syn] as follows:]{.ednote}

> <b>Header `<execution>` synopsis [exec.syn]</b>
>
> ```
> namespace std::execution {
>   @<span style="color:blue;font-style:italic">...as before...</span>@
> }
> ```

Acknowledgements
================

I would like to thank Hana Dusíková for her work making constexpr exceptions a
reality for C++26. Thanks also to LEWG for the nudge to investigate using
constexpr exceptions as an alternative to TMP hackery.

---
references:
  - id: P3164R3
    citation-label: P3164R3
    title: "Improving diagnostics for sender expressions"
    author:
      - family: Niebler
        given: Eric
    URL: https://wg21.link/P3164R3
---