---
title: "High-Quality Sender Diagnostics with Constexpr Exceptions"
document: D3557R0
date: today
audience:
  - "LEWG Library Evolution"
author:
  - name: Eric Niebler
    email: <eric.niebler@gmail.com>
toc: true
---

<div style="text-align: right;">
_"Only the exceptional paths bring exceptional glories!"_<br/>
--- Mehmet Murat Ildan
</div>

Introduction
============

The hardest part of writing a sender algorithm is often the computation of its
completion signatures, an intricate meta-programming task. Using sender
algorithms incorrectly leads to large, incomprehensible errors deep within the
completion-signatures meta-program. What is needed is a way to propagate type
errors automatically to the API boundary where they can be reported concisely,
much the way exceptions do for runtime errors.

Support for exceptions during constant-evaluation was recently accepted into the
Working Draft for C++26. We can take advantage of this powerful new feature to
easily propagate type errors during the computation of a sender's completion
signatures. This significantly improves the diagnostics users are likely to
encounter while also simplifying the job of writing new sender algorithms.

<!--
https://godbolt.org/z/haKxGhn86
-->

Executive Summary
=================

This paper proposes the following changes to the working draft with the
addition of [@P3164R3]. Subsequent sections will address the motivation
and the designs in detail.

1. Change `std::execution::get_completion_signatures` from a customization
  point object that accepts a sender and (optionally) an environment to
  a `consteval` function template that takes no arguments, as follows:

::: cmptable

### Before
```cpp
inline constexpr struct get_completion_signatures_t {
  template <class Sndr, class... Env>
  auto operator()(Sndr&&, Env&&...) const -> @_`see below`_@;
} get_completion_signatures {};
```

### After
```cpp
template <class Sndr, class... Env>
consteval auto get_completion_signatures()
  -> @_`valid-completion-signatures`_@ auto;
```

:::

2. Change the mechanism by which senders customize `get_completion_signatures`
  from a member function that accepts the _cv_-qualified sender object and an
  optional environment object to a `static constexpr` function template that
  take the sender and environment types as template parameters.

::: cmptable

### Before
```cpp
struct my_sender {
  template <class Self, class... Env>
    requires @_`some-predicate`_@<Self, Env...>
  auto get_completion_signatures(this Self&&, Env&&) {
    return completion_signatures</*...*/>();
  }
  ...
};
```

### After
```cpp
struct my_sender {
  template <class Self, class... Env>
  static constexpr auto get_completion_signatures() {
    if constexpr (!@_`some-predicate`_@<Self, Env...>) {
      throw @_`a-helpful-diagnostic`_@(); // <--- LOOK!
    }
    return completion_signatures</*...*/>();
  }
  ...
};
```

:::

3. Change the `sender_in<Sender, Env...>` concept to test that
  `get_completion_signatures<Sndr, Env...>()` is a constant expression.

::: cmptable

### Before
```cpp
template<class Sndr, class... Env>
concept sender_in =
  sender<Sndr> &&
  (queryable<Env> &&...) &&
  requires (Sndr&& sndr, Env&&... env) {
    { get_completion_signatures(
        std::forward<Sndr>(sndr),
        std::forward<Env>(env)...) }
            -> @_`valid-completion-signatures`_@;
  };
```

### After
```cpp
template <auto>
concept @_`is-constant`_@ = true; @_`// exposition only`{.cpp}_@

template<class Sndr, class... Env>
concept sender_in =
  sender<Sndr> &&
  (queryable<Env> &&...) &&
  @_`is-constant`_@<get_completion_signatures<Sndr, Env...>()>;
```

:::

4. In the exposition-only _`basic-sender`_ class template, specify under what
  conditions its `get_completion_signatures` static member function is
  ill-formed when called without an `Env` template parameter (see proposed
  wording for details).

5. Add a `dependent_sender` concept that is modeled by sender types that
  must have an environment before they know how they complete.

6. \[Optional]: Remove the `transform_completion_signatures` alias template.

The following additions are suggested by this paper to make working with
completion signatures in `constexpr` code easier. None of these additions is
strictly necessary.

* Extend the [`completion_signatures`](#completion_signatures) class template
  with `constexpr` operations that make the manipulation of completion
  signatures more ergonomic. These extensions are:

  - Combining two sets of completion signatures with `operator+`.

  - Treating an instance of a completion signatures specialization as a tuple
    of function pointers. For example, `completion_signatures<set_value_t(int), set_stopped_t()>{}`
    would be usable as if it were `tuple<set_value_t(*)(), set_stopped_t(*)()>{nullptr, nullptr}`,
    which makes `std::apply` useful for munging completion signatures.

  - Adding CTAD to deduce the signature types from a list of function pointers.
    Together with the above item, the following is the identity transform, given
    a `completion_signatures` object `cs`:

    > ```cpp
    > auto cs2 = std::apply([](auto... sigs){ return completion_signatures{sigs...}; }, cs);
    > static_assert(^^decltype(cs) == ^^decltype(cs2));
    > ```

* Add a [`make_completion_signatures`](#make_completion_signatures) helper
  function that takes signatures as template arguments or as function arguments
  or both. The returned value would have signatures that have been normalized,
  sorted ([@P2830R7]), and made unique.


* Add a [`get_child_completion_signatures`](#get_child_completion_signatures)
  function template that makes it easy for a sender adaptor to get the completion
  signatures of the child sender with the proper _cv_ qualification. It is
  simply:

  > ```cpp
  > template <class Parent, class Child, class... Env>
  > consteval auto get_child_completion_signatures() {
  >   using CvChild = decltype(std::forward_like<Parent>(declval<Child&>()));
  >   return get_completion_signatures<CvChild, Env...>();
  > }
  > ```

* Reintroduce
  [`transform_completion_signatures`](#transform_completion_signatures) as a
  `constexpr` function template that accepts lambdas as transforms. For example,
  the following code removes all error completions from a set, `cs`:

  > ```cpp
  > auto cs2 = transform_completion_signatures(
  >   cs,
  >   {}, // accept the default value completion transform
  >   []<class Error>() { return completion_signatures{}; });
  > ```

  See [transform_completion_signatures](#transform_completion_signatures) for a
  full design description of the `transform_completion_signatures` function
  template.

* Add an [`invalid_completion_signature`](#invalid_completion_signature)
  `consteval` function template whose return type is `completion_signatures<>`
  but that throws an unspecified exception type that contains diagnostic
  information. A typical use would look like this:

  > ```cpp
  > template <class Q>
  > template <class Self, class Env>
  > static constexpr auto read_env_sender<Q>::get_completion_signatures() {
  >   if constexpr (!invocable<Q, Env>) {
  >     // return type deduced to be completion_signatures<> but function exits
  >     // with an exception that contains the relevant diagnostic information.
  >     return invalid_completion_signature<
  >        IN_ALGORITHM<read_env>,
  >        struct WITH_QUERY(Q),
  >        struct WITH_ENVIRONMENT(Env)
  >     >("The environment does not provide a value for the given query type.");
  >   } else {
  >     using Result = invoke_result_t<Q, Env>;
  >     return completion_signatures<set_value_t(Result)>();
  >   }
  > }
  > ```

Revision History
================

R0
----
* Initial revision

Motivation
==========

This paper exists principly to improve the experience of users who make type
errors in their sender expressions by leveraging exceptions during constant-
evaluation. It is a follow-on of [@P3164R2], which defines a category of
"non-dependent" senders that can and must be type-checked early.

Senders have a construction phase and a subsequent connection phase. Prior to
P3164, all type-checking of senders happened at the connection phase (when a
sender is connected to a receiver). P3164 mandates that the sender algorithms
type-check non-dependent senders, moving the diagnostic closer to the source of
the error.

This paper addresses the _quality_ of those diagnostics and the diagnostics
users encounter when a dependent sender fails type-checking at connection time.

Senders are expression trees, and type errors can happen deep within their
structure. If programmed naively, ill-formed senders would generate megabytes of
incomprehensible diagnostics. The challenge is to report type errors _concisely_
and _comprehensibly_, at the right level of abstraction.

Doing this requires propagating domain-specific descriptions of type errors out
of the completion signatures meta-program so they can be reported concisely.
Such error detection and propagation is very cumbersome in template
meta-programming.

The C++ solution to error propagation is exceptions. With the adoption of
[@P3068R6], C++26 has gained the ability to throw and catch exceptions during
constant-evaluation. If we express the computation of completion signatures as a
`constexpr` meta-program, we can use exceptions to propagate type errors. This
greatly improves diagnostics and even simplifies the code that computes
completion signatures.

This paper proposes changes to `std::execution` that make the computation
of a sender's completion signatures an evaluation of a `constexpr` function.
It also specifies the conditions under which the computation is to exit
with an exception.

Proposed Design, Necessary Changes
==================================

`get_completion_signatures`
---------------------------

In the Working Draft, a sender's completion signatures are determined by the
type of the expression `std::execution::get_completion_signatures(sndr, env)`
(or, after P3164, `std::execution::get_completion_signatures(sndr)` for
non-dependent senders). Only the type of the expression matters; the expression
itself is never evaluated. 

In the design proposed by this paper, the `get_completion_signatures` expression
must be constant-evaluated in order use exceptions to report errors. To
make it ammenable to constant evaluation, it must not accept arguments with
runtime values, so the expression is changed to
`std::execution::get_completion_signatures<Sndr, Env...>()`, where
`get_completion_signatures` is a `consteval` function.

If an unhandled exception propagates out of `get_completion_signatures` the
program is ill-formed (because `get_completion_signatures` is `consteval`). The
diagnostic displays the type and value of the exception.

`std::execution::get_completion_signatures<Sndr, Env...>()` in turn calls
<code>remove_reference_t&lt;Sndr>::template get_completion_signatures&lt;Sndr,
Env\...>()</code>, which computes the completion signatures or throws as
appropriate, as shown below:

> ```cpp
> namespace ex = std::execution;
> 
> struct void_sender {
>   using sender_concept = ex::sender_t;
> 
>   template <class Self, class... Env>
>   static constexpr auto get_completion_signatures() {
>     return ex::completion_signatures<ex::set_value_t()>();
>   }
>   @<span style="color:blue">...`more`...</span>@
> };
> ```

To better support the `constexpr` value-oriented programming style, calls to
`get_completion_signatures` from a `constexpr` function are never ill-formed,
and they always have a `completion_signatures` type. `get_completion_signatures`
reports errors by failing to be a constant expression.

### Non-non-dependent senders

[@P3164R3] introduces the concept of non-dependent senders: senders that have
the same completion signatures regardless of the receiver's execution
environment. For a sender type `DependentSndr` whose completions _do_ depend on
the environment, what should happen when the sender's completions are queried
without an environment? That is, what should the semantics be for
`get_completion_signatures<DependentSndr>()`?

`get_completion_signatures<DependentSndr>()` should follow the general rule: it
should be well-formed in a `constexpr` function, and it should have a
`completion_signatures` type. That way, sender adaptors do not need to do
anything special when computing the completions of child senders that are
dependent. So `get_completion_signatures<DependentSndr>()` should throw.

If `get_completion_signatures<Sndr>()` throws for dependent senders, and it also
throws for non-dependent senders that fail to type-check, how then do we
distinguish between valid dependent and invalid non-dependent senders? We can
distinguish by checking the type of the exception.

An example will help. Consider the `read_env(q)` sender, a dependent sender that
sends the result of calling `q` with the receiver's environment. It cannot
compute its completion signatures without an environment. The natural way for
the `read_env` sender to express that is to require an `Env` parameter to its
customization of `get_completion_signatures`:

> ```cpp
> namespace ex = std::execution;
> 
> template <class Query>
> struct read_env_sender {
>   using sender_concept = ex::sender_t;
> 
>   template <class Self, class Env> // NOTE: Env is not optional!
>   static constexpr auto get_completion_signatures() {
>     if constexpr (!std::invocable<Query, Env>) {
>       throw @_`exception-type-goes-here`_@();
>     } else {
>       using Result = std::invoke_result_t<Query, Env>;
>       return ex::completion_signatures<ex::set_value_t(Result)>();
>     }
>   }
>   @<span style="color:blue">...`more`...</span>@
> };
> ```

That makes `read_env_sender<Q>::get_completion_signatures<Sndr>()` an ill-formed
expression, which the `get_completion_signatures` function can detect. In such
cases, it would throw an exception of a special type that it can catch later
when distinguishing between dependent and non-dependent senders.

### Implementation

Since the design has several parts, reading the implementation of
`get_completion_signatures` is probably the easiest way to understand it. The
implementation is shown below with comments describing the parts.

> ```cpp
> // Some exposition-only helpers:
> template <template <class...> class C, class... Ts>
> using @_`well-formed-type`_@ =  @_`// exposition only`{.cpp}_@
>   requires { typename C<Ts...>; };
> 
> template <class Sndr, class... Env>
> using @_`completion-signatures-of`_@ =  @_`// exposition only`{.cpp}_@
>   decltype(remove_reference_t<Sndr>::template get_completion_signatures<Sndr, Env...>());
> 
> // A sender is dependent when its get_completion_signatures customization
> // cannot be called without an environment parameter.
> template <class Sndr, class... Env>
> concept @_`dependent-sender-without-env`_@ =  @_`// exposition only`{.cpp}_@
>   (sizeof...(Env) == 0) &&
>   !@_`well-formed-type`_@<@_`completion-signatures-of`_@, Sndr>;
> 
> template <completion_signatures>
> concept @_`has-constexpr-completions-helper`_@ = true; @_`// exposition only`{.cpp}_@
> 
> // A concept that tests that a sender's customization of get_completion_signatures
> // is well-formed, a constant expression, and has a type that is a specialization
> // of completion_signatures<>.
> template <class Sndr, class... Env>
> concept @_`has-constexpr-completions`_@ =   @_`// exposition only`{.cpp}_@
>   @_`has-constexpr-completions-helper`_@<
>     remove_reference_t<Sndr>::template get_completion_signatures<Sndr, Env...>()>;
> 
> // This is a special exception type that will be thrown by
> // std::execution::get_completion_signatures when trying to query a dependent
> // sender for its non-dependent completions.
> struct @_`dependent-sender-error`_@ { };  @_`// exposition only`{.cpp}_@ 
> 
> // Given a sender and zero or one environment, compute the sender's completion
> // signatures. Calls to this function are always well-formed and have a type
> // that is a specialization of completion_signatures.
> template <class Sndr, class... Env>
> constexpr auto @_`get-completion-signatures-impl`_@() {
>   using @_`sndr-type`_@ = remove_reference_t<Sndr>;
> 
>   if constexpr (@_`has-constexpr-completions`_@<Sndr, Env>) {
>     // In the happy case where Sndr's customization is well-formed, a constant
>     // expression, and has a completion_signatures<> type, just return the
>     // result of calling the customization.
>     return @_`sndr-type`_@::template get_completion_signatures<Sndr, Env...>();
>   }
>   else if constexpr (@_`dependent-sender-without-env`_@<Sndr, Env...>) {
>     // If Sndr is dependent and we don't have an environment, throw an exception,
>     // but ensure that the return type of this function is a specialization
>     // of completion_signatures.
>     return (throw @_`dependent-sender-error`_@(), completion_signatures());
>   }
>   else if constexpr (!@_`well-formed-type`_@<@_`completion-signatures-of`_@, Sndr, Env...>>) {
>     // For some reason, the Sndr's customization cannot be called even with an
>     // environment. This is a library bug; it should always be callable from
>     // a constexpr context. Report the library bug by throwing an exception,
>     // taking care to ensure the return type is a completion_signatures type.
>     return (throw @_`unspecified`_@, completion_signatures());
>   }
>   else {
>     // Otherwise, we reach here under the following conditions:
>     // - The call to Sndr's customization cannot be constant-evaluated (possibly
>     //   because it throws), or
>     // - Its return type is not a completion_signatures type.
>     //
>     // We want to call the call the Sndr's customization so that if it throws
>     // an exception, that exception's information will appear in the diagnostic.
>     // If it doesn't throw, _we_ should throw to let the developer know that
>     // their customization returned an invalid type. And again, ensure that
>     // the return type is a completion_signatures type.
>     return (@_`sndr-type`_@::template get_completion_signatures<Sndr, Env...>(),
>             throw @_`unspecified`_@,
>             completion_signatures());
>   }
> }
> 
> // Applies a late sender transformation if appropriate, then computes the
> // completion signatures. Calls to this function are always well-formed and
> // have a type that is a specialization of completion_signatures.
> template <class Sndr, class... Env>
> consteval auto get_completion_signatures() {
>   if constexpr (sizeof...(Env) == 0) {
>     return @_`get-completion-signatures-impl`_@<Sndr>();
>   }
>   else {
>     // Apply a late sender transform:
>     using NewSndr = decltype(transform_sender(/*...*/));
>     return @_`get-completion-signatures-impl`_@<NewSndr, Env...>();
>   }
> }
> ```

Given this definition of `get_completion_signatures`, we can implement
a `dependent_sender` concept as follows:

> ```cpp
> // Returns true when get_completion_signatures<Sndr>() throws a
> // dependent-sender-error. Returns false when
> // get_completion_signatures<Sndr>() returns normally (Sndr is non-dependent),
> // or when it throws any other kind of exception (Sndr fails type-checking).
> template <class Sndr>
> consteval bool @_`is-dependent-sender-helper`_@() {
>   try {
>     get_completion_signatures<Sndr>();
>   } catch (@_`dependent-sender-error`_@&) {
>     return true;
>   }
>   return false;
> }
> 
> template <class Sndr>
> concept dependent_sender =
>   sender<Sndr> && std::bool_constant<@_`is-dependent-sender-helper`_@<Sndr>()>::value;
> ```

After the adoption of [@P3164R3], the sender algorithms are all required to
return senders that are either dependent or else that type-check successfully.
One way to implement this is with the following helper:

> ```cpp
> template <class Sndr>
> constexpr auto __type_check_sender(Sndr sndr) {
>   if constexpr (!dependent_sender<Sndr>) {
>     // This line will fail to compile if Sndr fails its type checking. We
>     // don't want to perform this type checking when Sndr is dependent, though.
>     // Without an environment, the sender doesn't know its completions.
>     get_completion_signatures<Sndr>();
>   }
>   return sndr;
> }
> ```

Sender algorithms could use this helper when returning the new sender.
For example, the `then` algorithm might look something like this:

> ```cpp
> inline constexpr struct then_t : __pipeable_sender_adaptor<then_t> {
>   template <sender Sndr, class Fn>
>   auto operator()(Sndr sndr, Fn fn) const {
>     return __type_check_sender(__then_sender{std::move(sndr), std::move(fn)});
>   }
> } then {};
> ```

`sender_in`
-----------

With the above changes, we need to tweak the `sender_in` concept to require
that `get_completion_signatures<Sndr, Env...>()` is a constant expression.

The changes to `sender_in` relative to [@P3164R3] are as follows:

> ```cpp
> @[`template <auto>`]{.add}@
>   @@[`concept @_is-constant_@ = true; @_// exposition only_@`]{.add}@@
> 
> template<class Sndr, class... Env>
>   concept sender_in =
>     sender<Sndr> &&
>     (sizeof...(Env) <= 1)
>     (queryable<Env> &&...) &&
>     @@[`@_is-constant_@<get_completion_signatures<Sndr, Env...>()>;`]{.add}@@
>     @[`requires (Sndr&& sndr, Env&&... env) {`]{.rm}@
>       @[`{ get_completion_signatures(std::forward<Sndr>(sndr), std::forward<Env>(env)...) }`]{.rm}@
>         @@[`-> @_valid-completion-signatures_@;`]{.rm}@@
>     @[`};`]{.rm}@
> ```

_`basic-sender`_
----------------

The sender algorithms are expressed in terms of the exposition-only class
template _`basic-sender`_. The mechanics of computing completion signatures is
not specified, however, so very little change there is needed to implement this
proposal.

We do, however, have to say when
<code><em>basic-sender</em>::get_completion_signatures&lt;Sndr>()</code> is
ill-formed. In [@P3164R3], non-dependent senders are dealt with by discussing
whether or not a sender's potentially-evaluated completion operations are
dependent on the type of the receiver's environment. In this paper, we make a
similar appeal when specifying whether or not
<code><em>basic-sender</em>::get_completion_signatures&lt;Sndr>()</code> is
well-formed.

`dependent_sender`
------------------

Users who write their own sender adaptors will also want to perform early
type-checking of senders that are not dependent. Therefore, they need a way
to determine whether or not a sender is dependent.

In the section [`get_completion_signatures`](#get_completion_signatures) we show
how the concept `dependent_sender` can be implemented in terms of this paper's
`get_completion_signatures` function template. By making this a public-facing
concept, we give sender adaptor authors a way to do early type-checking, just
like the standard adaptors.

Proposed Design, Nice-to-haves
==============================

`completion_signatures`
-----------------------

Computing completions signatures is now to be done using `constexpr`
meta-programming by manipulating values using ordinary imperative C++ rather
than template meta-programming. To better support this style of programming,
it is helpful to add `constexpr` operations that manipulate instances of
specializations of the `completion_signatures` class template.

For example, it should be possible to take the union of two sets of completion
signatures. `operator+` seems like a natural choice for that:

> ```cpp
> completion_signatures<set_value_t(int), set_error_t(exception_ptr)> cs1;
> completion_signatures<set_stopped_t(), set_error_t(exception_ptr)> cs2;
> 
> auto cs3 = cs1 + cs2; // completion_signatures<set_value_t(int),
>                       //                       set_error_t(exception_ptr),
>                       //                       set_stopped_t()>
> ```

It can also be convenient for `completion_signature` specializations to model
[_`tuple-like`_](https://en.cppreference.com/w/cpp/utility/tuple/tuple-like).
Although tuple elements cannot have funtion type, they can have function
_pointer_ type. With this proposal, an object like
`completion_signatures<set_value_t(int), set_stopped_t()>{}` behaves like
`tuple<set_value_t(*)(int), set_stopped_t(*)()>{nullptr, nullptr}` (except that
it wouldn't actually have to store the `nullptr`s). That would make it possible
to manipulate completion signatures using `std::apply`:

> ```cpp
> auto cs = /*...*/;
>
> // Add an lvalue reference to all arguments of all signatures:
> auto add_ref =     []<class T, class... As>(T(*)(As...)) -> T(*)(As&...) { return {}; };
> auto add_ref_all = [=](auto... sigs) { return make_completion_signatures(add_ref(sigs)...); };
>
> return std::apply(add_ref_all, cs);
> ```

The code above uses another nice-to-have feature: a `make_completion_signatures`
helper function that deduces the signatures from the arguments, removes any
duplicates, and returns a new instance of `completion_signatures`.

Consider trying to do all the above using template meta-programming. &#x1F62C;

`make_completion_signatures`
----------------------------

The `make_completion_signatures` helper function described just above would allow
users to build a `completion_signatures` object from a bunch of signature types,
or from function pointer objects, or a combination of both:

> ```cpp
> // Returns a default-initialized object of type completion_signatures<Sigs...>,
> // where Sigs is the set union of the normalized ExplicitSigs and DeducedSigs.
> template <@_`completion-signature`_@... ExplicitSigs, @_`completion-signature`_@... DeducedSigs>
> constexpr auto make_completion_signatures(DeducedSigs*... sigs) noexcept
>   -> @_`valid-completion-signatures`_@ auto;
> ```

To "normalize" a completion signature means to strip rvalue references from the
arguments. So, `set_value_t(int&&, float&)` becomes `set_value_t(int, float&)`.
`make_completions_signatures` first normalizes all the signatures and then
removes duplicates. ([@P2830R7] lets us order types, so making the set unique
will be _O_(_n_ log _n_).)

`transform_completion_signatures`
---------------------------------

The current Working Draft has a utility to make type transformations of
completion signature sets simpler: the alias template
`transform_completion_signatures`. It looks like this:

> ```cpp
> template <class... As>
> using @_value-transform-default_@ = completion_signatures<set_value_t(As...)>;
>
> template <class Error>
> using @_error-transform-default_@ = completion_signatures<set_error_t(Error)>;
>
> template <@_valid-completion-signatures_@ Completions,
>           @_valid-completion-signatures_@ OtherCompletions = completion_signatures<>,
>           template <class...> class ValueTransform = @_value-transform-default_@,
>           template <class> class ErrorTransform = @_error-transform-default_@,
>           @_valid-completion-signatures_@ StoppedCompletions = completion_signatures<set_stopped_t()>>
> using transform_completion_signatures = /*see below*/;
> ```

Anything that can be done with `transform_completion_signatures` can be done in
`constexpr` using `std::apply`, a lambda with `if constexpr`, and `operator+` of
`completion_signature` objects. In fact, we could even implement
`transform_completion_signatures` itself that way:

> ```cpp
> template </* ... as before... */>
> using transform_completion_signatures =
>   std::constant_wrapper< // see @@[@P2781R5]@@
>     std::apply(
>       [](auto... sigs) {
>         return ([]<class T, class... As>(T (*)(As...)) {
>           if constexpr (^^T == ^^set_value_t) { // use reflection to test type equality
>             return ValueTransform<As...>();
>           } else if constexpr (^^T == ^^set_error_t) {
>             return ErrorTransform<As...[0]>();
>           } else {
>             return StoppedCompletions();
>           }
>         }(sigs) +...+ completion_signatures());
>       },
>       Completions()
>     ) + OtherCompletions()
>   >::value_type;
> ```

This paper proposes dropping the `transform_completion_signatures` type alias
since it is not in the ideal form for `constexpr` meta-programming, and since
`std::apply` is good enough (sort of).

However, should we decide to keep the functionality of
`transform_completion_signatures`, we can reexpress it as a `constexpr` function
that accepts transforms as lambdas:

> ```cpp
> constexpr auto @_value-transform-default_@ = []<class... As>() { return completion_signatures<set_value_t(As...)>(); };
> constexpr auto @_error-transform-default_@ = []<class Error>() { return completion_signatures<set_error_t(Error)>(); };
> 
> template <@_valid-completion-signatures_@ Completions,
>           class ValueTransform = decltype(@_value-transform-default_@),
>           class ErrorTransform = decltype(@_error-transform-default_@),
>           @_valid-completion-signatures_@ StoppedCompletions = completion_signatures<set_stopped_t()>,
>           @_valid-completion-signatures_@ OtherCompletions = completion_signatures<>>
> consteval auto transform_completion_signatures(Completions completions,
>                                                ValueTransform value_transform = {},
>                                                ErrorTransform error_transform = {},
>                                                StoppedCompletions stopped_completions = {},
>                                                OtherCompletions other_completions = {})
>   -> @_valid-completion-signatures_@ auto;
> ```

The above form of `transform_completion_signatures` is more natural to use from
within a `constexpr` function. It also makes it simple to accept the default for
some arguments as shown below:

> ```cpp
> // Transform just the error completion signatures:
> auto cs2 = transform_completion_signatures(cs, {}, []<class E>() { return /*...*/; });
>                                            //  ^^  Accept the default value transform
> ```

Since accepting the default transforms is simple, we are able to move the
infrequently used `OtherCompletions` argument to the end of the argument list.

Although the signature of this `transform_completion_signatures` function looks
frightful, the implementation is quite straightforward, and seeing it might
make it less scary:

> ```cpp
> template <class... As, class Fn>
> consteval auto __apply_transform(const Fn& fn) {
>   if constexpr (!requires {{fn.template operator()<As...>()} -> __valid_completion_signatures;})
>     return invalid_completion_signature< @...@ >( @...@ ); @_`// see below`{.cpp}_@
>   else
>     return fn.template operator()<As...>();
> }
> 
> template < /* @...@ as shown above @...@ */ >
> consteval auto transform_completion_signatures(Completions completions,
>                                                ValueTransform value_transform,
>                                                ErrorTransform error_transform,
>                                                StoppedCompletions stopped_completions,
>                                                OtherCompletions other_completions) {
>   auto transform1 = [=]<class T, class... As>(Tag(*)(As...)) {
>     if constexpr (Tag() == set_value) // see "Completion tag comparison" below
>       return __apply_transform<As...>(value_transform);
>     else if constexpr (Tag() == set_error)
>       return __apply_transform<As...>(error_transform);
>     else
>       return stopped_completions;
>   };
> 
>   auto transform_all = [=](auto*... sigs) {
>     return (transform1(sigs) +...+ completion_signatures());
>   };
> 
>   return std::apply(transform_all, completions) + other_completions;
> }
> ```

Like `get_completion_signatures`, `transform_completion_signatures` always
returns a specialization of `completion_signatures` and reports errors by
throwing exceptions. It expects the lambdas passed to it to do likewise (but
handles it gracefully if they don't).

`invalid_completion_signature`
------------------------------

The reason for the design change is to permit the reporting of type errors using
exceptions. Let's look at an example where it would be desirable to throw an
exception from `get_completion_signatures`: the `then` algorithm. We will use
this example to motivate the rest of the design changes.

The `then` algorithm attaches a continuation to an async operation that executes
when the operation completes successfully. With this proposal, a `then_sender`'s
`get_completion_signatures` customization might be implemented as follows:

> ```cpp
> template <class Sndr, class Fun>
> template <class Self, class... Env>
> constexpr auto then_sender<Sndr, Fun>::get_completion_signatures() {
>   // compute the completions of the (properly cv-qualified) child:
>   using Child = decltype(std::forward_like<Self>(declval<Sndr&>()));
>   auto child_completions = get_completion_signatures<Child, Env...>();
>
>    // This lambda is used to transform value completion signatures:
>   auto value_transform = []<class... As>() {
>     if constexpr (std::invocable<Fun, As...>) {
>       using Result = std::invoke_result_t<Fun, As...>;
>       return completion_signatures<set_value_t(Result)>();
>     } else {
>       // Oh no, the user made an error! Tell them about it.
>       throw @_`some-exception-object`_@;
>     }
>   };
>
>   // Transform just the value completions:
>   return transform_completion_signatures(child_completions, value_transform);
> }
> ```

We would like to make it dead simple to throw an exception that will convey a
domain-specific diagnostic to the user. That way, the authors of sender
algorithms will be more likely to do so.

The `invalid_completion_signature` helper function is designed to make generating
meaningful diagnostics easy. As an example, here is how the `then_sender`'s
`completion_signatures` customization might use it:

> ```cpp
> template <const auto&> struct IN_ALGORITHM;
>
> template <class Sndr, class Fun>
> template <class Self, class... Env>
> constexpr auto then_sender<Sndr, Fun>::get_completion_signatures() {
>   @...@
>    // This lambda is used to transform value completion signatures:
>   auto value_transform = []<class... As>() {
>     if constexpr (std::invocable<Fun, As...>) {
>       using Result = std::invoke_result_t<Fun, As...>;
>       if constexpr (^^Result == ^^void)
>         return completion_signatures<set_value_t()>();
>       else
>         return completion_signatures<set_value_t(Result)>();
>     } else {
>       // Oh no, the user made an error! Tell them about it.
>       return invalid_completion_signature<
>         IN_ALGORITHM<std::execution::then>,
>         struct WITH_FUNCTION(Fun),
>         struct WITH_ARGUMENTS(As...)
>       >("The function passed to std::execution::then is not callable "
>         "with the values sent by the predecessor sender.");
>     }
>   };
>   @...@
> }
> ```

When the user of `then` makes a mistake, say like with the expression
"`just(42) | then([]() {@...@})`", they will get a helpful diagnostic like:

<blockquote>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">
<span><b>&lt;source&gt;:658:3: </b><b><span style="color:red">error: </span></b><b>call to immediate function 'operator|&lt;just_sender&lt;int&gt;&gt;'
is not a constant expression</b></span>
  658 |   just(<span style="color:green">42</span>) | then([](){})
      | <b><span style="color:green">  ^</span></b>
<span><b><span style="color:green"></span></b><b>&lt;source&gt;:564:14: </b><b><span style="color:cyan">note: </span></b>'operator|&lt;just_sender&lt;int&gt;&gt;' is an immediate function be
cause its body contains a call to an immediate function '__type_check_sender&lt;the
n_sender&lt;just_sender&lt;int&gt;, (lambda at &lt;source&gt;:658:19)&gt;&gt;' and that call is not a
constant expression</span>
  564 |       <span style="color:blue">return</span> __type_check_sender(then_sender{{}, self.fn_, sndr});
      | <b><span style="color:green">             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></b>
<span><b><span style="color:green"></span></b><b>&lt;source&gt;:358:11: </b><b><span style="color:cyan">note: </span></b>unhandled exception of type '__sender_type_check_failure&lt;
const char *, IN_ALGORITHM&lt;then&gt;, WITH_FUNCTION ((lambda at &lt;source&gt;:658:19)), W
ITH_ARGUMENTS (int)&gt;' with content {&amp;<span class="st">"The function passed to std::execution::the
n is not callable with the values sent by the predecessor sender."</span>[0]} thrown fr
om here</span>
  358 |     <span style="color:blue">throw</span> __sender_type_check_failure&lt;Values...[<span style="color:green">0</span>], What...&gt;(values...);
      | <b><span style="color:green">          ^</span></b>
<b><span style="color:green"></span></b>1 error generated.
Compiler returned: 1</code></pre></div>
</blockquote>

The above is the _complete_ diagnostic, regardless of how deeply nested the type error
is. So long, megabytes of template spew!

Lambdas passed to `transform_completion_signatures` _should_ return a
`completion_signatures` specialization (although
`transform_completion_signatures` recovers gracefully when they do not). The return type
of `invalid_completion_signature` is `completion_signature<>`. By "returning" the result
of calling `invalid_completion_signature`, the deduced return type of the lambda is
a `completion_signatures` type, as it should be.

A possible implementation of the `invalid_completion_signature` function is
shown below:

> ```cpp
> template <class... What, class... Args>
> struct @_sender-type-check-failure_@ : std::exception { @_`// exposition only`{.cpp}_@
>   constexpr @_sender-type-check-failure_@(Args... args) : @*args_*@{std::move(args)...} {}
>   constexpr char const* what() const noexcept override { return @_unspecified_@; };
>   std::tuple<Args...> @*args_*@; @_`// exposition only`{.cpp}_@
> };
> 
> template <class... What, class... Args>
> [[noreturn, nodiscard]]
> consteval completion_signatures<> invalid_completion_signature(Args... args) {
>   throw @_sender-type-check-failure_@<What..., Args...>{std::move(args)...};
> }
> ```

`get_child_completion_signatures`
---------------------------------

In the `then_sender` above, computing a child sender's completion signatures is a little awkward:

> ```cpp
> // compute the completions of the (properly cv-qualified) child:
> using Child = decltype(std::forward_like<Self>(declval<Sndr&>()));
> auto child_completions = get_completion_signatures<Child, Env...>();
> ```

Computing the completions of child senders will need to be done by every sender
adaptor algorithm. We can make this simpler with a
`get_child_completion_signatures` helper function:

> ```cpp
> // compute the completions of the (properly cv-qualified) child:
> auto child_completions = get_child_completion_signatures<Self, Sndr, Env...>();
> ```

... where `get_child_completion_signatures` is defined as follows:

> ```cpp
> template <class Parent, class Child, class... Env>
> consteval auto get_child_completion_signatures() {
>   using @_cvref-child-type_@ = decltype(std::forward_like<Parent>(declval<Child&>()));
>   return get_completion_signatures<@_cvref-child-type_@, Env...>();
> }
> ```

Completion tag comparison
-------------------------

For convenience, we can make the completion tag types equality-comparable with
each other. When writing sender adaptor algorithms, code like the following will
be common:

> ```cpp
> []<class Tag, class... Args>(Tag(*)(Args...)) {
>   if constexpr (std::is_same_v<Tag, ex::set_value_t>) {
>     // Do something
>   }
>   else {
>     // Do something else
>   }
> }
> ```

Although certainly not hard, with reflection the tag type comparison becomes a
litte simpler:

> ```cpp
>   if constexpr (^^Tag == ^^ex::set_value_t>) {
> ```

We can make this even easier by simply making the completion tag types
equality-comparable, as follows:

> ```cpp
>   if constexpr (Tag() == ex::set_value) {
> ```

The author finds that this makes his code read better. Tag types would compare
equal to themselves and not-equal to the other two tag types.

`eptr_completion_if`
--------------------

The following is a trivial utility that the author finds he uses surprisingly
often. Quite often, an async operation can complete exceptionally, but only
under certain conditions. In cases such as those, it is necessary to add a
`set_error_t(std::exception_ptr)` signature to the set of completions, but only
when the condition is met.

This is made simpler with the following alias template:

> ```cpp
> template <bool PotentiallyThrowing>
> using eptr_completion_if =
>   std::conditional_t<PotentiallyThrowing,
>                      completion_signatures<set_error_t(exception_ptr)>,
>                      completion_signatures<>>;
> ```

An example usage, from the `then` sender:

> ```cpp
> template <class Sndr, class Fun>
> template <class Self, class... Env>
> constexpr auto then_sender<Sndr, Fun>::get_completion_signatures() {
>   auto cs = get_child_completion_signatures<Self, Sndr, Env...>();
>   auto value_fn = []<class... As>() { @_... see [`invalid_completion_signature`](#invalid_completion_signature) ..._@ };
>
>   // Compute whether Fun can throw for any set of the predecessor's values
>   constexpr bool nothrow = std::apply([](auto... sigs) {
>     return ([]<class T, class... As>(T(*)(As...)) {
>       return (T() == set_value) ? std::is_nothrow_invocable_v<Fun, As...> : true;
>     }(sigs) &&...);
>   }, cs);
>
>   // Use eptr_completion_if here as the "extra" set of completions that
>   // will be added to the ones returned from the transforms.
>   return transform_completion_signatures(cs, value_fn, {}, {}, eptr_completion_if<!nothrow>());
> }
> ```

Questions for LEWG
==================

Assuming we want to change how completion signatures are computed as proposed in
this paper, the author would appreciate LEWG's feedback about the suggested
additions.

1. Do we want to use `operator+` to join two `completion_signature` objects?

2. Do we want to make `completion_signatures<Sigs...>` _`tuple-like`_ (where
    `completion_signatures<Sigs...>()` behaves like `tuple<Sigs*...>()`)?

3. Should we drop the `transform_completion_signatures` alias template?

4. Should we add a `make_completion_signatures` helper function that returns
    an instance of a `completion_signatures` type with its function types
    normalized and made unique?

5. Should we replace the `transform_completion_signatures` alias template with
    a `consteval` function that does the same thing but for values?

6. Do we want the `invalid_completion_signature` helper function to make it
    easy to generate good diagnostics when type-checking a sender fails.

7. Do we want the `get_child_completion_signatures` helper function to make
    is easy for sender adaptors to get a (properly _cv_-qualified) child
    sender's completion signatures?

8. Do we want to make the completion tag types (`set_value_t`, etc.)
    `constexpr` equality-comparable with each other?

9. Do we want the `eptr_completion_if` utility, which aliases
    either `completion_signatures<set_error_t(std::exception_ptr)>` or
    `completion_signatures<>` depending on a `bool` template parameter?

Implementation Experience
=========================

The design proposed below has been prototyped and can be found
on [Compiler Explorer](https://godbolt.org/z/Y1vPcn6Kr)[^1].

[^1]: [https://godbolt.org/z/Y1vPcn6Kr](https://godbolt.org/z/Y1vPcn6Kr)

Proposed Wording
================

[Change [exec.syn] as follows:]{.ednote}

> <b>Header `<execution>` synopsis [exec.syn]</b>
>
> ```
> namespace std::execution {
>   @<span style="color:blue;font-style:italic">...TODO...</span>@
> }
> ```

Acknowledgements
================

I would like to thank Hana Dusíková for her work making constexpr exceptions a
reality for C++26. Thanks also to LEWG for the nudge to investigate using
constexpr exceptions as an alternative to TMP hackery.

---
references:
  - id: P3164R3
    citation-label: P3164R3
    title: "Improving diagnostics for sender expressions"
    author:
      - family: Niebler
        given: Eric
    URL: https://wg21.link/P3164R3
---