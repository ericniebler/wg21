---
title: Reconsidering the `std::execution::on` algorithm
...


<style>
body { min-width: 50% !important; }
p {text-align:justify}
li {text-align:justify}
blockquote.note {
	background-color:#E0E0E0;
	padding-left: 15px;
	padding-right: 15px;
	padding-top: 1px;
	padding-bottom: 1px;
}
span.note:before {
  content: "[Note: ";
  font-style: italic;
}
span.note:after {
  content: " -- end note]";
  font-style: italic;
}
span.ednote:before {
  content: "[Editorial note: ";
  font-style: italic;
}
span.ednote:after {
  content: " -- end note]";
  font-style: italic;
}
span.ednote, span.ednote * {
  color:blue !important;
  margin-top: 0em;
  margin-bottom: 0em;
}
ins, ins * {color:#00A000 !important}
del, del * {color:#A00000 !important}
div.ins, div.ins * {
	color:#00A000 !important;
	text-decoration-line: none;
}
dfn {
	font-style: italic;
	font-weight: bold;
}
code:not(sourceCode) {
	white-space: normal;
	font-size: 80% !important;
}
ins > code:not(sourceCode) {
	white-space: normal;
	font-size: 80% !important;
}
div.sourceCode {
	margin-left: 20pt !important;
}
</style>

<div>
<dl>
<dt><strong>Authors:</strong></dt>
<dd><a href="mailto:eric.niebler@gmail.com">Eric Niebler</a></dd>

<dt><strong>Date:</strong></dt>
<dd>February 29, 2024</dd>

<dt><strong>Source:</strong></dt>
<dd><a href="https://github.com/ericniebler/wg21/blob/main/P3175/P3175R0.md">GitHub</a></dd>

<dt><strong>Issue tracking:</strong></dt>
<dd><a href="https://github.com/ericniebler/wg21/issues">GitHub</a></dd>

<dt><strong>Project:</strong></dt>
<dd>ISO/IEC JTC1/SC22/WG21 14882: Programming Language â€” C++</dd>

<dt><strong>Audience:</strong></dt>
<dd>LEWG</dd>
</dl>
</div>


Synopsis
--------

Usage experience with P2300 has revealed a gap between users'
expectations and the actual behavior of the `std::execution::on` algorithm. This
paper seeks to close that gap by making its behavior less surprising.

Executive Summary
-----------------

Below are the specific changes this paper proposes:

1. Rename the current `std::execution::on` algorithm to `std::execution::start_on`.

2. Rename `std::execution::transfer` to `std::execution::complete_on`

3. Add a new algorithm `std::execution::on` that, like `start_on`, starts a
    sender on a particular context, but that remembers where execution is
    transitioning _from_. After the sender completes, the `on` algorithm
    transitions _back_ to the starting execution context, giving a scoped,
    there-and-back-again behavior.

4. Optional: add a form of `std::execution::on` that lets you run part of a
    continuation on one scheduler, automatically transitioning back to the
    starting context.

Problem Description
-------------------

If, knowing little about senders and sender algorithms, someone showed you
code such as the following:

```c++
namespace ex = std::execution;

ex::sender auto work1 = ex::just()
                      | ex::transfer(scheduler_A);

ex::sender auto work2 = ex::on(scheduler_B, std::move(work1))
                      | ex::then([] { std::puts("hello world!"); });

ex::sender auto work3 = ex::on(scheduler_C, std::move(work2))

std::this_thread::sync_wait(std::move(work3));
```

... and asked you, which scheduler, `scheduler_A` or `scheduler_B`, is used to
execute the code that prints `"hello world!"`? You might reasonably think the
answer is `scheduler_C`. Your reasoning would go something like this: 

> Well clearly the first thing we execute is `on(scheduler_C, work2)`. I'm
> pretty sure that is going to execute `work2` on `scheduler_C`. The `printf` is
> a part of `work2`, so I'm going to guess that it executes on `scheduler_C`. 

This paper exists because the `on` algorithm as specified in P2300R8 does _not_
print `"hello world!"` from `scheduler_C`. It prints it from `scheduler_A`.
Surprise!

<div style="text-align: center">**_But why?_**</div>

`work2` executes `work1` on `scheduler_B`. `work1` then rather rudely
transitions to `scheduler_A` and doesn't transition back. The `on` algorithm is
cool with that. It just happily runs its continuation inline, _still on
`scheduler_A`_, which is where `"hello world!"` is printed from.

If there was more work tacked onto the end of `work3`, it too would execute on
`scheduler_A`.

### User expectations

The authors of P2300 have witnessed this confusion in the wild. And when this
author has asked his programmer friends about the code above, every single one
said they expected behavior different from what is specified. This is very
concerning.

However, if we change some of the algorithm names, people are less likely to
make faulty assumptions about their behavior. Consider the above code with
different names:

```c++
namespace ex = std::execution;

ex::sender auto work1 = ex::just()
                      | ex::complete_on(scheduler_A);

ex::sender auto work2 = ex::start_on(scheduler_B, std::move(work1))
                      | ex::then([] { std::puts("hello world!"); });

ex::sender auto work3 = ex::start_on(scheduler_C, std::move(work2))

std::this_thread::sync_wait(std::move(work3));
```

Now the behavior is a little more clear. The names `start_on` and `complete_on`
both suggest a one-way execution context transition, which matches their
specified behavior.

### Filling the gap

`on` fooled people into thinking it was a there-and-back-again algorithm.
We propose to fix that by renaming it to `start_on`. But what of the people
who _want_ a there-and-back-again algorithm?

Asynchronous work is better encapsulated when it completes on the same execution
context that it started on. People are surprised, and reasonably so, if they
`co_await` a task from a CPU thread pool and get resumed on, say, an OS timer
thread. Yikes!

We have an opportunity to give the users of P2300 what they _thought_ they
were already getting, and now the right name is available: **`on`**.

We propose to add a new algorithm, called `on`, that remembers where execution
came from and automatically transitions back there. Its operational semantics
can be easily expressed in terms of the existing P2300 algorithms. It is
approximately the following:

```c++
template <ex::scheduler Sched, ex::sender Sndr>
sender auto on(Sched sched, Sndr sndr) {
  return ex::read(ex::get_scheduler)
       | ex::let_value([=](auto old_sched) {
           return ex::start_on(sched, sndr)
                | ex::complete_on(old_sched);
         });
}
```

### One step further?

Once we recast `on` as a there-and-back-again algorithm, it opens up the possibility
of another there-and-back-again algorithm, one that executes a part of a _continuation_
on a given scheduler. Consider the following code, where `async_read_file` and
`async_write_file` are functions that return senders:

```c++
ex::sender auto work = async_read_file()
                     | ex::on(cpu_pool, ex::then(crunch_numbers))
                     | ex::let_value([](auto numbers) {
                         return async_write_file(numbers);
                       });
```

This would be a different overload of `on`, one that takes a sender, a scheduler,
and a continuation. The above would be roughly equivalent to:

```c++
ex::sender auto work = async_read_file()
                     | ex::let_value([=](auto numbers) {
                         auto work = ex::just(numbers)
                                   | ex::then(crunch_numbers);
                         return ex::on(cpu_pool, work)
                              | ex::let_value([=](auto numbers) {
                                  return async_write_file(numbers);
                                });
                       });
```







Design Considerations
---------------------

### Do we really have to rename the `transform` algorithm?



Proposed Wording
----------------

<span class="ednote">The wording in this section assumes is based on
[P2300R8](https://wg21.link/P2300R8).</span>


Change [sndr.]/ as follows:


<blockquote>

</blockquote>


<blockquote><pre style="white-space: pre-wrap; font-size: 85%;">
</pre></blockquote>


Acknowlegments
--------------

I'd like to thank my dog, Luna.
