---
title: Reconsidering the `std::execution::on` algorithm
...


<style>
body { min-width: 50% !important; }
p {text-align:justify}
li {text-align:justify}
blockquote.note {
	background-color:#E0E0E0;
	padding-left: 15px;
	padding-right: 15px;
	padding-top: 1px;
	padding-bottom: 1px;
}
span.note:before {
  content: "[Note: ";
  font-style: italic;
}
span.note:after {
  content: " -- end note]";
  font-style: italic;
}
span.ednote:before {
  content: "[Editorial note: ";
  font-style: italic;
}
span.ednote:after {
  content: " -- end note]";
  font-style: italic;
}
span.ednote, span.ednote * {
  color:blue !important;
  margin-top: 0em;
  margin-bottom: 0em;
}
ins, ins * {color:#00A000 !important}
del, del * {color:#A00000 !important}
div.ins, div.ins * {
	color:#00A000 !important;
	text-decoration-line: none;
}
dfn {
	font-style: italic;
	font-weight: bold;
}
code:not(sourceCode) {
	white-space: normal;
	font-size: 80% !important;
}
ins > code:not(sourceCode) {
	white-space: normal;
	font-size: 80% !important;
}
div.sourceCode {
	margin-left: 20pt !important;
}
</style>

<div>
<dl>
<dt><strong>Authors:</strong></dt>
<dd><a href="mailto:eric.niebler@gmail.com">Eric Niebler</a></dd>

<dt><strong>Date:</strong></dt>
<dd>February 29, 2024</dd>

<dt><strong>Source:</strong></dt>
<dd><a href="https://github.com/ericniebler/wg21/blob/main/P3175/P3175R0.md">GitHub</a></dd>

<dt><strong>Issue tracking:</strong></dt>
<dd><a href="https://github.com/ericniebler/wg21/issues">GitHub</a></dd>

<dt><strong>Project:</strong></dt>
<dd>ISO/IEC JTC1/SC22/WG21 14882: Programming Language â€” C++</dd>

<dt><strong>Audience:</strong></dt>
<dd>LEWG</dd>
</dl>
</div>


Synopsis
--------

Usage experience with P2300 has revealed a gap between users'
expectations and the actual behavior of the `std::execution::on` algorithm. This
paper seeks to close that gap by making its behavior less surprising.

Executive Summary
-----------------

Below are the specific changes this paper proposes:

1. Rename the current `std::execution::on` algorithm to `std::execution::start_on`.

2. Rename `std::execution::transfer` to `std::execution::continue_on`

3. Add a new algorithm `std::execution::on` that, like `start_on`, starts a
    sender on a particular context, but that remembers where execution is
    transitioning _from_. After the sender completes, the `on` algorithm
    transitions _back_ to the starting execution context, giving a scoped,
    there-and-back-again behavior.

4. Optional: add a form of `std::execution::on` that lets you run part of a
    continuation on one scheduler, automatically transitioning back to the
    starting context.

Problem Description
-------------------

If, knowing little about senders and sender algorithms, someone showed you
code such as the following:

```c++
namespace ex = std::execution;

ex::sender auto work1 = ex::just()
                      | ex::transfer(scheduler_A);

ex::sender auto work2 = ex::on(scheduler_B, std::move(work1))
                      | ex::then([] { std::puts("hello world!"); });

ex::sender auto work3 = ex::on(scheduler_C, std::move(work2))

std::this_thread::sync_wait(std::move(work3));
```

... and asked you, which scheduler, `scheduler_A` or `scheduler_B`, is used to
execute the code that prints `"hello world!"`? You might reasonably think the
answer is `scheduler_C`. Your reasoning would go something like this: 

> Well clearly the first thing we execute is `on(scheduler_C, work2)`. I'm
> pretty sure that is going to execute `work2` on `scheduler_C`. The `printf` is
> a part of `work2`, so I'm going to guess that it executes on `scheduler_C`. 

This paper exists because the `on` algorithm as specified in P2300R8 does _not_
print `"hello world!"` from `scheduler_C`. It prints it from `scheduler_A`.
Surprise!

<div style="text-align: center">**_But why?_**</div>

`work2` executes `work1` on `scheduler_B`. `work1` then rather rudely
transitions to `scheduler_A` and doesn't transition back. The `on` algorithm is
cool with that. It just happily runs its continuation inline, _still on
`scheduler_A`_, which is where `"hello world!"` is printed from.

If there was more work tacked onto the end of `work3`, it too would execute on
`scheduler_A`.

### User expectations

The authors of P2300 have witnessed this confusion in the wild. And when this
author has asked his programmer friends about the code above, every single one
said they expected behavior different from what is specified. This is very
concerning.

However, if we change some of the algorithm names, people are less likely to
make faulty assumptions about their behavior. Consider the above code with
different names:

```c++
namespace ex = std::execution;

ex::sender auto work1 = ex::just()
                      | ex::continue_on(scheduler_A);

ex::sender auto work2 = ex::start_on(scheduler_B, std::move(work1))
                      | ex::then([] { std::puts("hello world!"); });

ex::sender auto work3 = ex::start_on(scheduler_C, std::move(work2))

std::this_thread::sync_wait(std::move(work3));
```

Now the behavior is a little more clear. The names `start_on` and `continue_on`
both suggest a one-way execution context transition, which matches their
specified behavior.

### Filling the gap

`on` fooled people into thinking it was a there-and-back-again algorithm.
We propose to fix that by renaming it to `start_on`. But what of the people
who _want_ a there-and-back-again algorithm?

Asynchronous work is better encapsulated when it completes on the same execution
context that it started on. People are surprised, and reasonably so, if they
`co_await` a task from a CPU thread pool and get resumed on, say, an OS timer
thread. Yikes!

We have an opportunity to give the users of P2300 what they _thought_ they
were already getting, and now the right name is available: **`on`**.

We propose to add a new algorithm, called `on`, that remembers where execution
came from and automatically transitions back there. Its operational semantics
can be easily expressed in terms of the existing P2300 algorithms. It is
approximately the following:

```c++
template <ex::scheduler Sched, ex::sender Sndr>
sender auto on(Sched sched, Sndr sndr) {
  return ex::read(ex::get_scheduler)
       | ex::let_value([=](auto old_sched) {
           return ex::start_on(sched, sndr)
                | ex::continue_on(old_sched);
         });
}
```

### One step further?

Once we recast `on` as a there-and-back-again algorithm, it opens up the
possibility of another there-and-back-again algorithm, one that executes a part
of a _continuation_ on a given scheduler. Consider the following code, where
`async_read_file` and `async_write_file` are functions that return senders
(description after the break):

```c++
ex::sender auto work = async_read_file()
                     | ex::on(cpu_pool, ex::then(crunch_numbers))
                     | ex::let_value([](auto numbers) {
                         return async_write_file(numbers);
                       });
```

Here, we read a file and then send it to an `on` sender. This would be a
different overload of `on`, one that takes a sender, a scheduler, and a
continuation. It saves the result of the sender, transitions to the given
scheduler, and then forwards the results to the continuation,
`then(crunk_numbers)`. After that, it returns to the previous execution
context where it executes the `async_write_file(numbers)` sender.

The above would be roughly equivalent to:

```c++
ex::sender auto work = async_read_file()
                     | ex::let_value([=](auto numbers) {
                         ex::sender auto work = ex::just(numbers)
                                              | ex::then(crunch_numbers);
                         return ex::on(cpu_pool, work)
                              | ex::let_value([=](auto numbers) {
                                  return async_write_file(numbers);
                                });
                       });
```

This form of `on` would make it easy to, in the middle of a pipeline,
pop over to another execution context to do a bit of work and then
automatically pop back when it is done.


Design Considerations
---------------------

### Do we really have to rename the `transform` algorithm?

We don't! Within sender expressions, `work | transfer(over_there)` reads
a bit nicer than `work | continue_on(over_there)`, and taken in isolation
the name change is strictly for the worse.

However, the symmetry of the three operations:

* `start_on`
* `continue_on`
* `on`

... encourages developers to infer their semantics correctly. The first two are
one-way transitions before and after a piece of work, respectively; the third
book-ends work with transitions. In the author's opinion, this consideration
outweighs the other.

### Do we need the additional form of `on`?

We don't! Users can build it themselves from the other pieces of P2300 that will
ship in C++26. But the extra overload makes it much simpler for developers to
write well-behaved asynchronous operations that complete on the same execution
contexts they started on, which is why it is included here.


Questions for LEWG's consideration
----------------------------------

The author would like LEWG's feedback on the following two questions:

1. If `on` is renamed `start_on`, do we also want to rename `transfer` to
    `continue_on`?

2. If `on` is renamed `start_on`, do we want to add a new algorithm named `on`
    that book-ends a piece of work with transitions to and from a scheduler?

3. If we want the new scoped form of `on`, do we want to add the `on(sndr,
    sched, continuation)` algorithm overload to permit scoped execution of
    continuations?

Proposed Wording
----------------

<span class="ednote">The wording in this section is based on
[P2300R8](https://wg21.link/P2300R8).</span>


Change [exec.syn] as follows:

<blockquote><pre style="white-space: pre-wrap; font-size: 85%;">
  namespace <em>sender-adaptors</em> { <em>// exposition only</em>
    struct <ins>start_</ins>on_t;
    struct <del>transfer_t</del><ins>continue_on_t</ins>;
    <ins>struct on_t;</ins>
    struct schedule_from_t;
...
  }
  using <em>sender-adaptors</em>::<ins>start_</ins>on_t;
  using <em>sender-adaptors</em>::<del>transfer_t</del><ins>continue_on_t</ins>;
  <ins>using <em>sender-adaptors</em>::on_t;</ins>
  using <em>sender-adaptors</em>::schedule_from_t;
...

  inline constexpr <ins>start_</ins>on_t <ins>start_</ins>on{};
  inline constexpr <del>transfer_t transfer</del><ins>continue_on_t continue_on</ins>{};
  <ins>inline constexpr on_t on{};</ins>
  inline constexpr schedule_from_t schedule_from{};
</pre></blockquote>

In subsection [exec.adapt.general], add a new paragraph (8) as follows:

<div class="ins">
<blockquote>

8. *`rcvr-with-env`* and *`op-with-env`* are exposition-only class templates as
   follows:

    <pre style="white-space: pre-wrap; font-size: 85%;">
    tempate&lt;class Rcvr, class Env>  // arguments are not associated entities ([lib.tmpl-heads])
    struct <em>rcvr-with-env</em> : receiver_adaptor&lt;<em>rcvr-with-env</em>&lt;Rcvr, Env>> {
      decltype(auto) base(this auto&& self) noexcept {
        return std::forward_like&lt;decltype(self)>(self.op->first);
      }

      decltype(auto) get_env() const noexcept {
        return <em>JOIN-ENV</em>(op->second, <em>FWD-ENV</em>(get_env(op->first)));
      }

      pair&lt;Rcvr, Env>* op; // exposition only
    };

    template&lt;class Sndr, class Rcvr, class Env>  // arguments are not associated entities ([lib.tmpl-heads])
    struct <em>op-with-env</em> {
      <em>op-with-env</em>(Sndr&& sndr, Rcvr rcvr, Env env)
        : data{std::move(rcvr), std::move(env)}
        , op{connect(std::forward&lt;Sndr>(sndr), <em>rcvr-with-env</em>&lt;Rcvr, Env>{{}, &data})} {}

      friend void tag_invoke(start_t, <em>op-with-env</em>&amp; self) noexcept {
        start(self.op);
      }

      pair&lt;Rcvr, Env> data; // exposition only
      connect_result_t&lt;Sndr, <em>rcvr-with-env</em>&lt;Rcvr, Env>> op;
    };
    </pre>

8. *`write-env`* is an exposition-only pipeable sender adaptor object
    ([exec.adapt.objects]) such that, given subexpressions `sndr` and `env`,
    the expression <code><em>write-env</em>(sndr, env)</code> is equivalent to
    <code><em>write-sender</em>{{}, env, sndr}</code>, where *`write-sender`* is
    the following class template:

    <pre style="white-space: pre-wrap; font-size: 85%;">
    struct <em>write-tag</em> {}; //exposition only

    template&lt;queryable Env, sender Sndr>  // arguments are not associated entities ([lib.tmpl-heads])
    struct <em>write-sender</em> {
      using sender_concept = sender_t;

      template&lt;<em>decays-to</em>&lt;<em>write-sender</em>> Self>
      friend auto tag_invoke(connect_t, Self&& self, receiver auto rcvr) {
        return <code><em>op-with-env</em>{std::forward&lt;Self>(self).sndr, std::move(rcvr), std::forward&lt;Self>(self).env}</code>:
      }

      template&lt;<em>decays-to</em>&lt;<em>write-sender</em>> Self>
      friend auto tag_invoke(get_completion_signatures_t, Self&& self, const auto& env) noexcept
        -> decltype(get_completion_signatures(
            std::forward&lt;Self>(self).sndr, <em>JOIN-ENV</em>(self.env, env))) {
        return {};
      }

      friend decltype(auto) tag_invoke(get_env_t, const <em>write-sender</em>& self) noexcept {
        return <em>FWD-ENV</em>(get_env(self.sndr));
      }

      <em>write-tag</em> tag; // exposition only
      Env env;       // exposition only
      Sndr sndr;     // exposition only
    };
    </pre>
</blockquote>
</div>



Change subsection "`execution::on` [exec.on]" to
"`execution::start_on` [exec.start.on]", and within that subsection,
replace every instance of "`on`" with "`start_on`" and every instance of
"`on_t`" with "`start_on_t`".

Change subsection "`execution::transfer` [exec.transfer]" to
"`execution::continue_on` [exec.complete.on]", and within that subsection,
replace every instance of "`transfer`" with "`continue_on`" and every instance of
"`transfer_t`" with "`continue_on_t`".

Insert a new subsection "`execution::on` [exec.on]" as follows:

<div class="ins">
<blockquote>
1. The `on` sender adaptor has two forms:

    - one that starts a sender `sndr` on an execution agent belonging to a particular
      scheduler's associated execution resource and that restores execution to the
      starting execution resource when the sender completes, and

    - one that, upon completion of a sender `sndr`, transfers execution to an execution
      agent belonging to a particular scheduler's associated execution resource,
      then executes a sender adaptor closure with the async results of the sender,
      and that then transfers execution back to the execution resource `sndr`
      completed on.

2. The name `on` denotes a customization point object. For some subexpressions
    `sch` and `sndr`, if `decltype((sch))` does not satisfy `scheduler`, or
    `decltype((sndr))` does not satisfy `sender`, `on(sch, sndr)` is ill-formed.

3. Otherwise, the expression `on(sch, sndr)` is expression-equivalent to:

    <pre style="white-space: pre-wrap; font-size: 85%;">
    transform_sender(
      <em>query-or-default</em>(get_domain, sch, default_domain()),
      <em>make-sender</em>(on, sch, sndr));
    </pre>

4. For a subexpression `closure`, if `decltype((closure))` is not a sender
    adaptor closure object ([exec.adapt.objects]), the expression `on(sndr, sch,
    closure)` is ill-formed; otherwise, it is equivalent to:

    <pre style="white-space: pre-wrap; font-size: 85%;">
    transform_sender(
      <em>get-domain-early</em>(sndr),
      <em>make-sender</em>(on, pair{sch, closure}, sndr));
    </pre>

4. Let `out_sndr` and `env` be subexpressions such that `OutSndr` is
    `decltype((out_sndr))`. If <code><em>sender-for</em>&lt;OutSndr,
    on_t></code> is `false`, then the expressions `on.transform_env(out_sndr,
    env)` and `on.transform_sender(out_sndr, env)` are ill-formed; otherwise:

    1. Let *`none-such`* is an unspecified empty class type and
        *`not-a-sender`* is the exposition-only type:

        <pre style="white-space: pre-wrap; font-size: 85%;">
        struct <em>not-a-sender</em> {
          using sender_concept = sender_t;

          friend auto tag_invoke(get_completion_signatures_t, const <em>not-a-sender</em>&, auto&&) {
            return <em>see below</em>;
          }
        };
        </pre>

        ... where the customization for `get_completion_signatures` returns an
        object of a type that is not a specialization of the
        `completion_signatures` class template.

    2. `on.transform_env(out_sndr, env)` is equivalent to:

        <pre style="white-space: pre-wrap; font-size: 85%;">
        auto&& [ign1, data, ign2] = out_sndr;
        if constexpr (scheduler&lt;decltype(data)>) {
          return <em>JOIN-ENV</em>(<em>SCHED-ENV</em>(data), <em>FWD-ENV</em>(env));
        } else {
          using Env = remove_lvalue_reference_t&lt;decltype((env))>;
          return static_cast&lt;Env>(std::forward&lt;Env>(env));
        }
        </pre>

    3. `on.transform_sender(out_sndr, env)` is equivalent to:

        <pre style="white-space: pre-wrap; font-size: 85%;">
        auto&& [ign, data, sndr] = out_sndr;
        if constexpr (scheduler&lt;decltype(data)>) {
          auto old_sch =
            <em>query-with-default</em>(get_scheduler, env, <em>none-such{}</em>);

          if constexpr (same_as&lt;decltype(old_sch), <em>none-such</em>>) {
            return <em>not-a-sender</em>{};
          } else {
            return start_on(sch, std::forward_like&lt;OutSndr>(sndr))
                 | continue_on(old_sch);
          }
        } else {
          auto&& [sch, closure] = std::forward_like&lt;OutSndr>(data);
          auto old_sch = <em>query-with-default</em>(
            get_completion_scheduler&lt;set_value_t>,
            get_env(sndr),
            <em>query-with-default</em>(get_scheduler, env, <em>none-such{}</em>));

          if constexpr (same_as&lt;decltype(old_sch), <em>none-such</em>>) {
            return <em>not-a-sender</em>{};
          } else {
            return std::forward_like&lt;OutSndr>(sndr)
                 | <em>write-env</em>(<em>SCHED-ENV</em>(old_sch));
                 | continue_on(sch)
                 | std::forward_like&lt;OutSndr>(closure)
                 | continue_on(old_sch)
                 | <em>write-env</em>(<em>SCHED-ENV</em>(sch));
          }
        }
        </pre>

    4. <em>Recommended practice:</em> Implementations should use the return type
        of *`not-a-sender`*'s customization of `get_completion_signatures` to
        inform users that their usage of `on` is incorrect because there is no
        available scheduler onto which to restore execution.

</blockquote>
</div>

<span class="ednote">The following changes to the `let_*` algorithms are not
strictly necessary; they are simplifications made possible by the addition of
the exposition-only <em>write-env</em> above.</span>

Remove [exec.let]p5.1, which defines an exposition-only class *`receiver2`*.

Change [exec.let]p5.2.2 as follows:
<blockquote>

2. Let *`as-sndr2`* be an alias template such that
   <code><em>as-sndr2</em>&lt;Tag(Args`...`)></code> denotes the type
   <code>call-result-t&lt;Fn, decay_t&lt;Args>&`...`></code>. Then
   *`ops2-variant-type`* denotes the type <del><code>variant&lt;monostate,
   connect_result_t&lt;<em>as-sndr2</em>&lt;LetSigs>,
   <em>receiver2</em>&lt;Rcvr, Env>>`...`></code></del>
   <ins><code>variant&lt;monostate,
   <em>op-with-env</em>&lt;<em>as-sndr2</em>&lt;LetSigs>, Rcvr,
   Env>`...`></code></ins>.
</blockquote>

Change [exec.let]p5.3 as follows:

<blockquote>

3. The exposition-only function template *`let-bind`* is <del>equal to</del><ins>as follows</ins>:

    <pre style="white-space: pre-wrap; font-size: 85%;">
    <ins>template&lt;class State, class Rcvr, class... Args></ins>
    <ins>void <i>let-bind</i>(State& state, Rcvr& rcvr, Args&&... args) {</ins>
      auto& args = state.args.emplace&lt;decayed-tuple&lt;Args...>>(std::forward&lt;Args>(args)...);
      auto sndr2 = <ins><em>write-env</em>(</ins>apply(std::move(state.fn), args)<ins>, std::move(state.env)</ins>); <ins>// see [exec.adapt.general]</ins>
      <del>auto rcvr2 = receiver2{std::move(rcvr), std::move(state.env)};</del>
      auto mkop2 = [&] { return connect(std::move(sndr2), std::move(rcvr<del>2</del>)); };
      auto& op2 = state.ops2.emplace&lt;decltype(mkop2())>(emplace-from{mkop2});
      start(op2);
    <ins>}</ins>
    </pre>
</blockquote>


Acknowlegments
--------------

I'd like to thank my dog, Luna.
