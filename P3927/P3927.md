---
title: "`task_scheduler` support for parallel `bulk` execution"
document: P3927R0
date: today
audience:
  - "SG1 Concurrency and Parallelism Working Group"
  - "LEWG Library Evolution Working Group"
  - "LWG Library Working Group"
author:
  - name: Eric Niebler
    email: <eric.niebler@gmail.com>
toc: true
---

# Synopsis

By default, instances of the coroutine type `std::execution::task` store the "current"
scheduler in type-erased scheduler wrapper called `std::execution::task_scheduler`.
As with other type-erased wrappers, the goal of `std::execution::task_scheduler` is
presumably to behave as much like a drop-in replacement for the object it wraps as
is possible.

The `task_scheduler` falls short of this ideal in one respect: if a `task_scheduler`
wraps a `parallel_scheduler` and is used to launch parallel work with a `bulk`
sender, the work is not parallelized as it would be had a `parallel_scheduler`
been used directly. That is because the `task_scheduler` does not treat the
`bulk` algorithms specially, as `parallel_scheduler` does.

Fortunately, the `parallel_scheduler` has been specified in such a way that the
`task_scheduler` can reuse its back-end helpers, making the job of specifying
an improved `task_scheduler` much easier.

# Background

Like `task_scheduler`, the `parallel_scheduler` is a type-erased wrapper for a
scheduler-like object. It uses the abstract base classes `parallel_scheduler_backend` and
`receiver_proxy` to punch the `schedule`, `bulk_chunked`, and `bulk_unchunked` operations
through the type-erased interface. These are precisely the operations we would like
`task_scheduler` to handle.

Currently, `task_scheduler` is specified to have an exposition-only member
_`sch_`_ of type `shared_ptr<void>`. If this is changed to
`shared_ptr<parallel_scheduler_backend>`, then the `bulk` algorithms can
dispatch through ```@_`sch_`_@->schedule_bulk_chunked(...)``` and
```@_`sch_`_@->schedule_bulk_unchunked(...)``` and be accelerated for free.

Well ok, not exactly free; _some_ work is needed:

- We need a class that inherits `parallel_scheduler_backend` and implements its abstract
  interface in terms of a concrete scheduler, like:

  > ```cpp
  > template<scheduler Sch>
  > struct @_`task-scheduler-backend`_@ : parallel_scheduler_backend {           // exposition only
  >   explicit @_`task-scheduler-backend`_@(Sch sch) : sched_(std::move(sch)) {}
  > 
  >   void schedule(receiver_proxy& r, span<byte> s) noexcept override;
  >   void schedule_bulk_chunked(size_t shape, bulk_item_receiver_proxy& r,
  >                              span<byte> s) noexcept override;
  >   void schedule_bulk_unchunked(size_t shape, bulk_item_receiver_proxy& r,
  >                                span<byte> s) noexcept override;
  > 
  >   Sch sched_;
  > };
  > ```

  The `schedule` override would connect the result of calling
  `execution::schedule(sched_)` with a receiver that wraps the `receiver_proxy` and then
  calls `start` on the resulting operation state.

  The `schedule_bulk_[un]chunked` overrides would construct a `bulk` sender whose
  predecessor is essentially the `just()` sender, but with a value completion scheduler of
  `sched_`. It would then `connect` that `bulk` sender with a receiver that wraps the
  `bulk_item_receiver_proxy` and calls `start` on the resulting operation state. Since the
  predecessor sender has `sched_` as its value completion scheduler, `connect` will use
  `sched_`'s domain to transform the `bulk` sender before connecting it with the receiver,
  causing the sender to use a custom implementation as appropriate.

- We also need `task_scheduler` to have a completion domain with a `transform_sender`
  member function that accepts vanilla `bulk_[un]chunked` senders and transforms them so
  that they use ```@_`sch_`_@->schedule_bulk_chunked(...)``` and
  ```@_`sch_`_@->schedule_bulk_unchunked(...)```.

  > ```cpp
  > struct @_`task-scheduler-domain`_@ : default_domain {
  >   template<class BulkSndr, class Env>
  >   static constexpr auto transform_sender(set_value_t, BulkSndr&& bulk_sndr, const Env& env) noexcept;
  > };
  > ```

  This member function would be constrained to accept only `bulk_[un]chunked` senders
  and would return a new sender that, when connected and started, would connect and
  start `bulk_sndr`'s predecessor sender. Error and stopped completions are forwarded
  to the receiver. Value completions are used to construct a `bulk_item_receiver_proxy`
  which is passed to ```@_`sch_`_@->schedule_bulk_chunked(...)```.


# Implementation Experience

The proposed solution has been implemented in NVIDIA's [CCCL](https://github.com/NVIDIA/cccl)
library. The relevant pull request can be found at
[https://github.com/NVIDIA/cccl/pull/5975](https://github.com/NVIDIA/cccl/pull/5975),
and the source for the `task_scheduler` is
[here](https://github.com/NVIDIA/cccl/blob/main/cudax/include/cuda/experimental/__execution/task_scheduler.cuh).

# Proposed Wording

[Change [exec.task.scheduler]{.sref} as follows:]{.ednote}

> ```cpp
> namespace std::execution {
>   class task_scheduler {
>     class @[_`ts-sender`_]{.rm}@ @[_`ts-domain`_]{.add}@;           @_// exposition only_@
>
>     @@[```template<receiver R>```]{.rm}@@
>       @@[```class state;                      @_// exposition only_@```]{.rm}@@
>
>     @@[```template<scheduler Sch>```]{.add}@@
>       @@[```class @_`backend-for`_@;              @_// exposition only_@```]{.add}@@
>   public:
>     using scheduler_concept = scheduler_t;
>
>     template<class Sch, class Allocator = allocator<void>>
>       requires (!same_as<task_scheduler, remove_cvref_t<Sch>>) && scheduler<Sch>
>     explicit task_scheduler(Sch&& sch, Allocator alloc = {});
>
>     @[_`ts-sender`_]{.rm}[_`see below`_]{.add}@ schedule();
>
>     friend bool operator==(const task_scheduler& lhs, const task_scheduler& rhs) noexcept;
>
>     template<class Sch>
>       requires (!same_as<task_scheduler, Sch>) && scheduler<Sch>
>     friend bool operator==(const task_scheduler& lhs, const Sch& rhs) noexcept;
>
>   private:
>     shared_ptr<@[`void`]{.rm}[`parallel_scheduler_backend`]{.add}@> @_`sch_`_@; // exposition only
>                                                      @[_`// see [exec.sysctxrepl.psb]`_]{.add}@
>   };
> }
> ```
>
> 1. `task_scheduler` is a class that models `scheduler` ([exec.sched]{.sref}). Given an
>    object `s` of type `task_scheduler`, let ```@_`SCHED`_@(s)```{.cpp} be [the
>    _`sched_`_ member of]{.add} the object owned by ``s.@_`sch_`_@``. [The expression
>    `get_forward_progress_guarantee(s)` is equivalent to
>    ```get_forward_progress_guarantee(@_`SCHED`_@(s))```. The expression
>    `get_completion_domain<set_value_t>(s)` is equivalent to
>    ```task_scheduler::@_`ts-domain`_@().```]{.add}
>
> ```cpp
> template<class Sch, class Allocator = allocator<void>>
>   requires(!same_as<task_scheduler, remove_cvref_t<Sch>>) && scheduler<Sch>
> explicit task_scheduler(Sch&& sch, Allocator alloc = {});
> ```
>
> 2. _Effects_: Initialize _`sch_`_ with
>    ```allocate_shared<@[_`backend-for`_<]{.add}@remove_cvref_t<Sch>@[`>`]{.add}@>(alloc,​ std​::​forward<Sch>​(sch))```{.cpp}.
>
> 3. _Recommended practice_: Implementations should avoid the use of dynamically allocated
>    memory for small scheduler objects.
> 
> 4. _Remarks_: Any allocations performed by [construction of _`ts-sender`_ or _`state`_
>    objects resulting from]{.rm} calls on `*this` are performed using a copy of `alloc`.
> 
> ::: rm
> 
> ```cpp
> @_`ts-sender`_@ schedule();
> ```
> 
> 5. _Effects_: Returns an object of type _`ts-sender`_ containing a sender initialized with
>    ```schedule(@_`​SCHED​`_@(*this))```.
> 
> :::
> 
> ```cpp
> bool operator==(const task_scheduler& lhs, const task_scheduler& rhs) noexcept;
> ```
> 
> 6. _Effects_: Equivalent to: return ```lhs == @_`SCHED`_@(rhs)```;
> 
> ```cpp
> template<class Sch>
>   requires (!same_as<task_scheduler, Sch>) && scheduler<Sch>
> bool operator==(const task_scheduler& lhs, const Sch& rhs) noexcept;
> ```
> 
> 7. _Returns_: `false` if the type of ```@_`SCHED`_@(lhs)``` is not `Sch`, otherwise
>    ```@_`SCHED`_@(lhs) == rhs```.
>
> [Remove paragraphs 8-12 and add the following paragraphs:]{.ednote}
>
> ::: add
>
> 8. For an lvalue `r` of type derived from `receiver_proxy`, let ```@_`WRAP-RCVR`_@(r)```{.cpp}
>    be an object of a type that models `receiver` and whose
>    completion handlers result in invoking the corresponding completion handlers of `r`.
>
> ```cpp
> namespace std::execution {
>   template<scheduler Sch>
>   class task_scheduler::@_`backend-for`_@ : public parallel_scheduler_backend {           @_`// exposition only`_@
>   public:
>     explicit @_`backend-for`_@(Sch sch) : sched_(std::move(sch)) {}
>  
>     void schedule(receiver_proxy& r, span<byte> s) noexcept override;
>     void schedule_bulk_chunked(size_t shape, bulk_item_receiver_proxy& r,
>                                span<byte> s) noexcept override;
>     void schedule_bulk_unchunked(size_t shape, bulk_item_receiver_proxy& r,
>                                  span<byte> s) noexcept override;
>  
>     Sch @_`sched_`_@; @_`// exposition only`_@
>   };
> }
> ```
>
> 9. Let _`just-sndr-like`_ be a sender whose only value completion signature is
>    `set_value_t()` and for which the expression
>    ```get_completion_scheduler<set_value_t>(get_env(@_`just-sndr-like`_@)) == @_`sched_`_@```{.cpp}
>    is `true`.
>
> ```cpp
> void schedule(receiver_proxy& r, span<byte> s) noexcept override;
> ```
>
> 10. _Effects_: Constructs an operation state `os` with
>     ```connect(schedule(@_`sched_`_@), @_`WRAP-RCVR`_@(r))```{.cpp} and calls `start(os)`.
>
> ```cpp
> void schedule_bulk_chunked(size_t shape, bulk_item_receiver_proxy& r,
>                            span<byte> s) noexcept override;
> ```
>
> 11. _Effects_: Let `chunk_size` be an integer less than or equal to `shape`, let
>     `num_chunks` be `(shape + chunk_size - 1) / chunk_size`, and let `fn` be a function
>     object such that for an integer `i`, `fn(i)` calls `r.execute(i * chunk_size, m)`,
>     where `m` is the lesser of `(i + 1) * chunk_size` and `shape`. Constructs an
>     operation state `os` as if with
>     ```connect(bulk(@_`just-sndr-like`_@, par, num_chunks, fn), @_`WRAP-RCVR`_@(r))```{.cpp}
>     and calls `start(os)`.
>
> ```cpp
> void schedule_bulk_unchunked(size_t shape, bulk_item_receiver_proxy& r,
>                              span<byte> s) noexcept override;
> ```
>
> 12. _Effects_: Let `fn` be a function object such that for an integer `i`, `fn(i)` is
>     equivalent to `r.execute(i, i + 1)`. Constructs an operation state `os` as if with
>     ```connect(bulk(@_`just-sndr-like`_@, par, shape, fn), @_`WRAP-RCVR`_@(r))```{.cpp}
>     and calls `start(os)`.
>
> :::
>
> ::: add
>
> ```cpp
> @_`see below`_@ schedule();
> ```
>
> 13. _Returns_: a prvalue _`ts-sndr`_ whose type models `sender` such that:
>
>     - [8.1]{.pnum} ```get_completion_scheduler<set_value_t>(get_env(@_`ts-sndr`_@))```{.cpp} is equal
>       to `*this`{.cpp}.
>
>     - [8.2]{.pnum} ```get_completion_domain<set_value_t>(get_env(@_`ts-sndr`_@))```{.cpp} is
>       expression-equivalent to ```@_`ts-domain`_@()```{.cpp}.
>
>     - [8.3]{.pnum} If a receiver `rcvr` is connected to _`ts-sndr`_ and the resulting
>       operation state is started, calls ``@_`sch_`_@->schedule(r, s)``, where
>
>       - [8.3.1]{.pnum} `r` is a proxy for `rcvr` with base
>         `system_context_replaceability​::​receiver_proxy`{.cpp}
>         ([exec.par.scheduler]{.sref}) and
>
>       - [8.3.2]{.pnum} `s` is a preallocated backend storage for `r`.
>
>     - [8.4]{.pnum} `completion_signatures_of_t<Sndr>` denotes:
>
>       > ```cpp
>       > completion_signatures<
>       >   set_value_t(),
>       >   set_error_t(error_code),
>       >   set_error_t(exception_ptr),
>       >   set_stopped_t()
>       > >
>       > ```
>
> ```cpp
> namespace std::execution {
>   class task_scheduler::@_`ts-domain`_@ : public default_domain {
>   public:
>     template<class BulkSndr, class Env>
>       static constexpr auto transform_sender(set_value_t, BulkSndr&& bulk_sndr, const Env& env)
>         noexcept;
>   };
> }
> ```
>
> ```cpp
> template<class BulkSndr, class Env>     @_// exposition only_@
>   static constexpr @_`see below`_@ transform_sender(BulkSndr&& bulk_sndr, const Env& env)
>     noexcept;
> ```
>
> 14. _Constraints_: `sender_in<BulkSndr, Env>` is `true`,
>     `auto(std::forward<BulkSndr>(bulk_sndr))` is well-formed, and either
>     ```@_`sender-for`_@<BulkSndr, bulk_chunked_t>```{.cpp} or
>     ```@_`sender-for`_@<BulkSndr, bulk_unchunked_t>```{.cpp} is `true`.
>
> 15. _Effects_: Equivalent to:
>
>     ```cpp
>     auto& [_, data, child] = bulk_sndr;
>     auto& [_, shape, fn] = data;
>     auto sch = @_`call-with-default`_@(get_completion_scheduler<set_value_t>,
>                                  @_`not-a-scheduler`_@(), get_env(child), @_`FWD-ENV`_@(env));
>     return @_`e`_@;
>     ```
>
>     where _`e`_ is ```@_`not-a-sender`_@()``` if the type of `sch` is not
>     `task_scheduler`; otherwise, it is a prvalue whose type models `sender` such that,
>     if it is connected to `rcvr` and the resulting operation state is started, `child`
>     is connected to an unspecified receiver `R` and started. If `child` completes with
>     an error or a stopped completion, the completion operation is forwarded unchanged to
>     `rcvr`. Otherwise, let `args` be a pack of lvalue subexpressions designating objects
>     decay-copied from the value result datums. Then
>
>     - [15.1]{.pnum} If `bulk_sndr` was the result of the evaluation of an expression
>       equivalent to `bulk_chunked(child, policy, shape, f)` or a copy of such, then
>       ```@_`sch_`_@->schedule_bulk_chunked(shape, r, s)```{.cpp} is called where `r` is
>       a bulk chunked proxy ([exec.par.scheduler]{.sref}) for `rcvr` with callable `f`
>       and arguments `args`, and `s` is a preallocated backend storage for `r`.
>
>     - [15.2]{.pnum} Otherwise, calls
>       ```@_`sch_`_@->schedule_bulk_unchunked(shape, r, s)```{.cpp} where `r` is a bulk
>       unchunked proxy for `rcvr` with callable `f` and arguments `args`, and `s` is
>       a preallocated backend storage for `r`.
>
> 16. _Recommended practice_: The returned sender should hold references to the parts
>     of `bulk_sndr` that it needs.
>
> 17. _Remarks_: The expression `get_env(R)` is expression-equivalent to
>     ```@_`FWD-ENV`_@(get_env(@_`rcvr-copy`_@))```{.cpp}, where _`rcvr-copy`_ is
>     an lvalue subexpression designating an object decay-copied from `rcvr`.
>
> :::

