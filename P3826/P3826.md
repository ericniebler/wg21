---
title: "Defer Sender Algorithm Customization to Post-C++26"
document: D3826R0
date: today
audience:
  - "SG1 Concurrency and Parallelism Working Group"
  - "LEWG Library Evolution Working Group"
  - "LWG Library Working Group"
author:
  - name: Eric Niebler
    email: <eric.niebler@gmail.com>
toc: true
---


# Background

In the current Working Draft, [exec]{.sref} has sender algorithms that are customizable.
While the sender/receiver concepts and the algorithms themselves have been stable for
several years now, the customization mechanism has seen a fair bit of recent churn.
[@P3718R0] is the latest effort to shore up the mechanism. Unfortunately, there are gaps
in its proposed resolution. This paper details those gaps.

The problems are fixable although the fixes are non-trivial. The time for elaborate fixes
has passed. This paper proposes to remove the ability to customize sender algorithms for
C++26. A future paper will propose to add the feature back post-'26.

The author feels that postponing the feature will be less disruptive and safer than trying
to patch it at the last minute. Most common usages of sender/receiver will not be
affected.

# The problem with P3718

[@P3718R0] identifies real problems with the status quo of sender algorithm customization.
It proposes using information from the sender about where it will *complete* during
"early" customization, which happens when a sender algorithm constructs and returns a
sender; and it proposes using information from the receiver about where the operation will
*start* during "late" customization, when the sender and the receiver are connected.

The problem with this separation of responsibilities is that many senders do not know
where they will complete until they know where they will be started. A simple example is
the `just()`{.cpp} sender; it completes inline wherever it is started. And the information about
where a sender will start is not known during early customization, when the sender is being
asked for this information.

For the expression `then(sndr, fn)`{.cpp} for example, if the `then`{.cpp} CPO asks
`sndr`{.cpp} where it will complete, `sndr`{.cpp} might not be able to answer, in which
case no "early" customization is performed. And during "late" (`connect`-time)
customization, only the receiver's information about where the operation will start is
used to find a customization. Presumably an algorithm like `then(sndr, fn)`{.cpp} would
want to dispatch based on where the function `fn`{.cpp} will execute, but for some
expressions that information cannot be determined with the API proposed in P3718.

An illustrative example is:

> ```cpp
> namespace ex = std::execution;
> auto sndr = ex::starts_on(gpu, ex::just()) | ex::then(fn);
> std::this_thread::sync_wait(std::move(sndr));
> ```

... where `gpu`{.cpp} is a scheduler that runs work (unsurprisingly) on a GPU.

`fn`{.cpp} will execute on the GPU, so a GPU implementation of `then`{.cpp} should be used. By the
proposed resolution of P3718, algorithm customization proceeds as follows:

* During early customization, when `starts_on(gpu, just()) | then(fn)`{.cpp} is executing,
  the `then`{.cpp} CPO asks the `starts_on(gpu, just())`{.cpp} sender where it will complete
  as if by:

  > ```cpp
  > auto&& @_`tmp1`_@ = ex::starts_on(gpu, ex::just());
  > auto @_`dom1`_@ = ex::get_domain(ex::get_env(@_`tmp1`_@));
  > ```

* The `starts_on`{.cpp} sender will in turn ask the `just()`{.cpp} sender, as if by:

  > ```cpp
  > auto&& @_`tmp2`_@ = ex::just();
  > auto @_`dom2`_@ = ex::get_domain(ex::get_env(@_`tmp2`_@));
  > ```

  As discussed above, the `just()`{.cpp} sender doesn't know where it will complete until
  it knows where it will be started, but that information is not yet available. As a
  result, _`dom2`_ ends up as `default_domain`{.cpp}, which is then reported as the domain
  for the `starts_on`{.cpp} sender. That's incorrect. The `starts_on`{.cpp} sender will
  complete on the GPU.

* The `then`{.cpp} CPO uses `default_domain`{.cpp} to find an implementation of the
  `then`{.cpp} algorithm, which will find the default implementation. As a result, the
  `then`{.cpp} CPO returns an ordinary `then`{.cpp} sender.

* When that `then`{.cpp} sender is connected to `sync_wait`{.cpp}'s receiver, late
  customization happens. `connect`{.cpp} asks `sync_wait`{.cpp}'s receiver where the
  `then`{.cpp} sender will be started. It does that with
  `get_domain(get_env(rcvr))`{.cpp}. `sync_wait`{.cpp} starts operations on the current
  thread, so the `get_domain`{.cpp} query will return `default_domain`{.cpp}. As with
  early customization, late customization will also not find a GPU implementation.

The end result of all of this is that a CPU implementation will be used to evaluate
the `then`{.cpp} algorithm on the GPU. That is a bad state of affairs.

# Solutions considered

OK, so there is a problem. What do we do? There are a number of different options.

## Pull all of the C++26 `std::execution` additions

TODO

## Keep all of `std::execution` except the algorithms

TODO

## Keep all of `std::execution` except algorithm customization

TODO

## Ship everything as-is and fix algorithm customization in a DR

TODO


# Implications of removal

Removing algorithm customization is fairly straightforward in most regards, but there
are a few parts of `std::execution` that need special care.

## The parallel scheduler

The `parallel_scheduler` goes to great lengths to ensure that the `bulk` family of
algorithms -- `bulk`, `bulk_chunked`, and `bulk_unchunked` -- are executed in parallel
when the users requests it and when the underlying execution context supports it.

To that end, the `parallel_scheduler` "provides a customized implementation" of the
`bulk_chunked` and `bulk_unchunked` algorithms, but nothing is said about how those custom
implementations are found or under what circumstances users can be assured that the
`parallel_scheduler` will use them. Arguably, this is underspecified in the current
Working Draft and should be addressed whether this paper is accepted or not.

**We have to give users a guarantee that if _X_, _Y_, and _Z_ conditions are met, `bulk`
_will_ be run in parallel with absolute certainty.**

One solution is to say that the `bulk` algorithms are guaranteed to execute in parallel
when the immediate predecessor of the `bulk` operation is known to complete on the
`parallel_scheduler`. In a sender expression such as the following:

> ```cpp
> sndr | std::execution::bulk(std::par, 1024, fn)
> ```

If `sndr`'s attributes advertizes a completion scheduler of type `parallel_scheduler`,
then we can guarantee that the `bulk` operation will execute in parallel. Implementations
can choose to parallelize `bulk` under other circumstances, but we require this one.

The implication of offering this guarantee is that we must preserve the guarantee going
forward. Any new customization mechanism we might add must _never_ result in parallel
execution becoming serialized.

The reverse is not necessarily true though. **I maintain that a future change that
parallizes a `bulk` algorithm that formerly executed serially on the `parallel_scheduler`
is an acceptable change of behavior.**

If SG1 or LEWG disagrees with that, it greatly limits what can be done at this point,
in which case I would advocate shipping the algorithms as-is and fixing customization
as a DR.

## The task scheduler

[TODO: finish me]{.ednote}


## The `bulk` algorithms

https://cplusplus.github.io/LWG/issue4336

Few users will ever have a need to customize an algorithm like `then` or `let_value`.
The `bulk` algorithms are a different story. Anybody with a custom thread pool will
benefit from a custom `bulk` implementation that can run in parallel on the thread
pool. The loss of algorithm customization is particularly painful in this area. This
section explores some options to address these concerns and makes a recommendation.

### Option 1: Remove `bulk`, `bulk_chunked`, and `bulk_unchunked`

This option cuts the Gordian knot, but comes at a high cost. The `parallel_scheduler`
can hardly be called "parallel" if it does not offer a way to execute work in
parallel, so cutting the `bulk` algorithms probably means cutting `parallel_scheduler`
also.

### Option 2: Magical parallel execution

In this option, we keep the `bulk` algorithms and the `parallel_scheduler`, and we say
that the `bulk` algorithms are executed in parallel on the `parallel_scheduler`, but we
leave the mechanism unspecified.

This option is essentially the _status quo_, except that the _status quo_ is rather
under-specified at the moment. E.g., how does the `bulk` algorithm know it is being run on
the `parallel_scheduler`? Under what circumstances can users expect `bulk` to be
accelerated?

### Option 3: An exposition-only mechanism

This option takes option 2 a step further by specifying an exposition-only mechanism
by which the `parallel_scheduler` parallelizes the `bulk` algorithms. .
For example, we can specify that if a scheduler has an exposition-only 

[TODO: finish me]{.ednote}

### Option 4: A normative mechanism for the `bulk*` algorithms only

[TODO: finish me]{.ednote}


# Downsides of delaying sender alg customization

Until we add the feature back...

* ... users will not have a standard API for accelerating the standard `bulk`{.cpp} family of
  algorithms on their own parallel execution contexts (e.g., thread pools). 

* ... hardware vendors like NVIDIA will not be able to ship a scheduler for an exotic
  (non-CPU-ish) execution context and have it work with any standard-conforming
  implementation of std::execution.

This is only a temporary state of affairs. I describe below how the feature can be added
post-C++26 non-intrusively.

# Adding the feature back

Post-C++26, we can add back a way to query a sender/receiver for the domains on which
the async operation will start and complete. Such a query will have a default: the
`default_domain`{.cpp} that represents execution on a standard thread of execution. The query
will be a so-called "forwarding" query, so it will get passed through adaptation layers
automatically without needing to change any senders or receivers.

At this point, we can change `connect`{.cpp}, `get_completion_signatures`{.cpp}, and the sender
algorithms to check for this domain information and use it to find transforms and/or
customizations. This will not affect any senders already in the wild, none of which will
have such a domain query.




# Removal process

The approach to removing sender algorithm customization is twofold:

- Remove those components that facilitate algorithm customization and their uses where it
  is easy to do so.

- In all other cases, turn normative mechanisms into non-normative ones so we can change
  them later. This results in smaller and safer wording changes and preserves the
  already agreed-upon semantics in a way that is easy to verify.

The steps in detail are listed below.

1. Remove the type `default_domain`{.cpp} ([exec.domain.default]{.sref}).

2. Remove the functions:

   * `transform_sender`{.cpp} ([exec.snd.transform]{.sref}),
   * `transform_env`{.cpp} ([exec.snd.transform.env]{.sref}), and
   * `apply_sender`{.cpp} ([exec.snd.apply]{.sref}).

3. Remove the query object `get_domain`{.cpp} ([exec.get.domain]{.sref}).

4. Remove the exposition-only helpers:

   * _`completion-domain`_ ([exec.snd.expos]{.sref}/8-9),
   * _`get-domain-early`_ ([exec.snd.expos]{.sref}/13), and
   * _`get-domain-late`_ ([exec.snd.expos]{.sref}/14).

5. Change the functions `get_completion_signatures`{.cpp} ([exec.getcomplsigs]{.sref}) and
   `connect`{.cpp} ([exec.connect]{.sref}) to operate on a sender determined as follows
   instead of passing the sender through `transform_sender`{.cpp}:

   * If the sender has a tag with an exposition-only _`transform-sender`_ member function,
     pass the sender to this function with the receiver's environment and continue the
     operation on the resulting sender. This preserves the behavior of calling
     `transform_sender` with the `default_domain`.
   
   * Otherwise, perform the operation on the passed-in sender.

6. For the following algorithms that are currently expressed in terms of a sender
   transformation to a lowered form, move the lowering from
   `@_alg_@.transform_sender(sndr, env)`{.cpp} to `@_alg_@.@_transform-sender_@(sndr, env)`.

   * `starts_on`{.cpp} ([exec.starts.on]{.sref}),
   * `continues_on`{.cpp} ([exec.continues.on]{.sref}),
   * `on`{.cpp} ([exec.on]{.sref}),
   * `bulk`{.cpp} ([exec.bulk]{.sref}),
   * `when_all_with_variant`{.cpp} ([exec.when.all]{.sref}),
   * `stopped_as_optional`{.cpp} ([exec.stopped.opt]{.sref}), and
   * `stopped_as_error`{.cpp} ([exec.stopped.err]{.sref}).

7. For each sender adaptor algorithm in [exec.adapt]{.sref} that is specified to be
   expression-equivalant to some `transform_sender`{.cpp} invocation of the form:

   > ```cpp
   > transform_sender(@_`some-computed-domain`_@(), @_`make-sender`_@(tag, {args...}, sndr));
   > ```

   Change the expression to:

   > ```cpp
   > @_`make-sender`_@(tag, {args...}, sndr);
   > ```

   For example, in [exec.continues.on]{.sref}/3, the following:

   > ```cpp
   > transform_sender(@_`get-domain-early`_@(sndr), @_`make-sender`_@(continues_on, sch, sndr))
   > ```

   would be changed to:

   > ```cpp
   > @_`make-sender`_@(continues_on, sch, sndr)
   > ```

   Additionally, if there is some caveat of the form "except that `sndr`{.cpp} is
   evaluated only once," that caveat should be removed as appropriate.

8. Merge the `schedule_from`{.cpp} ([exec.schedule.from]{.sref}) and `continues_on`{.cpp}
   ([exec.continues.on]{.sref}) algorithms into one algorithm called `continues_on`{.cpp}.
   (Currently they are separate so that they can be customized independently; by default
   `continues_on`{.cpp} merely dispatches to `schedule_from`{.cpp}.)

9. Change [exec.sync.wait]{.sref} and [exec.sync.wait.var]{.sref} to dispatch directly to
   their default implementations instead of computing a domain and using `apply_sender`{.cpp} to
   dispatch to an implementation.

10. Fix a bug in the `on(sndr, sch, closure)` algorithm where a `write_env` is incorrectly
    changing the "current" scheduler before its child `continues_on` actually transfers to
    that scheduler. `continues_on` needs to know the scheduler on which it will be started
    in order to find customizations correctly in the future.

11. Tweak the wording of `parallel_scheduler`{.cpp} ([exec.par.scheduler]{.sref}) to
    indicate that it (`parallel_scheduler`) is permitted to run the `bulk`{.cpp} family of
    algorithms in parallel in accordance with those algorithms' semantics, rather than
    suggesting that those algorithms are "customized" for `parallel_scheduler`{.cpp}. The
    mechanism for such remains non-normative, however we specify the conditions under
    which the `parallel_scheduler` is guaranteed to run the `bulk` algorithms in parallel.
    (This is currently underspecified.)

12. Respecify `task_scheduler` in terms of `parallel_scheduler_backend` so that the
    `bulk` algorithms can be accelerated despite `task_scheduler`'s type-erasure.
    This addresses [LWG#4336](https://cplusplus.github.io/LWG/issue4336). As with
    `parallel_scheduler`, we specify the conditions under which `task_scheduler` is
    guaranteed to run the `bulk` algorithms in parallel.

This is admittedly a lot of changes, but each of these changes represents a simplification
from the status quo. The result will be a vastly simpler specification for [exec].


# Proposed resolution

[THIS SECTION IS INCOMPLETE]{.ednote}

[In [execution.syn]{.sref}, make the following changes:]{.ednote}

> ```cpp
> @[&hellip; as before &hellip;]{.blue}@
> 
> namespace std::execution {
>   // [exec.queries], queries
>   @@[```struct get_domain_t { @_`unspecified`_@ };```]{.rm}@@
>   struct get_scheduler_t { @_`unspecified`_@ };
>   struct get_delegation_scheduler_t { @_`unspecified`_@ };
>   struct get_forward_progress_guarantee_t { @_`unspecified`_@ };
>   template<class CPO>
>     struct get_completion_scheduler_t { @_`unspecified`_@ };
>   struct get_await_completion_adaptor_t { @_`unspecified`_@ };
> 
>   @@[```inline constexpr get_domain_t get_domain{};```]{.rm}@@
>   inline constexpr get_scheduler_t get_scheduler{};
>   inline constexpr get_delegation_scheduler_t get_delegation_scheduler{};
>   enum class forward_progress_guarantee;
>   inline constexpr get_forward_progress_guarantee_t get_forward_progress_guarantee{};
>   template<class CPO>
>     constexpr get_completion_scheduler_t<CPO> get_completion_scheduler{};
>   inline constexpr get_await_completion_adaptor_t get_await_completion_adaptor{};
>
> @[&hellip; as before &hellip;]{.blue}@
> 
>   // [exec.env], class template env
>   template<queryable... Envs>
>     struct env;
> 
>   @@[_```// [exec.domain.default], execution domains```_]{.rm}@@
>   @@[```struct default_domain;```]{.rm}@@
> 
>   // [exec.sched], schedulers
>   struct scheduler_t {};
>
> @[&hellip; as before &hellip;]{.blue}@
> 
>   template<sender Sndr>
>     using tag_of_t = @_`see below`_@;
> 
>   @@[_```// [exec.snd.transform], sender transformations```_]{.rm}@@
>   @@[```template<class Domain, sender Sndr, queryable... Env>```]{.rm}@@
>       @@[```requires (sizeof...(Env) <= 1)```]{.rm}@@
>     @@[```constexpr sender decltype(auto) transform_sender(```]{.rm}@@
>       @@[```Domain dom, Sndr&& sndr, const Env&... env) noexcept(@_`see below`_@);```]{.rm}@@
>
>   @@[_```// [exec.snd.transform.env], environment transformations```_]{.rm}@@
>   @@[```template<class Domain, sender Sndr, queryable Env>```]{.rm}@@
>     @@[```constexpr queryable decltype(auto) transform_env(```]{.rm}@@
>       @@[```Domain dom, Sndr&& sndr, Env&& env) noexcept;```]{.rm}@@
>
>   @@[_```// [exec.snd.apply], sender algorithm application```_]{.rm}@@
>   @@[```template<class Domain, class Tag, sender Sndr, class... Args>```]{.rm}@@
>     @@[```constexpr decltype(auto) apply_sender(```]{.rm}@@
>       @@[```Domain dom, Tag, Sndr&& sndr, Args&&... args) noexcept(@_`see below`_@);```]{.rm}@@
> 
>   // [exec.connect], the connect sender algorithm
>   struct connect_t;
>   inline constexpr connect_t connect{};
>
> @[&hellip; as before &hellip;]{.blue}@
> ```


[Remove subsection [exec.get.domain]{.sref}.]{.ednote}


[In [exec.sched]{.sref}, remove paragraph 6 as follows:]{.ednote}

::: rm

> 6. [For a given scheduler expression `sch`{.cpp}, if the expression `get_domain(sch)`{.cpp} is
>    well-formed, then the expression `get_domain(get_env(schedule(sch)))`{.cpp} is also
>    well-formed and has the same type.]{.rm}

:::

[In [exec.snd.general]{.sref}, change paragraph 1 as follows:]{.ednote}

> 1. Subclauses [exec.factories]{.sref} and [exec.adapt]{.sref} define [customizable]{.rm}
>    algorithms that return senders. [Each algorithm has a default implementation.]{.rm} Let
>    `sndr`{.cpp} be the result of an invocation of such an algorithm or an object equal to the
>    result ([concepts.equality]{.sref}), and let `Sndr`{.cpp} be `decltype((sndr))`{.cpp}. Let `rcvr`{.cpp}
>    be a receiver of type `Rcvr`{.cpp} with associated environment env of type `Env`{.cpp} such that
>    `sender_to<Sndr, Rcvr>`{.cpp} is `true`{.cpp}. [For the default implementation of the algorithm
>    that produced `sndr`{.cpp}, c]{.rm}[C]{.add}onnecting `sndr`{.cpp} to `rcvr`{.cpp} and starting the
>    resulting operation state ([exec.async.ops]{.sref}) necessarily results in the
>    potential evaluation ([basic.def.odr]{.sref}) of a set of completion operations whose
>    first argument is a subexpression equal to `rcvr`{.cpp}. Let `Sigs`{.cpp} be a pack of completion
>    signatures corresponding to this set of completion operations, and let `CS`{.cpp} be the type
>    of the expression `get_completion_signatures<Sndr, Env>()`{.cpp}. Then `CS`{.cpp} is a
>    specialization of the class template `completion_signatures`{.cpp} ([exec.cmplsig]{.sref}),
>    the set of whose template arguments is `Sigs`{.cpp}. If none of the types in `Sigs`{.cpp} are
>    dependent on the type `Env`{.cpp}, then the expression `get_completion_signatures<Sndr>()`{.cpp} is
>    well-formed and its type is `CS`{.cpp}. [If a user-provided implementation of the algorithm
>    that produced `sndr`{.cpp} is selected instead of the default:]{.rm}
> 
>    - [[1.1]{.pnum} Any completion signature that is in the set of types denoted by
>      `completion_signatures_of_t<Sndr, Env>`{.cpp} and that is not part of `Sigs`{.cpp} shall
>      correspond to error or stopped completion operations, unless otherwise specified.]{.rm}
> 
>    - [[1.2]{.pnum} If none of the types in `Sigs`{.cpp} are dependent on the type `Env`{.cpp}, then
>      `completion_signatures_of_t<Sndr>`{.cpp} and `completion_signatures_of_t<Sndr, Env>`{.cpp} shall
>      denote the same type.]{.rm}

[Change [exec.snd.expos]{.sref} paragraph 6 as follows:]{.ednote}

> 6. For a scheduler `sch`{.cpp}, ```@_`SCHED-ATTRS`_@(sch)```{.cpp} is [an expression `o1`{.cpp} whose type
>    satisfies _`queryable`_ such that `o1.query(get_completion_scheduler<Tag>)`{.cpp} is an
>    expression with the same type and value as `sch`]{.rm} [equivalent to
>    ```@_`MAKE-ENV`_@(get_completion_scheduler<Tag>, sch)```]{.add} where `Tag`{.cpp} is one of
>    `set_value_t`{.cpp} or `set_stopped_t`[, and such that `o1.query(get_domain)`{.cpp} is
>    expression-equivalent to `sch.query(get_domain)`]{.rm}. ```@_`SCHED-ENV`_@(sch)```{.cpp} is
>    [an expression `o2`{.cpp} whose type satisfies _`queryable`_ such that
>    `o2.query(get_scheduler)`{.cpp} is a prvalue with the same type and value as `sch`{.cpp}, and
>    such that `o2.query(get_domain)`{.cpp} is expression-equivalent to
>    `sch.query(get_domain)`]{.rm} [equivalent to
>    ```@_`MAKE-ENV`_@(get_scheduler, sch)```]{.add}.

[Remove the prototype of the exposition-only _`completion-domain`_ function just before
[exec.snd.expos]{.sref} paragraph 8, and with it remove paragraphs 8 and 9, which specify
the function's behavior.]{.ednote}

[Remove [exec.snd.expos]{.sref} paragraphs 13 and 14 and the prototypes for the
_`get-domain-early`_ and _`get-domain-late`_ functions.]{.ednote}

[Remove subsection [exec.domain.default]{.sref}.]{.ednote}

[Remove subsection [exec.snd.transform]{.sref}.]{.ednote}

[Remove subsection [exec.snd.transform.env]{.sref}.]{.ednote}

[Remove subsection [exec.snd.apply]{.sref}.]{.ednote}

[Change [exec.getcomplsigs]{.sref} as follows:]{.ednote}

> 1. Let _`except`_ be an rvalue subexpression of an unspecified class type _`Except`_ such
>    that ```move_constructible<@_`Except`_@> && derived_from<@_`Except`_@, exception>```{.cpp}
>    is `true`{.cpp}. Let ```@_`CHECKED-COMPLSIGS`_@(@_`e`_@)```{.cpp} be _`e`_ if _`e`_ is
>    a core constant expression whose type satisfies _`valid-completion-signatures`_;
>    otherwise, it is the following expression:
>    
>    > ```cpp
>    > (@_`e`_@, throw @_`except`_@, completion_signatures())
>    > ```
>    
>    Let ```@_`get-complsigs`_@<Sndr, Env...>()```{.cpp} be expression-equivalent to
>    ```remove_reference_t<Sndr>​::​template get_completion_signatures<Sndr, Env...>()```{.cpp}.
>    [Let `NewSndr`{.cpp} be `Sndr`{.cpp} if `sizeof...(Env) == 0`{.cpp} is `true`;
>    otherwise, ```decltype(@_`s`_@)```{.cpp} where _`s`_ is the following expression:]{.rm}
>    [Let `NewSndr`{.cpp} be
>    ```decltype(tag_of_t<Sndr>().@_`transform-sender`_@(declval<Sndr>(), declval<Env>()...))```
>    if that expression is well-formed, and `Sndr` otherwise.]{.add}
> 
>    ::: rm
> 
>    > ```cpp   
>    > @@[```transform_sender(```]{.rm}@@
>    >   @@[```@_`get-domain-late`_@(declval<Sndr>(), declval<Env>()...),```]{.rm}@@
>    >   @@[```declval<Sndr>(),```]{.rm}@@
>    >   @@[```declval<Env>()...)```]{.rm}@@
>    > ```
> 
>    :::
> 
> 2. _Constraints_: `sizeof...(Env) <= 1`{.cpp} is `true`{.cpp}.
> 
> 3. _Effects_: Equivalent to:  [&hellip; as before &hellip;]{.blue}


[Change [exec.connect]{.sref} as follows:]{.ednote}

> 1. `connect` connects ([exec.async.ops]{.sref}) a sender with a receiver.
> 
> 2. The name `connect` denotes a customization point object. For subexpressions `sndr` and
>    `rcvr`, let `Sndr` be `decltype((sndr))` and `Rcvr` be `decltype((rcvr))`[,]{.rm}[;]{.add} let
>    `new_sndr` be the expression
>    [```transform_sender(decltype(@_`get-domain-late`_@(sndr, get_env(rcvr))){}, sndr, get_env(rcvr))```{.cpp}]{.rm}
>    [```tag_of_t<Sndr>().@_`transform-sender`_@(sndr, get_env(rcvr))```{.cpp} if that
>    expression is well-formed, and `sndr` otherwise;]{.add}
>    and let `DS` and `DR` be ```decay_t<decltype((new_sndr))>```{.cpp} and
>    `decay_t<Rcvr>`, respectively.
> 
> 3. Let _`connect-awaitable-promise`_ be
>    [&hellip; as before &hellip;]{.blue}


[From [exec.adapt.general]{.sref}, strike paragraph (3.6) as follows:]{.ednote}

> 3. Unless otherwise specified:
>
>    [&hellip; as before &hellip;]{.blue}
>
>    - [3.5]{.pnum} An adaptor whose child senders are all non-dependent
>      ([exec.async.ops]{.sref}) is itself non-dependent.
>    
>    - [3.6]{.pnum} [These requirements apply to any function that is selected by the
>      implementation of the sender adaptor.]{.rm}
>    
>    - [3.7]{.pnum} _Recommended practice_: Implementations should use the completion
>      signatures of the adaptors to communicate type errors to users and to propagate any such
>      type errors from child senders.

[Change [exec.starts.on]{.sref} paragraph 3 as follows:]{.ednote}

> 3. Otherwise, the expression `starts_on(sch, sndr)`{.cpp} is expression-equivalent to[:]{.rm}
>    [```@_`make-sender`_@(starts_on, sch, sndr)```{.cpp}.]{.add}
> 
>    ::: rm
> 
>    > ```cpp
>    > transform_sender(
>    >   @_`query-with-default`_@(get_domain, sch, default_domain()),
>    >   @_`make-sender`_@(starts_on, sch, sndr))
>    > ```
> 
>    [except that `sch` is evaluated only once.]{.rm}
> 
>    :::
>
> 4. Let `out_sndr` and `env` be subexpressions such that `OutSndr` is `decltype((out_sndr))`{.cpp}. If
>    ```@_`sender-for`_@<OutSndr, starts_on_t>``` is `false`, then the [expressions
>    `starts_on.transform_env(out_sndr, env)` and]{.rm} [expression]{.add}
>    ```starts_on.@[transform_sender]{.rm}[_`transform-sender`_]{.add}@(out_sndr, env)```
>    [are]{.rm} [is]{.add} ill-formed; otherwise [it is equivalent to:]{.add}
>
>    ::: rm
>
>    - [4.1]{.pnum} `starts_on.transform_env(out_sndr, env)` is equivalent to:
>
>      > ```cpp
>      > auto&& [_, sch, _] = out_sndr;
>      > return @_`JOIN-ENV`_@(@_`SCHED-ENV`_@(sch), @_`FWD-ENV`_@(env));
>      > ```
>
>    - [4.2]{.pnum} `starts_on.transform_sender(out_sndr, env)` is equivalent to:
>
>    :::
>
> > > ```cpp
> > > auto&& [_, sch, sndr] = out_sndr;
> > > return let_value(
> > >   schedule(sch),
> > >   [sndr = std::forward_like<OutSndr>(sndr)]() mutable
> > >     noexcept(is_nothrow_move_constructible_v<decay_t<OutSndr>>) {
> > >     return std::move(sndr);
> > >   });
> > > ```
>
> 5. Let `out_sndr` be 
>    [&hellip; as before &hellip;]{.blue}


[Remove subsection [exec.continues.on]{.sref}]{.ednote}

[Change [exec.schedule.from]{.sref} to [exec.continues.on] and change it as follows:]{.ednote}

> **33.9.12.[7]{.rm}[6]{.add} ```execution::@[`schedule_from`]{.rm}[`continues_on`]{.add}@             ```{.cpp} [exec[.schedule.from]{.rm}[.continues.on]{.add}]**
> 
> 
> 1. [`schedule_from`]{.rm}[`continues_on`]{.add} schedules work dependent on the completion
>    of a sender onto a scheduler's associated execution resource.
> 
>    [[_Note 1_:` schedule_from` is not meant to be used in user code; it is used in the
>    implementation of `continues_on`. — end note]]{.rm}
> 
> 2. The name [`schedule_from`]{.rm}[`continues_on`]{.add} denotes a customization point
>    object. For some subexpressions `sch` and `sndr`, let `Sch` be `decltype((sch))` and
>    `Sndr` be `decltype((sndr))`. If `Sch` does not satisfy scheduler, or `Sndr` does not
>    satisfy `sender`,
>    [`schedule_from(sch, sndr)`{.cpp}]{.rm}[`continues_on(sndr, sch)`{.cpp}]{.add} is
>    ill-formed.
> 
> 3. Otherwise, the expression
>    [`schedule_from(sch, sndr)`{.cpp}]{.rm}[`continues_on(sndr, sch)`{.cpp}]{.add} is
>    expression-equivalent to[:]{.rm} [```@_`make-sender`_@(continues_on, sch, sndr)```{.cpp}]{.add}
> 
>    ::: rm
> 
>    > ```cpp
>    > transform_sender(
>    >    @_`query-with-default`_@(get_domain, sch, default_domain()),
>    >    @_`make-sender`_@(schedule_from, sch, sndr))
>    > ```
> 
>    except that sch is evaluated only once.
> 
>    :::
> 
> 4. The exposition-only class template _`impls-for`_ ([exec.snd.general]{.sref}) is
>    specialized for [`schedule_from_t`]{.rm}[`continues_on_t`]{.add} as follows:
> 
>    > ```cpp
>    > namespace std::execution {
>    >    template<>
>    >    struct @_`impls-for`_@<@[`schedule_from_t`]{.rm}[`continues_on_t`]{.add}@> : @_`default-impls`_@ {
>    >       static constexpr auto @_`get-attrs`_@ = @_`see below`_@;
>    >       static constexpr auto @_`get-state`_@ = @_`see below`_@;
>    >       static constexpr auto @_`complete`_@ = @_`see below`_@;
>    >
>    >       template<class Sndr, class... Env>
>    >          static consteval void @_`check-types`_@();
>    >    };
>    > }
>    > ```
> 
> 5. The member ```@_`impls-for`_@<@[`schedule_from_t`]{.rm}[`continues_on_t`]{.add}@>​::@_`​get-attrs`_@```{.cpp}
>    is initialized with a callable object equivalent to the following lambda:
> 
>    > ```cpp
>    > [](const auto& data, const auto& child) noexcept -> decltype(auto) {
>    >    return @_`JOIN-ENV`_@(@_`SCHED-ATTRS`_@(data), @_`FWD-ENV`_@(get_env(child)));
>    > }
>    > ```
> 
> 6. The member ```@_`impls-for`_@<@[`schedule_from_t`]{.rm}[`continues_on_t`]{.add}@>​::@_`​get-state`_@```{.cpp}
>    is initialized with a callable object equivalent to the following lambda:
> 
>    [&hellip; as before &hellip;]{.blue}
> 
> > ```cpp
> > template<class Sndr, class... Env>
> >   static consteval void @_`check-types`_@();
> > ```
> 
> [&hellip; as before &hellip;]{.blue}
> 
> 12. The member ```@_`impls-for`_@<@[`schedule_from_t`]{.rm}[`continues_on_t`]{.add}@>​::@_`complete`_@```{.cpp}
>     is initialized with a callable object equivalent to the following lambda:
> 
>     [&hellip; as before &hellip;]{.blue}
> 
> 13. Let `out_sndr` be a subexpression denoting a sender returned from
>     [`schedule_from(sch, sndr)`]{.rm}[`continues_on(sndr, sch)`]{.add} or one equal to
>     such, and let `OutSndr` be the type `decltype((out_sndr))`. Let `out_rcvr` be
>     [&hellip; as before &hellip;]{.blue}


[Change [exec.on]{.sref} paragraphs 3-8 as follows:]{.ednote}


> 3. Otherwise, if `decltype((sndr))` satisfies `sender`, the expression `on(sch, sndr)` is
>    expression-equivalent to[:]{.rm} [```@_`make-sender`_@(on, sch, sndr)```{.cpp}.]{.add}
> 
>    ::: rm
> 
>    > ```cpp
>    > transform_sender(
>    >    @_`query-with-default`_@(get_domain, sch, default_domain()),
>    >    @_`make-sender`_@(on, sch, sndr))
>    > ```
> 
>    except that `sch` is evaluated only once.
> 
>    :::
> 
> 
> 4. For subexpressions `sndr`, `sch`, and `closure`, if
> 
>    - [4.1]{.pnum} `decltype((sch))` does not satisfy `scheduler`, or
> 
>    - [4.2]{.pnum} `decltype((sndr))` does not satisfy `sender`, or
> 
>    - [4.3]{.pnum} `closure` is not a pipeable sender adaptor closure object
>      ([exec.adapt.obj]), the expression `on(sndr, sch, closure)` is ill-formed;
>      otherwise, it is expression-equivalent to[:]{.rm}
>      [```@_`make-sender`_@(on, @_`product-type`_@{sch, closure}, sndr)```{.cpp}.]{.add}
> 
>      ::: rm
> 
>      > ```cpp
>      > transform_sender(
>      >    @_`get-domain-early`_@(sndr),
>      >    @_`make-sender`_@(on, @_`product-type`_@{sch, closure}, sndr))
>      > ```
> 
>      except that `sndr` is evaluated only once.
> 
>      :::
> 
> 5. Let `out_sndr` and `env` be subexpressions, let `OutSndr` be `decltype((out_sndr))`{.cpp},
>    and let `Env` be `decltype((env))`{.cpp}. If ```@_`sender-for`_@<OutSndr, on_t>```{.cpp}
>    is `false`, then the [expressions `on.transform_env(out_sndr, env)`{.cpp} and]{.rm}
>    [expression]{.add} ```on.@[`transform_sender`]{.rm}[_`transform-sender`_]{.add}@(out_sndr, env)```{.cpp}
>    [are]{.rm} [is]{.add} ill-formed.
> 
> 6. Otherwise: Let _`not-a-scheduler`_ be an unspecified empty class type.
> 
> ::: rm
> 
> 7. The expression `on.transform_env(out_sndr, env)` has effects equivalent to:
> 
>    > ```cpp
>    > auto&& [_, data, _] = out_sndr;
>    > if constexpr (scheduler<decltype(data)>) {
>    >   return @_`JOIN-ENV`_@(@_`SCHED-ENV`_@(std::forward_like<OutSndr>(data)), @_`FWD-ENV`_@(std::forward<Env>(env)));
>    > } else {
>    >   return std::forward<Env>(env);
>    > }
>    > ```
> 
> :::
> 
> 8. The expression ```on.@[`transform_sender`]{.rm}[_`transform-sender`_]{.add}@(out_sndr, env)```{.cpp}
>    has effects equivalent to:
> 
>    > ```cpp
>    > auto&& [_, data, child] = out_sndr;
>    > if constexpr (scheduler<decltype(data)>) {
>    >    auto orig_sch =
>    >       @_`query-with-default`_@(get_scheduler, env, @_`not-a-scheduler`_@());
>    > 
>    >    if constexpr (same_as<decltype(orig_sch), @_`not-a-scheduler`_@>) {
>    >       return @_`not-a-sender`_@{};
>    >    } else {
>    >       return continues_on(
>    >          starts_on(std::forward_like<OutSndr>(data), std::forward_like<OutSndr>(child)),
>    >          std::move(orig_sch));
>    >    }
>    > } else {
>    >    auto& [sch, closure] = data;
>    >    auto orig_sch = @_`query-with-default`_@(
>    >       get_completion_scheduler<set_value_t>,
>    >       get_env(child),
>    >       @_`query-with-default`_@(get_scheduler, env, @_`not-a-scheduler`_@()));
>    > 
>    >    if constexpr (same_as<decltype(orig_sch), @_`not-a-scheduler`_@>) {
>    >       return @_`not-a-sender`_@{};
>    >    } else {
>    >       return @[`write_env`]{.rm} [`continues_on`]{.add}@(
>    >          @[`continues_on`]{.rm} [`write_env`]{.add}@(
>    >             std::forward_like<OutSndr>(closure)(
>    >                continues_on(
>    >                   write_env(std::forward_like<OutSndr>(child), @_`SCHED-ENV`_@(orig_sch)),
>    >                   sch)),
>    >             @[`orig_sch`]{.rm} [`SCHED-ENV(sch)`]{.add}@),
>    >          @@```@[`SCHED-ENV(sch)`]{.rm}[`orig_sch`]{.add}@```@@);
>    >    }
>    > }
>    > ```


[Change [exec.then]{.sref} paragraph 3 as follows:]{.ednote}

> 3. Otherwise, the expression ```@_`then-cpo`_@(sndr, f)```{.cpp} is expression-equivalent
>    to[:]{.rm} [```@_`make-sender`_@(@_`then-cpo`_@, f, sndr)```{.cpp}.]{.add}
> 
>    ::: rm
> 
>    > ```cpp
>    > transform_sender(@_`get-domain-early`_@(sndr), @_`make-sender`_@(@_`then-cpo`_@, f, sndr))
>    > ```
> 
>    except that `sndr` is evaluated only once.
> 
>    :::


[Change [exec.let]{.sref} paragraphs 2-4 as follows:]{.ednote}

> 2. For `let_value`, `let_error`, and `let_stopped`, let _`set-cpo`_ be `set_value`,
>    `set_error`, and `set_stopped`, respectively. Let the expression _`let-cpo`_ be one of
>    `let_value`, `let_error`, or `let_stopped`. For a subexpression `sndr`, let
>    ```@_`let-env`_@(sndr)```{.cpp} be expression-equivalent to
>    the first well-formed expression below:
> 
>    - [2.1]{.pnum} ```@_`SCHED-ENV`_@(@_`get_completion_scheduler`_@<@_`decayed-typeof`_@<@_`set-cpo`_@>>(get_env(sndr)))```{.cpp}
> 
>    ::: rm
> 
>    - [2.2]{.pnum} ```@_`MAKE-ENV`_@(get_domain, get_domain(get_env(sndr)))```{.cpp}
> 
>    :::
> 
>    - [2.3]{.pnum} `(void(sndr), env<>{})`{.cpp}
> 
> 3. The names `let_value`, `let_error`, and `let_stopped` denote
>    [&hellip; as before &hellip;]{.blue}
> 
> 4. Otherwise, the expression ```@_`let-cpo`_@(sndr, f)```{.cpp} is expression-equivalent
>    to[:]{.rm} [```@_`make-sender`_@(@_`let-cpo`_@, f, sndr)```{.cpp}.]{.add}
> 
>    ::: rm
> 
>    > ```cpp
>    > transform_sender(@_`get-domain-early`_@(sndr), @_`make-sender`_@(@_`let-cpo`_@, f, sndr))
>    > ```
> 
>    except that `sndr` is evaluated only once.
> 
>    :::

<a name="proposed-wording-for-bulk"></a>

[Change [exec.bulk]{.sref} paragraphs 3 and 4 and insert paragraphs 5 and 6 as
follows:]{.ednote}

> 3. Otherwise, the expression ```@_`bulk-algo`_@(sndr, policy, shape, f)```{.cpp} is
>    expression-equivalent to:
> 
>    ```cpp
>    @@[```transform_sender(@_`get-domain-early`_@(sndr),```{.cpp}]{.rm}@@ @_`make-sender`_@(
>       @_`bulk-algo`_@, @_`product-type`_@<@_`see below`_@, Shape, Func>{policy, shape, f}, sndr)@[`)`]{.rm}@
>    ```
> 
>    [except that `sndr` is evaluated only once.]{.rm} The first template argument of
>    _`product-type`_ is `Policy` if `Policy` models `copy_constructible`, and `const Policy&`
>    otherwise.
> 
> 4. Let `sndr` [and `env` be subexpressions]{.rm} [be an expression]{.add} such that
>    `Sndr` is `decltype((sndr))`. If ```@_`sender-for`_@<Sndr, bulk_t>```{.cpp} is
>    `false`, then the expression [`bulk.transform_sender(sndr, env)`{.cpp}]{.rm}
>    [```@_`as-bulk-chunked`_@(sndr)```{.cpp}]{.add} is ill-formed;
>    otherwise, it is equivalent to:
> 
>    > ```cpp
>    > auto [_, data, child] = sndr;
>    > auto& [policy, shape, f] = data;
>    > auto new_f = [func = std::move(f)](Shape begin, Shape end, auto&&... vs)
>    >     noexcept(noexcept(f(begin, vs...))) {
>    >   while (begin != end)
>    >     func(begin++, vs...);
>    > }
>    > return bulk_chunked(std::move(child), policy, shape, std::move(new_f));
>    > ```
> 
>    [[This causes the `bulk(sndr, policy, shape, f)` sender to be expressed in terms
>    of `bulk_chunked(sndr, policy, shape, f)` when it is connected to a receiver [whose
>    execution domain does not customize `bulk`]{.rm}.]{.note}]{.rm}
>
> ::: add
> 
> 5. Let `sndr` and `env` be subexpressions, let `Sndr` be `decltype((sndr))`, and let
>    `sch` be expression-equivalent to
>    ```get_completion_scheduler<set_value_t>(get_env(sndr.@_`get`_@<2>()))```{.cpp}. If
>    ```@_`sender-for`_@<Sndr, @_`decayed-typeof`_@<@_`bulk-algo`_@>>```{.cpp} is `false`,
>    the expression ```@_`bulk-algo`_@.@_`transform-sender`_@(sndr, env)```{.cpp} is
>    ill-formed; otherwise, it is expression-equivalent to:
>
>    - [6.1]{.pnum} ```sch.@_`bulk-transform`_@(sndr, env)```{.cpp} if that expression is
>      well-formed, except that `sndr` is evaluated only once; otherwise,
>
>    - [6.2]{.pnum} ```sch.@_`bulk-transform`_@(@_`as-bulk-chunked`_@(sndr), env)```{.cpp}
>      if that expression is well-formed, except that `sndr` is evaluated only once;
>      otherwise,
>
>    - [6.3]{.pnum} ```@_`bulk-algo`_@.@_`transform-sender`_@(sndr, env)```{.cpp} is
>      ill-formed.
>
> :::

[Change [exec.when.all]{.sref} as follows:]{.ednote}

> 1. `when_all` and `when_all_with_variant` both [&hellip; as before &hellip;]{.blue}
> 
> 2. The names `when_all` and `when_all_with_variant` denote customization point objects.
>    Let `sndrs` be a pack of subexpressions[,]{.rm} [and]{.add} let `Sndrs` be a pack of
>    the types `decltype((sndrs))...`{.cpp}[, and let `CD` be the type
>    ```common_type_t<decltype(@_`get-domain-early`_@(sndrs))...>```{.cpp}. Let `CD2` be
>    `CD` if `CD` is well-formed, and `default_domain` otherwise]{.rm}. The expressions
>    `when_all(sndrs...)` and `when_all_with_variant(sndrs...)` are ill-formed if any of the
>    following is `true`:
> 
>    - [2.1]{.pnum} `sizeof...(sndrs)`{.cpp} is `0`{.cpp}, or
> 
>    - [2.2]{.pnum} `(sender<Sndrs> && ...)`{.cpp} is `false`{.cpp}.
> 
> 3. The expression `when_all(sndrs...)` is expression-equivalent to[:]{.rm}
>    [```@_`make-sender`_@(when_all, {}, sndrs...)```.]{.add}
> 
>    ::: rm
> 
>    > ```cpp
>    > transform_sender(CD2(), @_`make-sender`_@(when_all, {}, sndrs...))
>    > ```
> 
>    :::
> 
> 4. The exposition-only class template _`impls-for`_ ([exec.snd.general]{.sref}) is
>    specialized for `when_all_t` as follows:
> 
>    > ```cpp
>    > namespace std::execution {
>    >    template<>
>    >    struct @_`impls-for`_@<when_all_t> : @_`default-impls`_@ {
>    >       @@[```static constexpr auto @_`get-attrs`_@ = @_`see below`_@;```]{.rm}@@
>    >       static constexpr auto @_`get-env`_@ = @_`see below`_@;
>    >       static constexpr auto @_`get-state`_@ = @_`see below`_@;
>    >       static constexpr auto @_`start`_@ = @_`see below`_@;
>    >       static constexpr auto @_`complete`_@ = @_`see below`_@;
>    > 
>    >       template<class Sndr, class... Env>
>    >          static consteval void @_`check-types`_@();
>    >    };
>    > }
>    > ```
> 
> [&hellip; as before &hellip;]{.blue}
> 
> 9. _Throws_: Any exception thrown as a result of evaluating the _Effects_[, or an exception
>    of an unspecified type derived from `exception` when `CD` is ill-formed]{.rm}.
> 
> ::: rm
> 
> 10. The member ```@_`impls-for`_@<when_all_t>​::@_`​get-attrs`_@```{.vpp} is initialized
>     with a callable object equivalent to the following lambda expression:
> 
>     > ```cpp
>     > [](auto&&, auto&&... child) noexcept {
>     >    if constexpr (same_as<CD, default_domain>) {
>     >       return env<>();
>     >    } else {
>     >       return @_`MAKE-ENV`_@(get_domain, CD());
>     >    }
>     > }
>     > ```
> 
> :::
> 
> [&hellip; as before &hellip;]{.blue}
> 
> 19. The expression `when_all_with_variant(sndrs...)`{.cpp} is expression-equivalent
>     to[:]{.rm} [```@_`make-sender`_@(when_all_with_variant, {}, sndrs...)```{.cpp}.]{.add}
> 
>     ::: rm
> 
>     > ```cpp
>     > transform_sender(CD2(), @_`make-sender`_@(when_all_with_variant, {}, sndrs...));
>     > ```
> 
>     :::
> 
> 20. Given subexpressions `sndr` and `env`, if
>     ```@_`sender-for`_@<decltype((sndr)), when_all_with_variant_t>```{.cpp} is
>     `false`{.cpp}, then the expression
>     ```when_all_with_variant.@[`transform_sender`]{.rm}[_`transform-sender`_]{.add}@(sndr, env)```{.cpp}
>     is ill-formed; otherwise, it is equivalent to:
>  
>     > ```cpp
>     > auto&& [_, _, ...child] = sndr;
>     > return when_all(into_variant(std::forward_like<decltype((sndr))>(child))...);
>     > ```
>  
>     [_Note 1_: This causes the `when_all_with_variant(sndrs...)`{.cpp} sender to become
>     `when_all(into_variant(sndrs)...)`{.cpp} when it is connected with a receiver [whose
>     execution domain does not customize `when_all_with_variant`]{.rm}. — _end note_]

[Change [exec.into.variant]{.sref} paragraph 3 as follows:]{.ednote}

> 3. Otherwise, the expression `into_variant(sndr)`{.cpp} is expression-equivalent to[:]{.rm}
>    [```@_`make-sender`_@(into_variant, {}, sndr)```{.cpp}.]{.add}
> 
>    ::: rm
> 
>    > ```cpp
>    > transform_sender(@_`get-domain-early`_@(sndr), @_`make-sender`_@(into_variant, {}, sndr))
>    > ```
> 
>    except that `sndr` is only evaluated once.
> 
>    :::

[Change [exec.stopped.opt]{.sref} paragraphs 2 and 4 as follows:]{.ednote}

> 2. The name `stopped_as_optional` denotes a pipeable sender adaptor object. For a
>    subexpression `sndr`, let `Sndr` be `decltype((sndr))`{.cpp}. The expression
>    `stopped_as_optional(sndr)` is expression-equivalent to[:]{.rm}
>    [```@_`make-sender`_@(stopped_as_optional, {}, sndr)```{.cpp}.]{.add}
> 
>    ::: rm
> 
>    > ```cpp
>    > transform_sender(@_`get-domain-early`_@(sndr), @_`make-sender`_@(stopped_as_optional, {}, sndr))
>    > ```
> 
>    except that `sndr` is only evaluated once.
> 
>    ::: 
>
> 3. The exposition-only class template _`impls-for`_ [&hellip; as before &hellip;]{.blue}
>
> 4. Let `sndr` and `env` be subexpressions such that `Sndr` is `decltype((sndr))`{.cpp}
>    and `Env` is `decltype((env))`{.cpp}. If ```@_`sender-for`_@<Sndr, stopped_as_optional_t>```{.cpp}
>    is `false` then the expression
>    ```stopped_as_optional.@[`transform_sender`]{.rm}[_`transform-sender`_]{.add}@(sndr, env)```{.cpp}
>    is ill-formed; otherwise,
>    if ```sender_in<@_`child-type`_@<Sndr>, @_`FWD-ENV-T`_@(Env)>```{.cpp} is `false`, the expression
>    ```stopped_as_optional.@[`transform_sender`]{.rm}[_`transform-sender`_]{.add}@(sndr, env)```{.cpp}
>    is equivalent to ```@_`not-a-sender`_@()```{.cpp}; otherwise, it is equivalent to:
> 
>    > ```cpp
>    > auto&& [_, _, child] = sndr;
>    > using V = @_`single-sender-value-type`_@<@_`child-type`_@<Sndr>, @_`FWD-ENV-T`_@(Env)>;
>    > return let_stopped(
>    >   then(std::forward_like<Sndr>(child),
>    >         []<class... Ts>(Ts&&... ts) noexcept(is_nothrow_constructible_v<V, Ts...>) {
>    >            return optional<V>(in_place, std::forward<Ts>(ts)...);
>    >         }),
>    >   []() noexcept { return just(optional<V>()); });
>    > ```
> 

[Change [exec.stopped.err]{.sref} paragraphs 2 and 3 as follows:]{.ednote}

> 2. The name `stopped_as_error` denotes a pipeable sender adaptor object. For some
>    subexpressions `sndr` and `err`, let `Sndr` be `decltype((sndr))`{.cpp} and let `Err`
>    be `decltype((err))`. If the type `Sndr` does not satisfy `sender` or if the type
>    `Err` does not satisfy _`movable-value`_, `stopped_as_error(sndr, err)` is
>    ill-formed. Otherwise, the expression `stopped_as_error(sndr)` is
>    expression-equivalent to[:]{.rm}
>    [```@_`make-sender`_@(stopped_as_error, err, sndr)```{.cpp}.]{.add}
> 
>    ::: rm
> 
>    > ```cpp
>    > transform_sender(@_`get-domain-early`_@(sndr), @_`make-sender`_@(stopped_as_error, err, sndr))
>    > ```
> 
>    except that `sndr` is only evaluated once.
> 
>    ::: 
>
> 2. Let `sndr` and `env` be subexpressions such that `Sndr` is `decltype((sndr))`{.cpp}
>    and `Env` is `decltype((env))`{.cpp}. If ```@_`sender-for`_@<Sndr, stopped_as_error_t>```{.cpp}
>    is `false` then the expression
>    ```stopped_as_error.@[`transform_sender`]{.rm}[_`transform-sender`_]{.add}@(sndr, env)```{.cpp}
>    is ill-formed; otherwise, it is equivalent to:
> 
>    > ```cpp
>    > auto&& [_, err, child] = sndr;
>    > using E = decltype(auto(err));
>    > return let_stopped(
>    >   std::forward_like<Sndr>(child),
>    >   [err = std::forward_like<Sndr>(err)]() noexcept(is_nothrow_move_constructible_v<E>) {
>    >     return just_error(std::move(err));
>    >   });
>    > ```

[Change [exec.associate]{.sref} paragraph 10 as follows:]{.ednote}

> 10. The name `associate` denotes a pipeable sender adaptor object. For subexpressions `sndr`
>     and `token`:
> 
>     - [10.1]{.pnum} If `decltype((sndr))`{.cpp} does not satisfy `sender`, or
>       `remove_cvref_t<decltype((token))>`{.cpp} does not satisfy `scope_token`, then
>       `associate(sndr, token)` is ill-formed.
>  
>     - [10.2]{.pnum} Otherwise, the expression `associate(sndr, token)` is
>       expression-equivalent to[:]{.rm}
>       [```@_`make-sender`_@(associate, @_`associate-data`_@(token, sndr))```{.cpp}.]{.add}
>  
>       ::: rm
>  
>       > ```cpp
>       > transform_sender(@_`get-domain-early`_@(sndr),
>       >                  @_`make-sender`_@(associate, @_`associate-data`_@(token, sndr)))
>       > ```
>  
>       except that `sndr` is evaluated only once.
>
>       :::

[Change [exec.sync.wait]{.sref} paragraphs 4 and 9 as follows:]{.ednote}

> 4. The name `this_thread​::​sync_wait`{.cpp} denotes a customization point object. For a
>    subexpression `sndr`, let `Sndr` be `decltype((sndr))`{.cpp}. The expression
>    `this_thread​::​sync_wait(sndr)`{.cpp} is expression-equivalent to [the
>    following, except that `sndr` is evaluated only once:]{.rm}
>    [```sync_wait.@_`apply`_@(sndr)```{.cpp}, where _`apply`_ is the exposition-only
>    member function specified below.]{.add}
> 
>    ::: rm
> 
>    > ```cpp
>    > apply_sender(@_`get-domain-early`_@(sndr), sync_wait, sndr)
>    > ```
>    
>    :::
> 
>    _Mandates_:
> 
>    - [4.1]{.pnum} ```sender_in<Sndr, @_`sync-wait-env`_@>```{.cpp} is true.
> 
>    - [4.2]{.pnum} The type ```@_`sync-wait-result-type`_@<Sndr>```{.cpp} is well-formed.
> 
>    ::: rm
> 
>    - [4.3]{.pnum} ```same_as<decltype(@_`e`_@), @_`sync-wait-result-type`_@<Sndr>>```{.cpp}
>      is `true`, where _`e`_ is the `apply_sender` expression above.
> 
>    :::
>
> [&hellip; as before &hellip;]{.blue}
>
> 9. For a subexpression `sndr`, let `Sndr` be `decltype((sndr))`{.cpp}. If
>    ```sender_to<Sndr, @_`sync-wait-receiver`_@<Sndr>>```{.cpp} is `false`{.cpp}, the
>    expression ```sync_wait.@[`apply_sender`]{.rm}[_`apply`_]{.add}@(sndr)```{.cpp} is
>    ill-formed; otherwise, it is equivalent to:
> 
>    ```cpp
>    @_`sync-wait-state`_@<Sndr> state;
>    auto op = connect(sndr, @_`sync-wait-receiver`_@<Sndr>{&state});
>    start(op);
> 
>    state.loop.run();
>    if (state.error) {
>      rethrow_exception(std::move(state.error));
>    }
>    return std::move(state.result);
>    ```

[Change _Note 1_ in [exec.sync.wait]{.sref} paragraph 10.1 as follows:]{.ednote}

> [_Note 1_: The [default]{.rm} implementation of `sync_wait` achieves forward progress
> guarantee delegation by providing a `run_loop` scheduler via the
> `get_delegation_scheduler` query on the _`sync-wait-receiver`_'s environment. The
> `run_loop` is driven by the current thread of execution. — _end note_]


[Change [exec.sync.wait.var]{.sref} paragraphs 1 and 2 as follows:]{.ednote}

> 1. The name `this_thread​::​sync_wait_with_variant` denotes a customization point
>    object. For a subexpression `sndr`, let `Sndr` be
>    `decltype(into_variant(sndr))`{.cpp}. The expression
>    `this_thread​::​sync_wait_with_variant(sndr)`{.sref} is expression-equivalent to [the
>    following, except `sndr` is evaluated only once:]{.rm}
>    [```sync_wait_with_variant.@_`apply`_@(sndr)```{.cpp}, where _`apply`_ is the
>    exposition-only member function specified below.]{.add}
> 
>    ::: rm
> 
>    > ```cpp
>    > apply_sender(get-domain-early(sndr), sync_wait_with_variant, sndr)
>    > ```
>
>    :::
> 
>    _Mandates_:
> 
>    - [1.1]{.pnum} ```sender_in<Sndr, @_`sync-wait-env`_@>```{.cpp} is `true`{.cpp}.
> 
>    - [1.2]{.pnum} The type ```@_`sync-wait-with-variant-result-type`_@<Sndr>```{.cpp} is well-formed.
> 
>    ::: rm
>
>    - [1.3]{.pnum} ```same_as<decltype(@_`e`_@), @_`sync-wait-with-variant-result-type`_@<Sndr>>```{.cpp}
>      is `true`{.cpp}, where _`e`_ is the `apply_sender` expression above.
>
>    :::
>
> 2. The expression ```sync_wait_with_variant.@[`apply_sender`]{.rm}[_`apply`_]{.add}@(sndr)```{.cpp}
>    is equivalent to:
> 
>    > ```cpp
>    > using result_type = @_`sync-wait-with-variant-result-type`_@<Sndr>;
>    > if (auto opt_value = sync_wait(into_variant(sndr))) {
>    >   return result_type(std::move(get<0>(*opt_value)));
>    > }
>    > return result_type(nullopt);
>    > ```

[Change _Note 1_ in [exec.sync.wait]{.sref} paragraph 10.1 as follows:]{.ednote}

> [_Note 1_: The [default]{.rm} implementation of `sync_wait_with_variant` achieves
> forward progress guarantee delegation ([intro.progress]{.sref}) by relying on the
> forward progress guarantee delegation provided by `sync_wait`. — _end note_]


[Change [exec.affine.on]{.sref} paragraph 3 as follows:]{.ednote}

> 3. Otherwise, the expression `affine_on(sndr, sch)`{.cpp} is expression-equivalent
>    to[:]{.rm} [```@_`make-sender`_@(affine_on, sch, sndr)```{.cpp}.]{.add}
> 
>    ::: rm
> 
>    > ```cpp
>    > transform_sender(@_`get-domain-early`_@(sndr), @_`make-sender`_@(affine_on, sch, sndr))
>    > ```
> 
>    except that `sndr` is evaluated only once.
> 
>    :::


[Change [exec.task.scheduler]{.sref} as follows:]{.ednote}

> ```cpp
> namespace std::execution {
>   class task_scheduler {
>     @@[```class @_`ts-sender`_@;                    // exposition only```]{.rm}@@
>
>     @@[```template<receiver R>```]{.rm}@@
>       @@[```class state;                      // exposition only```]{.rm}@@
> 
>     @@[```template<class Sch>```]{.add}@@
>       @@[```class @_`backend-for`_@;              // exposition only```]{.add}@@
>   public:
>     using scheduler_concept = scheduler_t;
> 
>     template<class Sch, class Allocator = allocator<void>>
>       requires (!same_as<task_scheduler, remove_cvref_t<Sch>>) && scheduler<Sch>
>     explicit task_scheduler(Sch&& sch, Allocator alloc = {});
> 
>     @[_`ts-sender`_]{.rm}[_`see below`_]{.add}@ schedule();
> 
>     @@[```template <class Sndr, class Env>     // exposition only```]{.add}@@
>       @@[```@_`see below`_@ @_`bulk-transform`_@(Sndr&& sndr, const Env& env);```]{.add}@@
> 
>     friend bool operator==(const task_scheduler& lhs, const task_scheduler& rhs) noexcept;
> 
>     template<class Sch>
>       requires (!same_as<task_scheduler, Sch>) && scheduler<Sch>
>     friend bool operator==(const task_scheduler& lhs, const Sch& rhs) noexcept;
> 
>   private:
>     shared_ptr<@[`void`]{.rm}[`parallel_scheduler_backend`]{.add}@> sch_; // exposition only
>                                                      @[_`// see [exec.sysctxrepl.psb]`_]{.add}@
>   };
> }
> ```
> 
> 1. `task_scheduler` is a class that models `scheduler` ([exec.sched]). Given an object
>    `s` of type `task_scheduler`, let ```@_`SCHED`_@(s)```{.cpp} be [the `sched_` member
>    of]{.add} the object owned by `s.sch_`.
> 
> ::: add
>
> 2. For subexpressions `sndr` and `attrs`, let ```@_`WRITE-ATTRS`_@(sndr, attrs)```{.cpp} be an
>    object `s` such that its type satisfies `sender` and `get_env(s)` is equal to `attrs`. In
>    all other respects, `s` is equivalent to `sndr`.
>
> 3. For an lvalue `r` of type derived from `receiver_proxy`, let ```@_`WRAP-RCVR`_@(r)```{.cpp}
>    be an object of a type that models `receiver` and whose
>    completion handlers result in invoking the corresponding completion handlers of `r`.
>
> > ```cpp
> > template<class Sch>
> > struct @_`backend-for`_@ : parallel_scheduler_backend {
> >   explicit @_`backend-for`_@(Sch sch) : sched_(std::move(sch)) {}
> > 
> >   void schedule(receiver_proxy& r, span<byte> s) noexcept override;
> >   void schedule_bulk_chunked(size_t shape, bulk_item_receiver_proxy& r,
> >                              span<byte> s) noexcept override;
> >   void schedule_bulk_unchunked(size_t shape, bulk_item_receiver_proxy& r,
> >                                span<byte> s) noexcept override;
> > 
> >   Sch sched_;
> > };
> > ```
>
> > ```cpp
> > void schedule(receiver_proxy& r, span<byte> s) noexcept override;
> > ```
>
> 4. _Effects_: Constructs an operation state `os` with
>    ```connect(schedule(sched_), @_`WRAP-RCVR`_@(r))```{.cpp} and calls `start(os)`.
>
> > ```cpp
> > void schedule_bulk_chunked(size_t shape, bulk_item_receiver_proxy& r,
> >                            span<byte> s) noexcept override;
> > ```
>
> 5. _Effects_: Let `sndr` be
>    ```@_`WRITE-ATTRS`_@(just(), @_`MAKE-ENV`_@(get_completion_scheduler<set_value_t>, sched_))```{.cpp}, let `chunk_size` be an integer less than or equal to `shape`, let `num_chunks` be
>    `(shape + chunk_size - 1) / chunk_size`, and let `fn` be a function object such that
>    for an integer `i`, `fn(i)` calls `r.execute(i * chunk_size, m)`, where `m` is the
>    lesser of `(i + 1) * chunk_size` and `shape`.
>    Constructs an operation state `os` as if with
>    ```connect(bulk(sndr, par, num_chunks, fn), @_`WRAP-RCVR`_@(r))```{.cpp} and calls `start(os)`.
>
> > ```cpp
> > void schedule_bulk_unchunked(size_t shape, bulk_item_receiver_proxy& r,
> >                              span<byte> s) noexcept override;
> > ```
>
> 6. _Effects_: Let `sndr` be
>    ```@_`WRITE-ATTRS`_@(just(), @_`MAKE-ENV`_@(get_completion_scheduler<set_value_t>, sched_))```{.cpp}.
>    and let `fn` be a function object such that for an integer `i`, `fn(i)` is equivalent to
>    `r.execute(i, i + 1)`. Constructs an operation state `os` as if with
>    ```connect(bulk(sndr, par, shape, fn), @_`WRAP-RCVR`_@(r))```{.cpp} and calls `start(os)`.
>
> :::
>
> > ```cpp
> > template<class Sch, class Allocator = allocator<void>>
> >   requires(!same_as<task_scheduler, remove_cvref_t<Sch>>) && scheduler<Sch>
> > explicit task_scheduler(Sch&& sch, Allocator alloc = {});
> > ```
> 
> 2. _Effects_: Initialize `sch_` with
>    ```allocate_shared<@[_`backend-for`_<]{.add}@remove_cvref_t<Sch>@[`>`]{.add}@>(alloc,​ std​::​forward<Sch>​(sch))```{.cpp}.
>
> [Paragraphs 3-7 are kept unmodified. Remove paragraphs 8-12 and add the following
> paragraphs:]{.ednote}
>
> ::: add
>
> ```cpp
> @_`see below`_@ schedule();
> ```
>
> 8. _Returns_: a prvalue `sndr` whose type `Sndr` models `sender` such that:
>
>    - [8.1]{.pnum} `get_completion_scheduler<set_value_t>(get_env(sndr))` is equal to `*this`.
>
>    - [8.2]{.pnum} `get_completion_signatures<Sndr>()` is expression-equivalent to:
>
>      > ```cpp
>      > completion_signatures<set_value_t(), set_error_t(exception_ptr), set_stopped_t()>()
>      > ```
>
>   - [8.3]{.pnum} For some receiver `rcvr` such that `receiver_of<decltype((rcvr)), completion_signatures_of_t<Sndr>>`
>     is `true`, `connect(sndr, rcvr)` returns an operation state `op` such that `start(op)`
>     calls `sch_->schedule(r, s)`, where
>
>     - [8.3.1]{.pnum} `r` is a proxy for `rcvr` with base 
>       `system_context_replaceability​::​receiver_proxy` ([exec.par.scheduler]{.sref}) and
>
>     - [8.3.2]{.pnum} `s` is a preallocated backend storage for `r`.
>
> ```cpp
> template <class Sndr, class Env>     // exposition only
>   @_`see below`_@ @_`bulk-transform`_@(Sndr&& sndr, const Env& env);
> ```
>
> 9. _Constraints_: `sender_in<Sndr, Env>` is `true` and either ```@_`sender-for`_@<Sndr, bulk_chunked_t>```{.cpp} or ```@_`sender-for`_@<Sndr, bulk_unchunked_t>```{.cpp} is `true`.
>
> 9. _Returns_: a prvalue `sndr` whose type
> 
> :::


[TODO: finish me]{.ednote}


[Change [exec.task]{.sref} as follows:]{.ednote}

[**TODO**]{.blue}


<a name="proposed-wording-for-parallel-scheduler"></a>

[In [exec.par.scheduler]{.sref}, add a new paragraph before paragraph 10, and change
paragraphs 10 and 11 as follows:]{.ednote}

> ::: add
>
> [?.]{.npnum} Let `sch` be a subexpression of type `parallel_scheduler`. For subexpressions `sndr`
>     and `env`, if `tag_of_t<Sndr>` is neither `bulk_chunked_t` nor `bulk_unchunked_t`, the
>     expression ```sch.@_`bulk-transform`_@(sndr, env)```{.cpp} is ill-formed; otherwise,
>     let `child`, `pol`, `shape`, and `f` be subexpressions equal to the arguments used to
>     create `sndr`.
>
> :::
>
> 10. [`parallel_scheduler` provides a customized implementation of the `bulk_chunked`
>     algorithm ([exec.bulk]{.sref}). If a receiver `rcvr` is connected to the sender
>     returned by `bulk_chunked(sndr, pol, shape, f)`{.cpp}]{.rm} [When the tag type of
>     `sndr` is `bulk_chunked_t`, the expression
>     ```sch.@_`bulk-transform`_@(sndr, env)```{.cpp} returns a sender `new_sndr` such
>     that if it is connected to a receiver `rcvr`]{.add} and the resulting operation
>     state is started, then:
> 
>     - [10.1]{.pnum} If [`sndr`]{.rm}[`child`]{.add} completes with values `vals`, let
>       `args` be a pack of lvalue subexpressions designating `vals`, then
>       `b.schedule_bulk_chunked(shape, r, s)`{.cpp} is called, where
> 
>       - [10.1.1]{.pnum} `r` is a bulk chunked proxy for `rcvr` with callable `f` and
>         arguments `args` and
> 
>       - [10.1.2]{.pnum} `s` is a preallocated backend storage for `r`.
> 
>     - [10.2]{.pnum} All other completion operations are forwarded unchanged.
> 
>     [Customizing the behavior of `bulk_chunked` affects the [default]{.rm}
>     implementation of `bulk`.]{.note}
> 
> 11. [`parallel_scheduler` provides a customized implementation of the `bulk_unchunked`
>     algorithm ([exec.bulk]{.sref}). If a receiver `rcvr` is connected to the sender
>     returned by `bulk_unchunked(sndr, pol, shape, f)`{.cpp}]{.rm} [When the tag type of
>     `sndr` is `bulk_unchunked_t`, the expression
>     ```sch.@_`bulk-transform`_@(sndr, env)```{.cpp} returns a sender `new_sndr` such
>     that if it is connected to a receiver `rcvr`]{.add} and the resulting operation
>     state is started, then:
> 
>     - [11.1]{.pnum} If [`sndr`]{.rm}[`child`]{.add} completes with values `vals`, let
>       `args` be a pack of lvalue subexpressions designating `vals`, then
>       `b.schedule_bulk_unchunked(shape, r, s)`{.cpp} is called, where
> 
>       - [11.1.1]{.pnum} `r` is a bulk unchunked proxy for `rcvr` with callable `f` and
>         arguments `args` and
> 
>       - [11.1.2]{.pnum} `s` is a preallocated backend storage for `r`.
> 
>     - [11.2]{.pnum} All other completion operations are forwarded unchanged.














[THIS SECTION IS INCOMPLETE]{.ednote}
