---
title: "Defer Sender Algorithm Customization to Post-C++26"
document: D3826R0
date: today
audience:
  - "SG1 Concurrency and Parallelism Working Group"
  - "LEWG Library Evolution Working Group"
  - "LWG Library Working Group"
author:
  - name: Eric Niebler
    email: <eric.niebler@gmail.com>
toc: true
---

# Background

In the current Working Draft, [exec]{.sref} has sender algorithms that are customizable.
While the sender/receiver concepts and the algorithms themselves have been stable for
several years now, the customization mechanism has seen a fair bit of recent churn.
[@P3718R0] is the latest effort to shore up the mechanism. Unfortunately, there are gaps
in its proposed resolution. This paper details those gaps.

The problem and its solution are easy to describe, but the changes are not trivial. The
fix has been implemented once, and another independent implementation is in progress at
the time of writing. This paper proposes to fix the issue for C++26. Should the fix be
deemed too risky, this paper also offers guidance on how to remove the ability to customize sender
algorithms for C++26 in a way that permits us to add it back in C++29.

# The problem with P3718

[@P3718R0] identifies real problems with the status quo of sender algorithm customization.
It proposes using information from the sender about where it will *complete* during
"early" customization, which happens when a sender algorithm constructs and returns a
sender; and it proposes using information from the receiver about where the operation will
*start* during "late" customization, when the sender and the receiver are connected.

The problem with this separation of responsibilities is:

<center>**Many senders do not know where they will complete until they know where they will be
started.**</center>

A simple example is the `just()`{.cpp} sender; it completes inline wherever it is started.
The information about where a sender will start is not known during early customization,
when the sender is being asked for this information.

And even if we knew where the sender will start, there is no generic interface for asking
a sender where it will complete _given where it will start_. There currently is no such
API, which is the whole problem in a nutshell.

## An illustrative example

This section illustrates the above problem by walking through the algorithm selection
process proposed by P3718. Consider the following example:

> ```cpp
> namespace ex = std::execution;
> auto sndr = ex::starts_on(_gpu, e_x::just()) | ex::then(fn);
> std::this_thread::sync_wait(std::move(sndr));
> ```

... where `_gpu`{.cp_p} is a scheduler that runs work (unsurprisingly) on a GPU.

`fn`{.cpp} will execute on the GPU, so a GPU implementation of `then`{.cpp} should be used. By the
proposed resolution of P3718, algorithm customization proceeds as follows:

* During early customization, when `starts_on(_gpu, jus_t()) | then(fn)`{.cpp} is executing,
  the `then`{.cpp} CPO asks the `starts_on(_gpu, jus_t())`{.cpp} sender where it will complete
  as if by:

  > ```cpp
  > auto&& @_`tmp1`_@ = ex::starts_on(_gpu, e_x::just());
  > auto @_`dom1`_@ = ex::get_domain(ex::get_env(@_`tmp1`_@));
  > ```

* The `starts_on`{.cpp} sender will in turn ask the `just()`{.cpp} sender, as if by:

  > ```cpp
  > auto&& @_`tmp2`_@ = ex::just();
  > auto @_`dom2`_@ = ex::get_domain(ex::get_env(@_`tmp2`_@));
  > ```

  As discussed, the `just()`{.cpp} sender doesn't know where it will complete until
  it knows where it will be started, but that information is not yet available. As a
  result, _`dom2`_ ends up as `default_domain`{.cpp}, which is then reported as the domain
  for the `starts_on`{.cpp} sender. That's incorrect. The `starts_on`{.cpp} sender will
  complete on the GPU.

* The `then`{.cpp} CPO uses `default_domain`{.cpp} to find an implementation of the
  `then`{.cpp} algorithm, which will find the default implementation. As a result, the
  `then`{.cpp} CPO returns an ordinary `then`{.cpp} sender.

* When that `then`{.cpp} sender is connected to `sync_wait`{.cpp}'s receiver, late
  customization happens. `connect`{.cpp} asks `sync_wait`{.cpp}'s receiver where the
  `then`{.cpp} sender will be started. It does that with the query
  `get_domain(get_env(rcvr))`{.cpp}. `sync_wait`{.cpp} starts operations on the current
  thread, so the `get_domain`{.cpp} query will return `default_domain`{.cpp}. As with
  early customization, late customization will also not find a GPU implementation.

The end result of all of this is that a default (which is effectively a CPU)
implementation will be used to evaluate the `then`{.cpp} algorithm on the GPU. That is a
bad state of affairs.


<!--

## The issue, conceptually

The section above shows in detail how the rules for algorithm customization go awry.
Now let's zoom out and describe the problem more generally.

A sender expression represents a task graph, the nodes of which are asynchronous
operations. Every async operation is started on some execution context, the _starting
context_, and completes on another execution context, the _completing context_. The two
might be the same, but that's irrelevant.

::: callout

[Note]{.callout-header} [This is a simplification. Some senders like
`when_all` can complete on one of several contexts. We solve that problem with domains as
described below.]{.callout-content}

:::

Imagine we assign each execution resource a color. The mission then is to paint every node
in the task graph with the colors of its starting and completing contexts. Once we know
where each operation will start and complete, we can use that information to pick the
right algorithm implementation.

In regards to customization, each color can be thought to represent not an individual
execution resource, but rather a set of algorithm implementations. Two different execution
resources might use the same set of algorithm implementations, so they would have the same
"color". In fact, most execution resources will use the default set of algorithm
implementations, in which case they all have the same color.

That's not always the case though. A thread pool would not want to use the default
implementation of `bulk` for example, which is serial. The thread pool would have
a different color corresponding to its set of preferred algorithm implementations.

In `std::execution` today, this notion of color is called a "domain". A domain is a tag
type that is used to select a set of algorithm implementations. Schedulers, which are
stand-ins for execution resources, advertize their domain with the `get_domain` query.

-->


# Solutions considered

Here is a list of possible ways to address this problem for C++26, sorted in descending
awfulness.

## Remove all of the C++26 `std::execution` additions

Although the safest option, I hope most agree that such a drastic step is not warranted by
this issue. Pulling the `sender` abstraction and everything that depends on it would result
in the removal of:

- The sender/receiver-related concepts and customization points, without which
  the ecosystem will have no shared async abstraction, and which will set back the
  adoption of structured concurrency three years.

- The sender algorithms, which capture common async patterns and make them reusable,

- `execution::counting_scope` and `execution::simple_counting_scope`, and related
  features for incremental adoption of structured concurrency,

- `execution::parallel_scheduler` and all of its related APIs, and

- `execution::task` and `execution::task_scheduler` (C++26 will _still_
  not have a standard coroutine task type <small><em>&lt;heavy sigh&gt;</em></small>).

This option should only be considered if all the other options are determined to have
unacceptable risk.

## Remove all of the customizable sender algorithms

This option would keep all of the above library components with the exception of the
customizable sender algorithms:

- `then`, `upon_error`, `upon_stopped`
- `let_value`, `let_error`, `let_stopped`
- `bulk`, `bulk_chunked`, `bulk_unchunked`
- `starts_on`, `continues_on`, `on`
- `when_all`, `when_all_with_variant`
- `stopped_as_optional`, `stopped_as_error`
- `into_variant`
- `sync_wait`
- `affine_on`

This would leave users with no easy standard way to start work on a given execution
context, or transition to another execution context, or to execute work in parallel,
or to wait for work to finish.

In fact, without the `bulk` algorithms, we leave no way for the `parallel_scheduler`
to execute work in parallel!

While still delivering a standard async abstraction with minimal risk, the loss of the
algorithms would make it _just_ an abstraction. Like coroutines, adoption of senders as an
async _lingua franca_ will be hampered by lack of standard library support.

## Remove sender algorithm customization

In this option, we ship everything currently in the Working Draft but remove the ability to
customize the algorithms. This gives us a free hand to design a better customization
mechanism for C++29 -- provided we have confidence that those new customization hooks
can be added without break existing behavior.

This option is not as low-risk as it may seem. Firstly, it is difficult to be confident
that algorithm customization can be added back without breaking code. Improved
customization hooks have been implemented, and wording for the removal has been written,
to the best of the author's ability, such that that the new hooks can be standardized
without breaking changes. 

Secondly, algorithm customizability is a load-bearing feature. Taking it out is not hard
but it isn't trivial either. Customizability is used by the `parallel_scheduler` to
accelerate the `bulk` family of algorithms. Although the `task_scheduler` does not
currently customize `bulk`, it should. Some design work is necessary before algorithm
customization can be removed.

The section [](#implications-of-removal) describes the effects and possible remedies of
the removal option.

## Ship everything as-is and fix algorithm customization in a DR

This option is not as reckless as it sounds. We have a fix and the fix has been
implemented in a working and publicly available `execution` library
([CCCL](https://github.com/NVIDIA/cccl)). It would not be the first time the Committee
shipped a standard with known defects, and the DR process exists for just this purpose.

One potential problem is that, as DRs go, this one would be large-ish. I do not
know if this presents a problem procedurally. If it does, then fixing the problem
now would make more sense. Any future DRs are likely to be smaller.

## Fix algorithm customization now

This is the option this paper proposes. The fix is easy to describe:

<center>**When asking a sender where it will complete, _tell it where it will start_.**</center>

That is done by passing the receiver's environment when asking the sender for its
completion domain. Instead of `get_domain(get_env(sndr))`, the query would be
`get_domain(get_env(sndr), get_env(rcvr))` (but with a query other than
`get_domain`, read on).

That change has some ripple effects, the biggest of which is that the receiver is not
known during early customization. Therefore, early customization is irreparably broken and
must be removed.

::: callout

[There are no algorithms in `std::execution` that are effected by the removal of early
customization since they all do their work lazily. Should a future algorithm be added that
eagerly connects a sender, that algorithm should accept an optional execution environment
by which users can provide the starting domain. That is not onerous.]{.callout-content}

:::

There are other ripples from the proposed change. They are described in full detail in
section [](#the-fix).

This fix has been implemented in NVIDIA's [CCCL](https://github.com/NVIDIA/cccl) library.
At the time of writing a second implementation is being developed independently for
[stdexec](https://github.com/NVIDIA/stdexec), the `std::execution` reference
implementation with an eye to having a few months deployment experience prior to the
upcoming London meeting.

There are risks with trying to fix the problem now. It is a design change happening
uncomortably close to the release of C++26. One mitigating factor is that it is unlikely
that the fix would make things more broken than they already are. If there are lingering
problems, they could be fixed with the usual DR process.

# The fix

Selecting the right implementation of an algorithm requires requires two things:

1. Identifying the starting and completing domain of the algorithm's async operation, and

2. Using that information to select the preferred implementation for the algorithm
   that operation represents.

Let's take these two separately.

## Determining the starting and completing domains

As described in [](#fix-algorithm-customization-now), so-called "early" customization,
which determines the return type of `then(sndr, fn)` for example, is irreparably broken.
It needs the sender to know where it will complete, which it can't in general.

So the first step is to remove early customization. There is no plan to add it back later.

That leaves "late" customization, which is performed by the `connect` customization point.
The receiver, which is an extension of caller, knows where the operation will start.
If the sender is given this information -- that is, if the sender is told where it will
start -- it can accurately report where it will complete. This is the key insight.

When `connect` queries a sender's attributes for its completion domain, it should pass the
receiver's environment. That way a sender has all available information when computing
its completion domain.

### `get_completion_domain`

It is sometimes the case that a sender's value and error completions can happen on
different domains. For example, imagine trying to schedule work on a GPU. If it succeeds,
you are in the GPU domain, Bob's your uncle. If scheduling fails, however, the error
cannot be reported on the GPU because we failed to make it there!

So asking a sender for a singular completion domain is not flexible enough.

When asking for a completion _scheduler_, we have three queries, one for each completion
disposition: `get_completion_scheduler<set_[value|error|stopped]_t>`. Similarly, we should
have three separate queries for a sender's completion domain:
`get_completion_domain<set_[value|error|stopped]_t>`.

::: callout

[ASIDE]{.callout-header} [If we have the `get_completion_scheduler` queries, why do we need
`get_completion_domain`? We can ask the completion scheduler for its domain, right? The
answer is that there are times when a sender's completion domain is knowable but the
completion scheduler is not. E.g., `when_all(s1, s2)`{.cpp} completes on the completion
scheduler of either `s1` or `s2`, so its completion scheduler is indeterminate.
But if `s1` and `s2` have the same completion _domain_, then we know that `when_all`
will complete in that domain.]{.callout-context}

:::

The addition of the completion domain queries creates a nice symmetry as shown in the
table below (with additions in green):

|                     | Receiver        |  Sender   |
|---------------------|-----------------|-----------|
| Query for scheduler | `get_scheduler` | `get_completion_scheduler<set_value_t>`<br/>`get_completion_scheduler<set_error_t>`<br/>`get_completion_scheduler<set_stopped_t>`  |
| Query for domain    | `get_domain`    | [`get_completion_domain<set_value_t>`<br/>`get_completion_domain<set_error_t>`<br/>`get_completion_domain<set_stopped_t>`]{.green} |

For a sender `sndr` and an environment `env`, we can get the sender's completion domain
as follows:

> ```cpp
> auto completion_domain = get_completion_domain<set_value_t>(get_env(sndr), env);
> ```

A sender like `just()` would implement this query as follows:

> ```cpp
> struct just_attrs
> {
>   auto query(get_completion_domain_t<set_value_t>, const auto& env) const noexcept
>   {
>     // an inline sender completes where it starts. the domain of the environment is where
>     // the sender will start, so return that.
>     return get_domain(env);
>   }
>   //...
> };
>
> template <class... Values>
> struct just_sender
> {
>   //...
>   auto get_env() const noexcept
>   {
>     return just_attrs{};
>   }
>   //...
> };
> ```

::: callout

[Note]{.callout-header} [A query that accepts an additional argument is novel in
`std::execution`, but the query system was designed to support this usage. See
[exec.queryable.concept]{.sref}.]{.callout-content}

:::

Just as the `get_completion_domain` queries accept an optional `env` argument, so
too should the `get_completion_scheduler` queries.


### Dispatching in `connect`

With the addition of the `get_completion_domain<...>` queries that can accept the
receiver's environment, `connect` can now know the starting and completing domains of the
async operation it is constructing. When passed arguments `sndr` and `rcvr`, the starting
domain is:

> ```c++
> // Get the operation's starting domain:
> auto starting_domain = get_domain(get_env(rcvr));
> ```

To get the completion domain (when the operation completes successfully):

> ```c++
> // Get the operation's completion domain for the value channel:
> auto completion_domain = get_completion_domain<set_value_t>(get_env(sndr), get_env(rcvr));
> ```

Now `connect` has all the information it needs to select the correct algorithm
implementation. Great!

But this presents the `connect` function with a dilemna: how does it use _two_ domains to
pick _one_ algorithm implementation?

Consider that the starting domain might want a say in how `start` works, and the
completing domain might want a say in how `set_value` works. So should we let the starting
domain customize `start` and the completing domain customize `set_value`?

No. `start` and `set_value` are bookends around an async operation; they must match. Often
`set_value` needs state that is set up in `start`. Customizing the two independently is
madness.

### Solving the double-dispatch problem

The solution is to use sender transforms. Each domain can apply its transform in turn. I
do not have reason to believe the order matters, but it is important that when asked to
transform a sender, a domain knows whether it is the "starting" domain or the "completing"
domain.

Here is how a domain might customize `bulk` when it is the completing domain:

> ```cpp
> struct thread_pool_domain
> {
>   template <@_`sender-for`_@<bulk_t> Sndr, class Env>
>   auto transform_sender(set_value_t, Sndr&& sndr, const Env& env) const
>   {
>     //...
>   }
> };
> ```

Since it has `set_value_t` as its first argument, this transform is only applied when
`thread_pool_domain` is an operation's completion domain. Had the first argument been
`start_t`, the transform would only be used when `thread_pool_domain` is a starting
domain.

### `transform_sender`

In this proposed design, the `connect` CPO does a few things:

1. Determines the starting and completing domains,

2. Applies the completing domain's transform (if any),

3. Applies the starting domain's transform (if any) to the resulting sender,

4. Connnects the twice-transformed sender to the receiver.

The first three steps are doing something different than connecting a sender and receiver,
so it makes sense to factor them out into their own utility. As it so happens we already
have such a utility: `transform_sender`.

The proposal requires some changes to how `transform_sender` operates. This new
`transform_sender` still accepts a sender and an environment, but it no longer accepts a
domain. It computes the two domains and applies the two transforms, recursing if a
transform changes the type of the sender.

A possible implementation of `transform_sender` is listed in
[](#appendix-a-listing-for-updated-transform_sender).

With the definition of `transform_sender` in Appendix A, `connect(sndr, rcvr)` is
equivalent to `transform_sender(sndr, get_env(rcvr)).connect(rcvr)`.


### Revisiting the problematic example

Let's see how this new approach addresses the problems noted in the motivating example
[above](#an-illustrative-example). The troublesome code is:

> ```cpp
> namespace ex = std::execution;
> auto sndr = ex::starts_on(_gpu, e_x::just()) | ex::then(fn);
> std::this_thread::sync_wait(std::move(sndr));
> ```

[](#an-illustrative-example) describes how the current design and the "fixed" one proposed
in [@P3718R0] go off the rails while determining the domain in which the function `fn`
will execute, causing it to use a CPU implementation instead of a GPU one.

In the new design, when the `then` sender is being connected to `sync_wait`'s receiver,
the starting domain will still be the `default_domain`, but when asking the sender where
it will complete, the answer will be different. Let's see how:

* When asked for its completion domain, the `then` sender will ask the `starts_on` sender
  where it will complete, as if by:

  > ```cpp
  > auto& [_, fn, child1] = *this; // *this is a then sender
  >                                // child1 is a starts_on sender
  > auto dom1 = ex::get_completion_domain<ex::set_value_t>(ex::get_env(child1), ex::get_env(rcvr));
  > ```

* In turn, the `starts_on` sender asks the `just` sender where it will complete,
  _telling it where it will start_. (This is the new bit.) It looks like:

  > ```cpp
  > auto& [_, sch, child2] = *this;  // *this is a starts_on sender
  >                                  // child2 is a just sender
  > // ask for the scheduler's completion domain:
  > auto sch_dom = ex::get_completion_domain<ex::set_value_t>(sch, get_env(rcvr));
  > // construct an env that reflects the fact that child2 will be started on sch:
  > auto env2 = ex::env{ex::prop{ex::get_scheduler, sch},
  >                     ex::prop{ex::get_domain, sch_dom},
  >                     ex::get_env(rcvr)};
  > // pass the new env when asking child2 for its completion domain:
  > auto dom2 = ex::get_completion_domain<ex::set_value_t>(ex::get_env(child2), env2);
  > ```

* The `just`{.cpp} sender, when asked where it will complete, will respond with the domain
  on which it is started. In other words,
  `get_completion_domain<set_value_t>(get_env(just()), env2)` will return
  `get_domain(env2)`, which is _`sch-dom`_.

* Having correctly determined that the `then` sender will start on the default domain
  and complete on the GPU domain, `connect` can select the right implementation for the
  `then` algorithm. It does that by calling:

  > ```cpp
  > return ex::transform_sender(sndr, ex::get_env(rcvr)).connect(rcvr);
  > ```

  The `transform_sender` call will execute the following (simplified):

  > ```cpp
  > ex::default_domain().transform_sender(
  >   ex::start,
  >   gpu_domain().transform_sender(ex::set_value, sndr, ex::get_env(rcvr)),
  >   ex::get_env(rcvr))
  > ```

  where `gpu_domain` is the domain of the `gpu` scheduler. The `default_domain` does not
  apply any transformation to `then` senders, so this expression reduces to:

  > ```cpp
  > gpu_domain().transform_sender(ex::set_value, sndr, ex::get_env(rcvr))
  > ```

  So, in the new customization scheme, the GPU domain gets a crack at transforming the
  `then` sender before it is connected to a receiver, as it should.


### Customizing `continues_on` and `schedule_from`

One of the uglier parts of the current algorithm customization design is that it needs
special case handling for the `continues_on` and `schedule_from` algorithms. The proposed
design gives us an opportunity to clean this up significantly.

#### Background

In order to transition between two execution contexts, each of which may know nothing
about the other, it is necessary to do it in two steps: a transition _from_ a context to
the default domain, and a transition from the default domain _to_ another context. A
scheduler can customize either or both of these two steps by customizing the
`continues_on` and `schedule_from` algorithms.

The customization of `continues_on` is found using the completion domain of `sndr`, making
it the sanctioned way to transition _off of_ a context. `schedule_from` finds its
customization using the domain of `sch`, making it useful for transitioning _onto_ a
context.

When not customized, connecting the sender `continues_on(sndr, sch)` performs a switcheroo
and connects `schedule_from(sch, sndr)` instead. In that way, both the source and
destination contexts get a say in how the execution transfer is mediated.

But how does that switcheroo happen? Asking `continues_on(sndr, sch)` for its completion
domain will yield the domain of `sch`, but `continues_on` wants to use the completion
domain of `sndr`. The usual `transform_sender` mechanism does not seem to cut it.

This is handled in the current draft wording by making `continues_on` a special case in
`transform_sender`. In [@P3718R0], the special casing is replaced with a
`get_domain_override` attribute query, by which the `continues_on` sender can force
`transform_sender` to use a different domain.

Both of these solutions are hacks.

#### A simplification

A better way to solve this problem is to devide responsibilities differently
between `continues_on` and `schedule_from`. Suppose that only `continues_on`
transfers execution, and `schedule_from` does nothing and only exists so it
can be customized. The `continues_on` customization point would look like:

```c++
constexpr @_`pipeable-adaptor`_@ continues_on =
  []<class Sndr, class Sch>(this auto self, Sndr&& sndr, Sch sch)
  {
    return @_`make-sender`_@(self, sch, schedule_from(forward<Sndr>(sndr)));
  };
```

The `schedule_from` customization point would look like this:

```c++
constexpr auto schedule_from =
  []<class Sndr>(this auto self, Sndr&& sndr)
  {
    return @_`make-sender`_@(self, {}, forward<Sndr>(sndr));
  };
```

Semantically, `schedule_from(sndr)` is equivalent to `sndr`. Crucially, that means that
`schedule_from(sndr)` has the same completion domain as `sndr`. And that makes
`schedule_from` a great way to customize how to transition _off of_ an execution context.

On the other hand, `continues_on(sndr, sch)` completes on the domain of `sch`, making it a
great way to customize how to transition _onto_ an execution context.

By splitting `continues_on` and `schedule_from` in this way, we obviate the need for any
special cases or domain overrides. The usual `transform_sender` mechanism is sufficient.

In the [CCCL](https://github.com/NVIDIA/cccl) project, I have implemented this design
and ported my CUDA stream scheduler to use it. I needed to customize `schedule_from`
for the CUDA stream scheduler to mediate the execution transfer from the GPU back to the
CPU. Besides the `bulk` algorithms, `schedule_from` is the only algorithm the GPU
scheduler needs to customize.

::: callout

[NOTE]{.callout-title} [Carving the two algorithms this way flips how they are dispatched.
`continues_on` now dispatches based on the domain of `sch`, and `schedule_from` on
the completion domain of the predecessor sender. The author believes this is a far
more sensible arrangement.]{.callout-content}

:::

### `inline_scheduler`

The suggestion above to extend the `get_completion_scheduler<*>` query presents an
intriguing possibility for the `inline_scheduler`: the ability for it to report the
scheduler on which its scheduling operations complete!

Consider the sender `schedule(inline_scheduler())`. Ask it where it completes today and it
will say, "I complete on the `inline_scheduler`.", which isn't terribly useful. However, if
you ask it, "Where will you complete -- and by the way you will be started on the
`parallel_scheduler`?", now that sender can report that it will complete on the
`parallel_scheduler`.

The result is that code that uses the `inline_scheduler` will no longer cause the
_actual_ scheduler to be hidden.

This realization is the motivation behind the change to strike the
`get_completion_scheduler<set_value_t>(get_env(schedule(sch)))` requirement from the
`scheduler` concept. We want that expression to be ill-formed for the `inline_scheduler`.
Instead, we want the following query to be well-formed:

> ```cpp
> get_completion_scheduler<set_value_t>(get_env(schedule(inline_scheduler())), get_env(rcvr))
> ```

That expression should be equivalent to `get_scheduler(get_env(rcvr))`, which says that
the sender of `inline_scheduler` completes wherever it is started.


## The procedure for the fix

The steps for fixing algorithm customization are detailed below.

#. Remove the uses of `transform_sender` in the sender adaptor algorithm customization
   points ([exec.adapt]{.sref}). Directly return the result of calling _`make-sender`_
   rather than passing it to `transform_sender`.

#. Remove the exposition-only helpers:

   * _`completion-domain`_ ([exec.snd.expos]{.sref}/8-9),
   * _`get-domain-early`_ ([exec.snd.expos]{.sref}/13), and
   * _`get-domain-late`_ ([exec.snd.expos]{.sref}/14).

#. Add the `get_completion_domain` queries:

   * `get_completion_domain<set_value_t>`
   * `get_completion_domain<set_error_t>`
   * `get_completion_domain<set_stopped_t>`

#. Change the `get_completion_scheduler` queries to accept an optional environment
   argument.

#. Make the `get_domain(env)` query smarter by falling back to the current scheduler's
   domain if `env.query(get_domain)` is ill-formed, and falling back further to
   `default_domain()` if `env` does not have a current scheduler.

#. Restore the ability of `env<...>::query` to accept additional arguments.

#. Rename the current `schedule_from` algorithm to `continues_on` and change it to return
   ```@_`make-sender`_@(continues_on, sch, schedule_from(sndr))```, where `schedule_from`
   is a new algorithm such that `schedule_from(sndr)` is equivalent to
   ```@_`make-sender`_@(schedule_from, {}, sndr)```.

#. Remove the (unused) `transform_env` function and the `transform_env` members
   of the sender algorithm CPOs and from `default_domain`.

#. Change `transform_sender` from `transform_sender(Domain, Sndr, Env...)` to
   `transform_sender(Sndr, Env)`. Have it compute the sender's starting and
   completing domains and apply their transforms to `Sndr` as shown in
   [](#appendix-a-listing-for-updated-transform_sender).

#. Update the usages of `transform_sender` in `connect` and `get_completion_signatures` to
   reflect its new signature.

#. For the `transform_sender` member functions in the sender algorithm CPOs, add
   `set_value_t,` in the front of their parameter list. Parameterize the
   `transform_sender` member in `default_domain` with a leading `Tag` parameter.

#. Update the attributes of the sender algorithms to properly report their completion
   schedulers and completion domains given an optional `env` argument. Also update
   the `inline_scheduler` and its schedule-sender to compute their completion
   scheduler and domain from the extra `env` argument.

#. From the `scheduler` concept, replace the required expression

   > ```cpp
   > { auto(get_completion_scheduler<set_value_t>(get_env(schedule(std::forward<Sch>(sch))))) }
   >     -> same_as<remove_cvref_t<Sch>>;
   > ```

   with a semantic requirement that _if_ the above expression is well-formed -- which it
   is for the `parallel_scheduler`, the `task_scheduler`, and `run_loop`'s scheduler --
   then it shall compare equal to `sch`. (See [](#inline_scheduler) for the motivation
   behind these changes.)

#. Simplify the `on` algorithm which no longer needs to use `write_env` to make
   child operations aware of the current scheduler and domain.





# Implications of removal

Removing algorithm customization is fairly straightforward in most regards, but there
are a few parts of `std::execution` that need special care.

## The parallel scheduler

The `parallel_scheduler` goes to great lengths to ensure that the `bulk` family of
algorithms -- `bulk`, `bulk_chunked`, and `bulk_unchunked` -- are executed in parallel
when the users requests it and when the underlying execution context supports it.

To that end, the `parallel_scheduler` "provides a customized implementation" of the
`bulk_chunked` and `bulk_unchunked` algorithms, but nothing is said about how those custom
implementations are found or under what circumstances users can be assured that the
`parallel_scheduler` will use them. Arguably, this is under-specified in the current
Working Draft and should be addressed whether this paper is accepted or not.

*We have to give users a guarantee that if _X_, _Y_, and _Z_ conditions are met,
`bulk[_[un]chunked]`{.cpp}* <u>will</u> *be run in parallel with absolute certainty.*

One solution is to say that the `bulk` algorithms are guaranteed to execute in parallel
when the immediate predecessor of the `bulk` operation is known to complete on the
`parallel_scheduler`. In a sender expression such as the following:

> ```cpp
> sndr | std::execution::bulk(std::par, 1024, fn)
> ```

If `sndr`'s attributes advertizes a completion scheduler of type `parallel_scheduler`,
then we can guarantee that the `bulk` operation will execute in parallel. Implementations
can choose to parallelize `bulk` under other circumstances, but we require this one.

The implication of offering this guarantee is that we must preserve the guarantee going
forward. Any new customization mechanism we might add must _never_ result in parallel
execution becoming serialized.

The reverse is not necessarily true though. I maintain that a future change that
parallelizes a `bulk` algorithm that formerly executed serially on the `parallel_scheduler`
is an acceptable change of behavior.

If SG1 or LEWG disagrees, there are ways to avoid even this behavior change.

## The task scheduler

Library issue [#4336](https://cplusplus.github.io/LWG/issue4336) describes the
poor interaction between `task_scheduler`, a type-erased scheduler, and the `bulk`
family of algorithms; namely, that the `task_scheduler` always executes `bulk`
in serial, even when it is wrapping a `parallel_scheduler`.

This is not a problem caused by the customization mechanism, but it is something
that can be addressed as part of the customization removal process.

When we address that issue, we must avoid the `parallel_scheduler` pitfall by
under-specifying the interaction with `bulk`. As with `parallel_scheduler`, users must
have a guarantee about the conditions under which `bulk` is accelerated on a
`task_scheduler`.

Fortunately, the `parallel_scheduler` has already given us a way to punch the
`bulk_chunked` and `bulk_unchunked` algorithms through a type-erased API boundary:
`parallel_scheduler_backend` ([exec.sysctxrepl.psb]{.sref}). By specifying
the behavior of `task_scheduler` in terms of `parallel_scheduler_backend` and
`bulk_item_receiver_proxy`, we can give `task_scheduler` the ability to parallelize
`bulk` without having to invent a new mechanism.


## The `bulk` algorithms

Few users will ever have a need to customize an algorithm like `then` or `let_value`.
The `bulk` algorithms are a different story. Anybody with a custom thread pool will
benefit from a custom `bulk` implementation that can run in parallel on the thread
pool. The loss of algorithm customization is particularly painful in this area. This
section explores some options to address these concerns and makes a recommendation.

### Option 1: Remove `bulk`, `bulk_chunked`, and `bulk_unchunked`

This option cuts the Gordian knot, but comes at a high cost. The `parallel_scheduler`
can hardly be called "parallel" if it does not offer a way to execute work in
parallel, so cutting the `bulk` algorithms probably means cutting `parallel_scheduler`
also.

### Option 2: Magical parallel execution

In this option, we keep the `bulk` algorithms and the `parallel_scheduler`, and we say
that the `bulk` algorithms are executed in parallel on the `parallel_scheduler` (and on a
`task_scheduler` that wraps a `parallel_scheduler`), but we leave the mechanism
unspecified.

This option is essentially the _status quo_, except that as discussed in [](#the-parallel-scheduler),
this aspect of the `parallel_scheduler` is currently under-specified. The referenced section proposes a path forward.

A variant of this option is to specify an exposition-only mechanism whereby `bulk`
gets parallelized.

This option makes `parallel_scheduler` and `task_scheduler` "magic" with respect to the
`bulk` algorithms. End users would have no standard mechanism to parallelize `bulk` on
their own third-party thread pools in C++26.

This is the approach taken by the [](#proposed-wording-2) below.

### Option 3: A normative mechanism for the `bulk*` algorithms only

In this option, we reintroduce algorithm customization with a special-purpose API just for
the `bulk` algorithms. For example, a scheduler might have an optional
`sch.bulk_transform(sndr, env)` that turns a serial `bulk*` sender into one that
executes in parallel on scheduler `sch`. Whenever a `bulk*` sender is passed to
`connect`, `connect` can check the sender's predecessor for a completion scheduler
that defines `bulk_transform` and uses it if found.

The downside of this approach is that we will still have to support this API even when a
more general algorithm customization mechanism is available. That doesn't seem terribly
onerous to me, but that is for SG1/LEWG to decide.


## Impacts on hardware vendors

Without algorithm customization, manufacturers of special-purpose hardware accelerators
will not be able to ship a scheduler that both:

* works with any standard-conforming implementation of `std::execution`, and

* performs optimally on their hardware for all of the standard algorithms.

See [](#mitigating-factors) for some reasons why this is not as terrible as it sounds.


## Mitigating factors

The loss of direct support for sender algorithm customization is a blow to power users of
`std::execution`{.cpp}, but there are a few factors that mitigate the blow.

### Sender introspection

All of the senders returned from the standard algorithms are self-describing and can be
unpacked into their constituent parts with structured bindings. A sufficiently motivated
user can "customize" an algorithm by writing a recursive sender tree transformation,
explicitly transforming senders before launching them.

### Third party algorithms

The sender concepts and customization points make it possible for users to write their own
sender algorithms that interoperate with the standard ones. If a user wants to change the
behavior of the `then` algorithm in some way, they have the option of writing their own
and using it instead. I expect libraries of third-party algorithms to appear on GitHub in
time, as they tend to.

### Difficulties with proprietary extensions

Some execution contexts place extra-standard requirements on the code that executes on
them. For example, NVIDIA GPUs require device-accelerated code to be annotated with its
proprietary `__device__` annotation. Standard libraries are unlikely to ship
implementations of `std::execution` with such annotations. The consequence is that, rather
than shipping just a GPU scheduler with some algorithm customizations, a vendor like
NVIDIA is already committed to shipping its own complete implementation of
`std::execution` (in a different namespace, of course).

For such vendors, the inability to customize standard algorithms is a moot point. Since it
is _implementing_ the standard algorithms, the implementations can do whatever they want.


## The removal process

### Approach

The approach to removing sender algorithm customization is twofold:

- Remove those components that facilitate algorithm customization and their uses where it
  is easy to do so.

- In all other cases, turn normative mechanisms into non-normative ones so we can change
  them later. This results in smaller and safer wording changes and preserves the
  already agreed-upon semantics in a way that is easy to verify.

### Procedure

The steps for removing algorithm customization are detailed below.

1. Remove the type `default_domain`{.cpp} ([exec.domain.default]{.sref}).

2. Remove the functions:

   * `transform_sender`{.cpp} ([exec.snd.transform]{.sref}),
   * `transform_env`{.cpp} ([exec.snd.transform.env]{.sref}), and
   * `apply_sender`{.cpp} ([exec.snd.apply]{.sref}).

3. Remove the query object `get_domain`{.cpp} ([exec.get.domain]{.sref}).

4. Remove the exposition-only helpers:

   * _`completion-domain`_ ([exec.snd.expos]{.sref}/8-9),
   * _`get-domain-early`_ ([exec.snd.expos]{.sref}/13), and
   * _`get-domain-late`_ ([exec.snd.expos]{.sref}/14).

5. Change the functions `get_completion_signatures`{.cpp} ([exec.getcomplsigs]{.sref}) and
   `connect`{.cpp} ([exec.connect]{.sref}) to operate on a sender determined as follows
   instead of passing the sender through `transform_sender`{.cpp}:

   * If the sender has a tag with an exposition-only _`transform-sender`_ member function,
     pass the sender to this function with the receiver's environment and continue the
     operation on the resulting sender. This preserves the behavior of calling
     `transform_sender` with the `default_domain`.

   * Otherwise, perform the operation on the passed-in sender.

6. For the following algorithms that are currently expressed in terms of a sender
   transformation to a lowered form, move the lowering from
   `@_alg_@.transform_sender(sndr, env)`{.cpp} to `@_alg_@.@_transform-sender_@(sndr, env)`.

   * `starts_on`{.cpp} ([exec.starts.on]{.sref}),
   * `continues_on`{.cpp} ([exec.continues.on]{.sref}),
   * `on`{.cpp} ([exec.on]{.sref}),
   * `bulk`{.cpp} ([exec.bulk]{.sref}),
   * `when_all_with_variant`{.cpp} ([exec.when.all]{.sref}),
   * `stopped_as_optional`{.cpp} ([exec.stopped.opt]{.sref}), and
   * `stopped_as_error`{.cpp} ([exec.stopped.err]{.sref}).

7. For each sender adaptor algorithm in [exec.adapt]{.sref} that is specified to be
   expression-equivalent to some `transform_sender`{.cpp} invocation of the form:

   > ```cpp
   > transform_sender(@_`some-computed-domain`_@(), @_`make-sender`_@(tag, {args...}, sndr));
   > ```

   Change the expression to:

   > ```cpp
   > @_`make-sender`_@(tag, {args...}, sndr);
   > ```

   For example, in [exec.continues.on]{.sref}/3, the following:

   > ```cpp
   > transform_sender(@_`get-domain-early`_@(sndr), @_`make-sender`_@(continues_on, sch, sndr))
   > ```

   would be changed to:

   > ```cpp
   > @_`make-sender`_@(continues_on, sch, sndr)
   > ```

   Additionally, if there is some caveat of the form "except that `sndr`{.cpp} is
   evaluated only once," that caveat should be removed as appropriate.

8. Merge the `schedule_from`{.cpp} ([exec.schedule.from]{.sref}) and `continues_on`{.cpp}
   ([exec.continues.on]{.sref}) algorithms into one algorithm called `continues_on`{.cpp}.
   (Currently they are separate so that they can be customized independently; by default
   `continues_on`{.cpp} merely dispatches to `schedule_from`{.cpp}.)

9. Change [exec.sync.wait]{.sref} and [exec.sync.wait.var]{.sref} to dispatch directly to
   their default implementations instead of computing a domain and using `apply_sender`{.cpp} to
   dispatch to an implementation.

10. Fix a bug in the `on(sndr, sch, closure)` algorithm where a `write_env` is incorrectly
    changing the "current" scheduler before its child `continues_on` actually transfers to
    that scheduler. `continues_on` needs to know the scheduler on which it will be started
    in order to find customizations correctly in the future.

11. Tweak the wording of `parallel_scheduler`{.cpp} ([exec.par.scheduler]{.sref}) to
    indicate that it (`parallel_scheduler`) is permitted to run the `bulk`{.cpp} family of
    algorithms in parallel in accordance with those algorithms' semantics, rather than
    suggesting that those algorithms are "customized" for `parallel_scheduler`{.cpp}. The
    mechanism for such remains non-normative, however we specify the conditions under
    which the `parallel_scheduler` is guaranteed to run the `bulk` algorithms in parallel.
    (This is currently under-specified.)

12. Respecify `task_scheduler` in terms of `parallel_scheduler_backend` so that the
    `bulk` algorithms can be accelerated despite `task_scheduler`'s type-erasure.
    This addresses [LWG#4336](https://cplusplus.github.io/LWG/issue4336). As with
    `parallel_scheduler`, we specify the conditions under which `task_scheduler` is
    guaranteed to run the `bulk` algorithms in parallel.

13. From the `scheduler` concept, remove the required expression:

    > ```cpp
    > { auto(get_completion_scheduler<set_value_t>(get_env(schedule(std::forward<Sch>(sch))))) }
    >     -> same_as<remove_cvref_t<Sch>>;
    > ```

    Instead, add a semantic requirement that _if_ the above expression is well-formed,
    then it shall compare equal to `sch`. Additionally, require that that expression is
    well-formed for the `parallel_scheduler`, the `task_scheduler`, and `run_loop`'s
    scheduler, but not `inline_scheduler`. See [](#inline_scheduler) for the motivation
    behind these changes, but in short: the `inline_scheduler` does not know where it
    completes in C++26 but will in C++29.

14. _Optional, but recommended_: Change the `env<>::query`{.cpp} member function to accept
    optional additional arguments after the query tag. This restores the original design
    of `env` to that which was first proposed in [@P3325R1] and which was approved by LEWG
    straw poll in St Louis. As described in [](#restoring-algorithm-customization-in-c29),
    when asking a sender for its completion scheduler, the caller needs to pass extra
    information about where the operation will be started, and that will require
    `env<>::query` to accept extra arguments.

This is admittedly a lot of changes, but the first 9 changes represent a simplification
from the _status quo_, and the other changes are either neutral in terms of specification
or else correct an existing Library issue.

In the final accounting, the result of these changes will be a vastly simpler
specification for [exec].

# Restoring algorithm customization in C++29

For C++29, we want the sender algorithms in `std::execution` to be customizable,
with different implementations suited for different execution contexts. If we remove
customization for C++26, how do we add it back without breaking code?

Recall that many senders do not know where they will complete until they know where they
will be started, and that information is not currently provided when the sender is queried
for its completion scheduler. This is the shoal on which algorithm customization has
foundered, because without accurate information about where operations are executing, it
is impossible to pick the right algorithm implementation.

Once the problem is stated plainly, the fix (or at least a major part of it) is obvious:

::: callout

[When asking the sender where it will complete, _tell it where it will start_.]{.callout-context}

:::

The implication of this is that so-called "early" customization, performed when
constructing a sender, will not be coming back. The receiver's execution environment is
not known when constructing a sender. C++29 will bring back "late" customization only.


## Completion scheduler enhancements

A paper targetting C++29 will propose that we extend the `get_completion_scheduler` query
to support an optional environment argument. Given a sender `S` and receiver `R`, the query
would look like:

> ```cpp
> // Pass the sender's attributes and the receiver's environment when computing
> // the completion scheduler:
> auto sch = get_completion_scheduler<set_value_t>(get_env(S), get_env(R));
> ```

It will not be possible in C++26 to pass the receiver's environment in this way, making
this a conforming extension since it would not change the meaning of any existing code.

This change will also make it possible to provide a completion scheduler for the error
channel in more cases. That is often not possible today since many errors are reported
inline on the context on which the operation is started. The receiver's environment knows
where the operation will be started, so by passing it to the
`get_completion_scheduler<set_error_t>` query, the error completion scheduler is knowable.

::: callout

[Note]{.callout-header} [The paragraph above makes it sound like this would be changing
the behavior for the `get_completion_scheduler<set_error_t>(get_env(sndr))` query. But
that expression will behave as it always has. Only when called with the receiver's
environment will any new behavior manifest; hence, this change is a pure
extension.]{.callout-context}

:::

By the way, this extension to `get_completion_scheduler` motivates the change to
`env<>::query` described above in [](#the-removal-process). Although we could decide
to defer that change until it is needed in C++29, it seems best to me to make the
change now.

## Domains {#get-domain}

There are sender expressions that complete on an indeterminate scheduler based on runtime
factors; `when_all` is a good example. This is the problem the `get_domain` query solved.
So long as all of `when_all`'s child senders share a common domain tag -- a property of
the scheduler -- we know the domain on which the `when_all` operation will
complete, even though we do not know which scheduler it will complete on. The <u>domain</u>
controls algorithm selection, not the scheduler directly.

So the plan will be to bring back a `get_domain` query in C++29. Additionally, just as it
is necessary to have three `get_completion_scheduler` queries, one each for the three
different completion channels, it is necessary to have three `get_completion_domain`
queries for the times when the completion scheduler is indeterminate but the domain is
known.

::: callout

[Note]{.callout-header} [Above we say, "So long as all of `when_all`'s child senders share
a common domain tag [...]". This sounds like we are adding a new requirement to the
`when_all` algorithm. However, this requirement will be met for all existing uses of
`when_all`. Before C++29, all senders will be in the "default" domain, so they trivially
all share a common domain.]{.callout-context}

:::

Giving a non-default domain to a scheduler is the way to opt-in to algorithm
customization. Prior to C++29, there will be no `get_*domain` queries, hence the addition
of those queries in C++29 will not affect any existing schedulers. And the domain queries
will be so-called "forwarding" queries, meaning they will automatically be passed through
layers of sender adaptors. Users will not have to change their code in order for domain
information to be propagated. As a result, this change is a pure extension.


## Customizing `connect`

Since C++29 will support only late (`connect`-time) customization, customizing
an algorithm effectively amounts to customizing that algorithm's `connect` operation.
By default, `connect(sndr, rcvr)` calls `sndr.connect(rcvr)`, but in C++29 there
will be a way to do something different depending on the sender's attributes and
the receiver's environment.

`connect` will compute two domains, the "starting" domain and the (value) "completion"
domain:

| Domain kind       | Query                                                  |
|-------------------|--------------------------------------------------------|
| Starting domain   | `get_domain(get_env(rcvr))`                            |
| Completion domain | `get_completion_domain<set_value_t>(get_env(sndr), get_env(rcvr))` |

How `connect` will use this information to select an algorithm implementation is currently
under design. (See [](#appendix-a-the-planned-fix) for more information.) But at that point,
it is only a matter of mechanism. The key point is that `connect` has the information it
needs to dispatch accurately, and that we can make that addition without breaking code.
And we can.

## The parallel and task schedulers and `bulk`

Once we have a general mechanism for customizing algorithms, we can consider changing
`parallel_scheduler` and `task_scheduler` to use that mechanism to find parallel
implementations of the `bulk` algorithms. In C++26, it is unspecified precisely how those
schedulers accelerate `bulk`, and we can certainly leave it that way for C++29. No change
is often the safest change and always the easiest.

If we wanted to switch to using the new algorithm dispatch mechanics in C++29, I believe
we can do so with minimal impact on existing code. Any behavior change would be an
improvement, accelerating `bulk` operations that _should_ have been accelerated but
were not.

Consider the following sender:

> ```cpp
> starts_on(parallel_scheduler(), just() | bulk(fn))
> ```

In C++26, we can offer no iron-clad standard guarantee that this `bulk` operation will be
accelerated even though it is executing on the parallel scheduler. The predecessor
of `bulk`, `just()`, does not know where it will complete in C++26. There is no plumbing
yet to tell it that it will be started on the parallel scheduler. As a result, it is
QoI whether this `bulk` will execute in parallel or not.

But suppose we add a `get_completion_domain<set_value_t>` query to the
`parallel_scheduler` such that the query returns an instance of a new type:
`parallel_domain`. Now, when connecting the `bulk` sender, `connect` will ask for the
predecessor's domain, passing also the receiver's environment. Now the `just()` sender is
able to say where it completes: the domain where it starts, `get_domain(get_env(rcvr))`.
This will return `parallel_domain{}`. `connect` would then use that information to
find a parallel implementation of `bulk`.

As a result, in C++29 we could guarantee that this usage of `bulk` will be parallelized.
For some stdlib implementations, this would be a behavior change: what once executed
serially on a thread of the parallel scheduler now executes in parallel on many threads.
Can that break working code? Yes, but only code that had already violated the
preconditions of `bulk`: that `fn` can safely be called in parallel.

I do not believe this should be considered a breaking change, since any code that breaks
is already broken.

All of the above is true also for `task_scheduler`, which merely adds an indirection
to the call to `connect`. After the changes suggested by this paper, the `task_scheduler`
accelerates `bulk` in the same way as `parallel_scheduler`.

::: callout

[Note]{.callout-header} [If we assign `parallel_domain` to the `parallel_scheduler`, and
we _also_ add a requirement to `when_all` that all of its child operations share a common
domain (see [](#get-domain)), does that have the potential to break existing
code? It would not. We would make `parallel_domain` inherit from `default_domain` so
that `when_all` will compute the common domain as `default_domain` even if one child
completes in the `parallel_domain`.]{.callout-content}

:::

<!-- -->

# Proposed wording, option 1: Fix algorithm customization {#proposed-wording-1}

[Introduce the notion of "execution domains" by changing [exec.async.ops#1]{.sref} as
follows:]{.ednote}

[In [execution.syn]{.sref}, make the following changes:]{.ednote}

> ```cpp
> @[&hellip; as before &hellip;]{.blue}@
>
> namespace std::execution {
>   // [exec.queries], queries
>   struct get_domain_t { @_`unspecified`_@ };
>   struct get_scheduler_t { @_`unspecified`_@ };
>   struct get_delegation_scheduler_t { @_`unspecified`_@ };
>   struct get_forward_progress_guarantee_t { @_`unspecified`_@ };
>   template<class CPO>
>     struct get_completion_scheduler_t { @_`unspecified`_@ };
>   @@[```template<class CPO>```]{.add}@@
>     @@[```struct get_completion_domain_t { @_`unspecified`_@ };```]{.add}@@
>   struct get_await_completion_adaptor_t { @_`unspecified`_@ };
>
>   inline constexpr get_domain_t get_domain{};
>   inline constexpr get_scheduler_t get_scheduler{};
>   inline constexpr get_delegation_scheduler_t get_delegation_scheduler{};
>   enum class forward_progress_guarantee;
>   inline constexpr get_forward_progress_guarantee_t get_forward_progress_guarantee{};
>   template<class CPO>
>     constexpr get_completion_scheduler_t<CPO> get_completion_scheduler{};
>   @@[```template<class CPO>```]{.add}@@
>     @@[```constexpr get_completion_domain_t<CPO> get_completion_domain{};```]{.add}@@
>   inline constexpr get_await_completion_adaptor_t get_await_completion_adaptor{};
>
> @[&hellip; as before &hellip;]{.blue}@
>
>   template<sender Sndr>
>     using tag_of_t = @_`see below`_@;
>
>   // [exec.snd.transform], sender transformations
>   template<@[`class Domain,`]{.rm}@ sender Sndr, @_`queryable`_[...]{.rm}@ Env>
>       requires (sizeof...(Env) <= 1)
>     constexpr sender decltype(auto) transform_sender(
>       @[`Domain dom,`]{.rm}@ Sndr&& sndr, const Env&@[...]{.rm}@ env) noexcept(@_`see below`_@);
>
>   @[`// [exec.snd.transform.env], environment transformations`]{.rm}@
>   @@[```template<class Domain, sender Sndr, @_`queryable`_@ Env>```]{.rm}@@
>     @[`constexpr queryable decltype(auto) transform_env(`]{.rm}@
>       @[`Domain dom, Sndr&& sndr, Env&& env) noexcept;`]{.rm}@
>
>   // [exec.snd.apply], sender algorithm application
>   template<class Domain, class Tag, sender Sndr, class... Args>
>     constexpr decltype(auto) apply_sender(
>       Domain dom, Tag, Sndr&& sndr, Args&&... args) noexcept(@_`see below`_@);
>
>   // [exec.connect], the connect sender algorithm
>   struct connect_t;
>   inline constexpr connect_t connect{};
>
> @[&hellip; as before &hellip;]{.blue}@
> ```

[Before subsection [exec.fwd.env]{.sref}, insert a new subsection with stable name
[exec.queries.expos] as follows:]{.ednote}

::: add

### Query utilities    [exec.queries.expos]

> 1. [exec.queries] makes use of the following exposition-only entities.
>
> 2. For subexpressions `q` and `tag` and pack `args`, let
>    ```@_`TRY-QUERY`_@(q, tag, args...)```{.cpp} be expression-equivalent to
>    ```@_`AS-CONST`_@(q).query(tag, args...)```{.cpp} if that expression is well-formed, and
>    ```@_`AS-CONST`_@(q).query(tag)```{.cpp} otherwise.
>
> 3. For subexpressions `q` and `tag` and pack `args`, let ```@_`HIDE-SCHED`_@(q)```{.cpp}
>    be an object `o` such that `o.query(tag, args...)` is ill-formed when the type of
>    `tag` is `get_scheduler_t` or `get_domain_t`, and `o.query(tag, args...)` otherwise.

:::


[Change [exec.get.domain] as follows:]{.ednote}

> ### `execution::get_domain`     [exec.get.domain]
>
> 1. `get_domain` asks a queryable object for its associated execution domain tag.
>
> 2. The name `get_domain` denotes a query object. For a subexpression `env`,
>    `get_domain(env)` is expression-equivalent to [```@_`MANDATE-NOTHROW`_@(D())```, where
>    `D` is the type of the first of the following expressions that is well-formed]{.add}
>    [Reformatted as a list.]{.ednote}
>
>    - [2.1]{.pnum} ```@[_`MANDATE-NOTHROW`_(]{.rm}[`auto(`]{.add}_`AS-CONST`_@(env).query(get_domain))```{.cpp}
>   
>    ::: add
>   
>    - [2.2]{.pnum} ```get_completion_domain<set_value_t>(get_scheduler(env), @_`HIDE-SCHED`_@(env))```{.cpp}
>
>    - [2.3]{.pnum} `default_domain()`
>   
>    :::
>
> 3. `forwarding_query(execution::get_domain)` is a core constant expression and has
>    value `true`.

[Change subsection [exec.get.compl.sched]{.sref} as follows:]{.ednote}

> ### `execution::get_completion_scheduler` [exec.get.compl.sched]
>
> 1. ```get_completion_scheduler<@_`completion-tag`_@>```{.cpp} obtains the completion
>   scheduler associated with a completion tag from a sender's attributes.
>
> ::: add
>
> 2. For subexpression `sch1` and pack `envs`, let `sch2` be
>   ```@_`TRY-QUERY`_@(sch, get_completion_scheduler<set_value_t>, envs...)```{.cpp} and let
>   ```@_`QUERY-RECURSE`_@(sch1, envs...)```{.cpp} be expression-equivalent to
>   ```@_`QUERY-RECURSE`_@(sch2, envs...)```{.cpp} if that expression is well-formed and
>   `sch1` and `sch2` have different types or compare unequal; otherwise, `sch`.
>
> :::
>
> 3. The name `get_completion_scheduler` denotes a query object template. For a
>   subexpression `q` [and pack `envs`]{.add}, the expression
>   ```get_completion_scheduler<@_`completion-tag`_@>(q@[`, envs...`]{.add}@)```{.cpp} is ill-formed if
>   _`completion-tag`_ is not one of `set_value_t`, `set_error_t`, or `set_stopped_t`.
>   Otherwise, ```get_completion_scheduler<@_`completion-tag`_@>(q@[`, envs...`]{.add}@)```{.cpp} is
>   expression-equivalent to
>
>   > ::: rm
>   >
>   > ```cpp
>   > @_`MANDATE-NOTHROW`_@(@_`AS-CONST`_@(q).query(get_completion_scheduler<@_`completion-tag`_@>))
>   > ```
>   >
>   > :::
>
> ::: add
>
> > - [3.1]{.pnum}
> >   ```@_`MANDATE-NOTHROW`_@(@_`RECURSE-QUERY`_@(@_`TRY-QUERY`_@(q, get_completion_scheduler<@_`completion-tag`_@>, envs...), envs...))```{.cpp}
> >   if that expression is well-formed.
> >
> > - [3.2]{.pnum} Otherwise, `q` if the type of `q` satisfies `scheduler` and `sizeof...(envs) == 0`
> >   is `false`.
> >
> > - [3.3]{.pnum} Otherwise, ```get_completion_scheduler<@_`completion-tag`_@>(q, envs...)```{.cpp}
> >   is ill-formed.
>
> :::
>
> > _Mandates_: If [the expression above]{.rm}
> > [```get_completion_scheduler<@_`completion-tag`_@>(q, envs...)```{.cpp}]{.add} is well-formed,
> > its type satisfies `scheduler`.
>
> 3. Let _`completion-fn`_ be a completion function ([exec.async.ops]); let
>   _`completion-tag`_ be the associated completion tag of _`completion-fn`_; let `args`
>   [and `envs`]{.add} be [a]{.rm} pack[s]{.add} of subexpressions; and let `sndr` be a
>   subexpression such that `sender<decltype((sndr))>`{.cpp} is `true` and
>   ```get_completion_scheduler<@_`completion-tag`_@>(get_env(sndr)@[`, envs...`]{.add}@)```{.cpp}
>   is well-formed and denotes a scheduler `sch`. If an
>   asynchronous operation created by connecting `sndr` with a receiver `rcvr` causes the
>   evaluation of ```@_`completion-fn`_@(rcvr, args...)```{.cpp}, the behavior is
>   undefined unless the evaluation happens on an execution agent that belongs to `sch`'s
>   associated execution resource.
>
> 4. The expression
>   ```forwarding_query(get_completion_scheduler<@_`completion-tag`_@>)``` is a core constant
>   expression and has value `true`.


[After subsection [exec.get.compl.sched]{.sref}, add a new subsection with stable name
[exec.get.compl.domain] as follows.]{.ednote}

::: add

> ### `execution::get_completion_domain` [exec.get.compl.domain]
>
> 1. ```get_completion_domain<@_`completion-tag`_@>```{.cpp} obtains the completion
>    domain associated with a completion tag from a sender's attributes.
>
> 2. The name `get_completion_domain` denotes a query object template. For a
>    subexpression `q` and pack `envs`, the expression
>    ```get_completion_domain<@_`completion-tag`_@>(q, envs...)```{.cpp} is ill-formed if
>    _`completion-tag`_ is not one of `set_value_t`, `set_error_t`, or `set_stopped_t`.
>    Otherwise, ```get_completion_domain<@_`completion-tag`_@>(q, envs...)```{.cpp} is
>    expression-equivalent to ```@_`MANDATE-NOTHROW`_@(D())```, where `D` is the type
>    of the first of the following expressions that is well-formed
>
>    - [2.1]{.pnum} ```@_`TRY-QUERY`_@(q, get_completion_domain<@_`completion-tag`_@>, envs...)```
>   
>    - [2.2]{.pnum} ```@_`TRY-QUERY`_@(get_completion_scheduler<@_`completion-tag`_@>(q, envs...), get_completion_domain<set_value_t>, envs...)```
>   
>    - [2.3]{.pnum} `default_domain()` if `sizeof...(envs) == 0` is `false`.
>   
>    If none of the above expressions is well-formed, the expression
>    ```get_completion_domain<@_`completion-tag`_@>(q, envs...)```{.cpp} is ill-formed.
>
> 3. Let _`completion-fn`_ be a completion function ([exec.async.ops]); let
>    _`completion-tag`_ be the associated completion tag of _`completion-fn`_; let `args`
>    and `envs` be packs of subexpressions; and let `sndr` be a subexpression such that
>    `sender<decltype((sndr))>`{.cpp} is `true` and
>    ```get_completion_domain<@_`completion-tag`_@>(get_env(sndr), envs...)```{.cpp} is
>    well-formed and denotes a domain `d`. If an asynchronous operation created by
>    connecting `sndr` with a receiver `rcvr` causes the evaluation of
>    ```@_`completion-fn`_@(rcvr, args...)```{.cpp}, the behavior is undefined unless the
>    evaluation happens on an execution agent of an execution resource whose associated
>    execution domain tag is `d`.
>
> 4. The expression
>    ```forwarding_query(get_completion_domain<@_`completion-tag`_@>)``` is a core constant
>    expression and has value `true`.


:::

[In [exec.sched]{.sref}, change paragraphs 1, 5, and 6 as follows:]{.ednote}

> 1. The `scheduler` concept defines the requirements of a scheduler type
>    ([exec.async.ops]{.sref}). `schedule` is a customization point object that accepts a
>    scheduler. A valid invocation of `schedule` is a schedule-expression.
>
>    > ```cpp
>    > namespace std::execution {
>    >   template<class Sch>
>    >     concept scheduler =
>    >       derived_from<typename remove_cvref_t<Sch>::scheduler_concept, scheduler_t> &&
>    >       @_queryable_@<Sch> &&
>    >       requires(Sch&& sch) {
>    >         { schedule(std::forward<Sch>(sch)) } -> sender;
>    >         @[`{ auto(get_completion_scheduler<set_value_t>(`]{.rm}@
>    >             @[`get_env(schedule(std::forward<Sch>(sch))))) }`]{.rm}@
>    >               @[`-> same_as<remove_cvref_t<Sch>>;`]{.rm}@
>    >       } &&
>    >       equality_comparable<remove_cvref_t<Sch>> &&
>    >       copyable<remove_cvref_t<Sch>>;
>    > }
>    > ```
>
> > [&hellip; as before &hellip;]{.blue}
>
> 5. For a given scheduler expression `sch`, [if]{.add} the expression
>    ```get_completion_scheduler<set_value_t>(get_env(schedule(sch)))```{.cpp} [is
>    well-formed, it]{.add} shall compare equal to `sch`.
>
> 6. For a given scheduler expression `sch` [and pack of subexpressions `env`]{.add}, if
>    the expression
>    ```get_@[completion_]{.add}@domain@[<_`completion-tag`_>]{.add}@(sch@[`, env...`]{.add}@)```{.cpp} is
>    well-formed, then the expression
>    ```get_@[completion_]{.add}@domain@[<_`completion-tag`_>]{.add}@(get_env(schedule(sch))@[`, env...`]{.add}@)```{.cpp}
>    is also well-formed and has the same type.
>
> ::: add
>
> 5. For a given scheduler expression `sch` and pack of subexpressions `env`, if
>    the expression
>    ```get_completion_scheduler<@_`completion-tag`_@>(sch, env...)```{.cpp} is
>    well-formed, then the expression
>    ```get_completion_scheduler<@_`completion-tag`_@>(get_env(schedule(sch)), env...)```{.cpp} is
>    ```get_@[completion_]{.add}@domain@[<_`completion-tag`_>]{.add}@(get_env(schedule(sch))@[`, env...`]{.add}@)```{.cpp}
>    is also well-formed and has the same type and value.
>
> :::

[Change [exec.snd.expos]{.sref} paragraph 3 as follows:]{.ednote}

> 3. For a query object `q` [and]{.rm}[,]{.add} a subexpression `v`[, and a pack
>   of subexpressions `as`]{.add}, ```@_`MAKE-ENV`_@(q, v)``` is an expression `env` whose type
>   satisfies _`queryable`_ such that the result of ```env.query(q@[`, as...`]{.add}@)```
>   has a value equal to `v` ([concepts.equality]{.sref}). Unless otherwise stated, the object to
>   which ```env.query(q@[`, as...`]{.add}@)``` refers remains valid while `env` remains
>   valid.


[Change [exec.snd.expos]{.sref} paragraph 6 as follows:]{.ednote}

TODO: fix all uses of _`SCHED-ATTRS`_ and _`SCHED-ENV`_.

> 6. For a scheduler `sch` [and pack of subexpressions `env`, let `sch2` be
>    ```@_`call-with-default`_@(get_completion_scheduler<set_value_t>, sch, sch, env...)```.]{.add}
>    [, ```@_`SCHED-ATTRS`_@(sch)``` is an expression `o1` whose type satisfies _`queryable`_
>    such that ```o1.query(get_completion_scheduler<Tag>)``` is
>    an expression with the same type and value as `sch` where `Tag` is one of
>    `set_value_t` or `set_stopped_t`, and such that `o1.query(get_domain)` is
>    expression-equivalent to `sch.query(get_domain)`.]{.rm}
>    ```@_`SCHED-ENV`_@(sch@[`, env...`]{.add}@)``` is an expression
>    `o2` whose type satisfies _`queryable`_ such that `o2.query(get_scheduler)` is a
>    prvalue with the same type and value as ```sch@[2]{.add}@```, and such that
>    `o2.query(get_domain)` is expression-equivalent to
>    ```sch@[2]{.add}@.query(get_domain)``` [if that expression is well-formed,
>    and `default_domain()` otherwise]{.add}.

<!--

> ::: add
>
> 6. For a scheduler `sch` and a pack of subexpressions `env`,
>   ```@_`SCHED-ATTRS`_@(sch)``` is an expression `o1` whose type satisfies _`queryable`_
>   such that
>
>   > - [6.1]{.pnum} ```o1.query(get_completion_scheduler<@_`completion-tag`_@>, env...)``` is
>   >   expression-equivalent to ```get_completion_scheduler<@_`completion-tag`_@>(sch, env...)```;
>   >
>   > - [6.2]{.pnum} ```o1.query(get_completion_domain<@_`completion-tag`_@>, env...)``` is
>   >   expression-equivalent to ```get_completion_domain<@_`completion-tag`_@>(sch, env...)```
>   >   if that expression is well-formed, and `default_domain()` otherwise; and
>   >
>   > - [6.3]{.pnum} ```o1.query(get_completion_behavior<@_`completion-tag`_@>, env...)``` is
>   >   expression-equivalent to ```get_completion_behavior<@_`completion-tag`_@>(sch, env...)```.
>
> 7. For a scheduler `sch` and a pack of subexpressions `env`,
>   ```@_`SCHED-ENV`_@(sch)``` is an expression `o2` whose type satisfies _`queryable`_
>   such that
>
>   > - [7.1]{.pnum} `o2.query(get_scheduler)` is a prvalue with the same type and value as
>   >   `sch`,
>   >
>   > - [7.2]{.pnum} `o2.query(get_domain)` is expression-equivalent to
>   >   `sch.query(get_domain)` if that expression is well-formed, and `default_domain()`
>   >   otherwise.
>
> :::

-->

[Remove the prototype of the exposition-only _`completion-domain`_ function just before
[exec.snd.expos]{.sref} paragraph 8, and with it remove paragraphs 8 and 9, which specify
the function's behavior.]{.ednote}

[Remove [exec.snd.expos]{.sref} paragraphs 13 and 14 and the prototypes for the
_`get-domain-early`_ and _`get-domain-late`_ functions.]{.ednote}

[After [exec.snd.expos]{.sref} paragraph 47 (_`not-a-sender`_), add the following
new paragraph]{.ednote}

> ::: add
>
> 48.
> > ```cpp
> > struct @_`not-a-scheduler`_@ {
> >   using scheduler_concept = scheduler_t;
> >
> >   constexpr auto schedule() const noexcept {
> >     return @_`not-a-sender`_@();
> >   }
> > };
> > ```
>
> :::


[Add the following new paragraphs after [exec.snd.expos]{.sref} paragraph 50 as
follows:]{.ednote}

> ::: add
>
> 51. ```cpp
> template<class Sndr, class SetTag, class... Env>
>   concept @_`never-completes-with`_@ = requires {
>     requires (0 == get_completion_signatures<Sndr, Env...>().@_`count-of`_@(SetTag()));
>   };
> ```
>
> ```cpp
> template<class Fn, class Default, class... Args>
>   constexpr auto @_`call-with-default`_@(Fn&& fn, Default&& value, Args&&... args) noexcept(@_`see below`_@);
> ```
>
> 52. Let `e` be the expression `std::forward<Fn>(fn)(std::forward<Args>(args)...)` if
>     that expression is well-formed; otherwise, it is
>     `static_cast<Default>(std::forward<Default>(value))`.
>
> 53. _Returns_: `e`.
>
> 54. _Remarks_: The expression in the `noexcept` clause is `noexcept(e)`.
>
> :::

[Change [exec.domain.default]{.sref} as follows:]{.ednote}

> ### 33.9.5 `execution::default_domain` [exec.domain.default]
>
> 1.
> ```cpp
> namespace std::execution {
>   struct default_domain {
>     template<@[class Tag, ]{.add}@ sender Sndr, @_`queryable`_[`...`]{.rm}@ Env>
>         @[`requires (sizeof...(Env) <= 1)`]{.rm}@
>       static constexpr sender decltype(auto) transform_sender(@[`Tag, `]{.add}@ Sndr&& sndr, const Env&@[`...`]{.rm}@ env)
>         noexcept(@_`see below`_@);
>
>     @@[```template<sender Sndr, @_`queryable`_@ Env>```]{.rm}@@
>       @@[```static constexpr @_`queryable`_@ decltype(auto) transform_env(Sndr&& sndr, Env&& env) noexcept;```]{.rm}@@
>
>        template<class Tag, sender Sndr, class... Args>
>          static constexpr decltype(auto) apply_sender(Tag, Sndr&& sndr, Args&&... args)
>            noexcept(@_`see below`_@);
>   };
> }
> ```
>
> ```cpp
> template<@[class Tag, ]{.add}@ sender Sndr, @_`queryable`_[`...`]{.rm}@ Env>
>     @[`requires (sizeof...(Env) <= 1)`]{.rm}@
>   static constexpr sender decltype(auto) transform_sender(@[`Tag, `]{.add}@ Sndr&& sndr, const Env&@[`...`]{.rm}@ env)
>     noexcept(@_`see below`_@);
> ```
>
> 2. Let `e` be the expression
>
>    > ```cpp
>    > tag_of_t<Sndr>().transform_sender(@[`Tag(), `]{.add}@std::forward<Sndr>(sndr), env@[`...`]{.rm}@)
>    > ```
>
>    if that expression is well-formed; otherwise, ```@[`static_cast<Sndr>(`]{.add}@std::forward<Sndr>(sndr)@[`)`]{.add}@```.
>
> 3. _Returns_: `e`.
>
> 4. _Remarks_: The exception specification is equivalent to `noexcept(e)`.
>
> ::: rm
>
> ```cpp
> template<sender Sndr, @_`queryable`_@ Env>
>   constexpr @_`queryable`_@ decltype(auto) transform_env(Sndr&& sndr, Env&& env) noexcept;
> ```
>
> 5. Let e be the expression
>
>    > ```cpp
>    > tag_of_t<Sndr>().transform_env(std::forward<Sndr>(sndr), std::forward<Env>(env))
>    > ```
>
>    if that expression is well-formed; otherwise, ```@_`FWD-ENV`_@(std::forward<Env>(env))```.
>
> 6. _Mandates_: `noexcept(e)` is `true`.
>
> 7. _Returns_: `e`.
>
> :::
>
> ```cpp
> template<class Tag, sender Sndr, class... Args>
> constexpr decltype(auto) apply_sender(Tag, Sndr&& sndr, Args&&... args)
>   noexcept(@_`see below`_@);
> ```
>
> 8. Let `e` be the expression
>
>    > ```cpp
>    > Tag().apply_sender(std::forward<Sndr>(sndr), std::forward<Args>(args)...)
>    > ```
>
> 9. _Constraints_: `e` is a well-formed expression.
>
> 10. _Returns_: `e`.
>
> 11. _Remarks_: The exception specification is equivalent to `noexcept(e)`.



[Change [exec.snd.transform]{.sref} as follows:]{.ednote}

> ### `execution::transform_sender`        [exec.snd.transform]
>
> ```cpp
> namespace std::execution {
>   template<@[`class Domain,`]{.rm}@ sender Sndr, @_`queryable`_[`...`]{.rm}@ Env>
>       @[`requires (sizeof...(Env) <= 1)`]{.rm}@
>     constexpr sender decltype(auto) transform_sender(@[`Domain dom,`]{.rm}@ Sndr&& sndr, const Env&@[`...`]{.rm}@ env)
>       noexcept(@_`see below`_@);
> }
> ```
>
> ::: add
>
> 1. For a subexpression `s`, let ```@_`domain-for`_@(start, s)``` be `D()` where
>    `D` is the decayed type of `get_domain(env)` if that expressions that is well-formed,
>    and `default_domain` otherwise.
>
> 2. Let ```@_`domain-for`_@(set_value, s)``` be `D()` where `D` is the decayed
>    type of  `get_completion_domain<set_value_t>(get_env(sndr), env)` if that
>    is well-formed, and `default_domain` otherwise.
>
> :::
>
> 3. Let ```@_`transformed-sndr`_[`(dom, tag, s)`]{.add}@``` be the expression
>
>    > ```cpp
>    > @[`dom.transform_sender(std::forward<Sndr>(sndr), env...)`]{.rm}@
>    > @[`dom.transform_sender(tag, s, env)`]{.add}@
>    > ```
>
>    if that expression is well-formed; otherwise,
>
>    > ```cpp
>    > @[`default_domain().transform_sender(std::forward<Sndr>(sndr), env...)`]{.rm}@
>    > @[`default_domain().transform_sender(tag, s, env)`]{.add}@
>    > ```
>
>    Let [_`final-sndr`_]{.rm} [```@_`transform-recurse`_@(dom, tag, s)```]{.add} be the
>    expression ```@_`transformed-sndr`_[(dom, tag, s)]{.add}@``` if
>    ```@_`transformed-sndr`_[(dom, tag, s)]{.add}@``` and [`sndr`]{.rm} [`s`]{.add} have
>    the same type ignoring `cv`-qualifiers; otherwise, it is the expression
>    [```transform_sender(dom, @_`transformed-sndr`_@, env...)```]{.rm}
>    [```@_`transform-recurse`_@(dom2, tag, s2)``` where `s2` is
>    ```@_`transformed-sender`_@(dom, tag, s)``` and `d2` is
>    ```@_`domain-for`_@(tag, s2)```]{.add}.
>
>    ::: add
>
>    Let _`tmp-sndr`_ be the expression
>
>    > ```cpp
>    > @_`transform-recurse`_@(@_`domain-for`_@(set_value, sndr), set_value, sndr)
>    > ```
>
>    and let _`final-sndr`_ be the expression
>
>    > ```cpp
>    > @_`transform-recurse`_@(@_`domain-for`_@(start, @_`tmp-sndr`_@), start, @_`tmp-sndr`_@)
>    > ```
>
>    :::
>
> 2. _Returns_: _`final-sndr`_.
>
> 3. _Remarks_: The exception specification is equivalent to ```noexcept(@_`final-sndr`_@)```.


[Remove section [exec.snd.transform.env]{.sref}.]{.ednote}


[Change [exec.getcomplsigs]{.sref} paragraph 1 as follows:]{.ednote}

> ```cpp
> template<class Sndr, class... Env>
>   consteval auto get_completion_signatures() -> @_`valid-completion-signatures`_@ auto;
> ```
>
> 1. Let _`except`_ be an rvalue subexpression of an unspecified class type
>    _`Except`_ such that ```move_constructible<@_`Except`_@> && derived_from<@_`Except`_@, exception>``` is
>    `true`. Let ```@_`CHECKED-COMPLSIGS`_@(@_`e`_@)``` be _`e`_ if _`e`_ is a core constant expression whose type
>    satisfies _`valid-completion-signatures`_; otherwise, it is the following expression:
>    ```(@_`e`_@, throw @_`except`_@, completion_signatures())``` Let ```@_`get-complsigs`_@<Sndr, Env...>()``` be
>    expression-equivalent to
>    `remove_reference_t<Sndr>::template get_completion_signatures<Sndr, Env...>()`. Let `NewSndr` be `Sndr` if
>    `sizeof...(Env) == 0` is `true`; otherwise, ```decltype(@_`s`_@)``` where _`s`_ is the following expression:
>
>    > ```cpp
>    > transform_sender(
>    >   @@[```@_`get-domain-late`_@(declval<Sndr>(), declval<Env>()...),```]{.rm}@@
>    >   declval<Sndr>(),
>    >   declval<Env>()...)
>    > ```

[Change [exec.connect]{.sref} paragraph 2 as follows:]{.ednote}

> 2. The name `connect` denotes a customization point object. For subexpressions
>    `sndr` and `rcvr`, let `Sndr` be `decltype((sndr))` and `Rcvr` be `decltype((rcvr))`,
>    let `new_sndr` be the expression
>
>    > ```cpp
>    > transform_sender(@@[```decltype(@_`get-domain-late`_@(sndr, get_env(rcvr))){},```]{.rm}@@ sndr, get_env(rcvr))
>    > ```
>
>    and let `DS` and `DR` be `decay_t<decltype((new_sndr))>` and `decay_t<Rcvr>`,
>    respectively.


[Remove [exec.schedule]{.sref} paragraph 4 as follows:]{.ednote}

> ::: rm
>
> 4. If the expression
>
>    > ```cpp
>    > get_completion_scheduler<set_value_t>(get_env(sch.schedule())) == sch
>    > ```
>
>    is ill-formed or evaluates to `false`, the behavior of calling `schedule(sch)` is
>    undefined.
>
> :::

[Change [exec.just]{.sref} paragraph 2 as follows:]{.ednote}

> 2. The names `just`, `just_error`, and `just_stopped` denote customization point
>    objects. Let _`just-cpo`_ be one of `just`, `just_error`, or `just_stopped`. For a pack of
>    subexpressions `ts`, let `Ts` be the pack of types `decltype((ts))`. The expression
>    ```@_`just-cpo`_@(ts...)``` is ill-formed if
>
>    - [2.1]{.pnum} ```(@_`movable-value`_@<Ts> &&...)``` is `false`, or
>
>    - [2.2]{.pnum} _`just-cpo`_ is `just_error` and `sizeof...(ts) == 1` is `false`, or
>
>    - [2.3]{.pnum} _`just-cpo`_ is `just_stopped` and `sizeof...(ts) == 0` is `false`.
>
>    Otherwise, it is expression-equivalent to ```@_`make-sender`_@(@_`just-cpo`_@, @_`product-type`_@{ts...})```.
>
>    For `just`, `just_error`, and `just_stopped`, let _`set-cpo`_ be `set_value`,
>    `set_error`, and `set_stopped`, respectively. The exposition-only class template
>    _`impls-for`_ ([exec.snd.expos]{.sref}) is specialized for _`just-cpo`_ as follows:
>
>    > ```cpp
>    > namespace std::execution {
>    >   template<>
>    >   struct @_`impls-for`_@<@_`decayed-typeof`_@<@_`just-cpo`_@>> : @_`default-impls`_@ {
>    >     @@[```static constexpr auto @_`get-attrs`_@ =```]{.add}@@
>    >       @@[```[](const auto& data) noexcept -> decltype(auto) {```]{.add}@@
>    >         @@[```return @_`see below`_ [TODO]{.blue}@;```]{.add}@@
>    >       @@[```};```]{.add}@@
>    >
>    >     static constexpr auto @_`start`_@ =
>    >       [](auto& state, auto& rcvr) noexcept -> void {
>    >         auto& [...ts] = state;
>    >         @_`set-cpo`_@(std::move(rcvr), std::move(ts)...);
>    >       };
>    >   };
>    > }
>    > ```

[Change [exec.read.env]{.sref} paragraph 3 as follows:]{.ednote}

> 3. The exposition-only class template _`impls-for`_ ([exec.snd.expos]{.sref}) is
>    specialized for `read_env` as follows:
>
>    > ```cpp
>    > namespace std::execution {
>    >   template<>
>    >   struct @_`impls-for`_@<@_`decayed-typeof`_@<read_env>> : @_`default-impls`_@ {
>    >     @@[```static constexpr auto @_`get-attrs`_@ =```]{.add}@@
>    >       @@[```[](const auto& data) noexcept -> decltype(auto) {```]{.add}@@
>    >         @@[```return @_`see below`_ [TODO]{.blue}@;```]{.add}@@
>    >       @@[```};```]{.add}@@
>    >
>    >     static constexpr auto @_`start`_@ =
>    >       [](auto query, auto& rcvr) noexcept -> void {
>    >         @_`TRY-SET-VALUE`_@(rcvr, query(get_env(rcvr)));
>    >       };
>    >   };
>    >
>    >   template<class Sndr, class Env>
>    >     static consteval void @_`check-types`_@();
>    > }
>    > ```


[Change [exec.starts.on]{.sref} paragraphs 3 and 4, and insert a new paragraph 5 as
follows:]{.ednote}


> 3. Otherwise, the expression `starts_on(sch, sndr)` is expression-equivalent to:
>
>    > ```cpp
>    > @@[`transform_sender(`]{.rm}@@
>    >   @@[```@_`query-with-default`_@(get_domain, sch, default_domain()),```]{.rm}@@
>    >   @_`make-sender`_@(starts_on, sch, sndr)@[`)`]{.rm}@
>    > ```
>
>    [except that `sch` is evaluated only once.]{.rm}
>
> 4. Let `out_sndr` and env be subexpressions such that `OutSndr` is
>    `decltype((out_sndr))`. If ```@_`sender-for`_@<OutSndr, starts_on_t>``` is `false`,
>    then the expression[s `starts_on.transform_env(out_sndr, env)` and]{.rm}
>    ```starts_on.transform_sender(@[`set_value, `]{.add}@out_sndr, env)```
>    [are]{.rm}[is]{.add} ill-formed; otherwise
>
>    ::: rm
>
>    - [4.1]{.pnum} `starts_on.transform_env(out_sndr, env)` is equivalent to:
>
>    > ```cpp
>    > auto&& [_, sch, _] = out_sndr;
>    > return @_`JOIN-ENV`_@(@_`SCHED-ENV`_@(sch), @_`FWD-ENV`_@(env));
>    > ```
>
>    :::
>
>    - [4.2]{.pnum} ```starts_on.transform_sender(@[`set_value, `]{.add}@out_sndr, env)``` is equivalent to:
>
>    > ```cpp
>    > auto&& [_, sch, sndr] = out_sndr;
>    > return let_value(
>    >   @[schedule(sch),]{.rm}@
>    >   @[`continues_on(just(), sch),`]{.add}@
>    >   [sndr = std::forward_like<OutSndr>(sndr)]() mutable
>    >     noexcept(is_nothrow_move_constructible_v<decay_t<OutSndr>>) {
>    >     return std::move(sndr);
>    >   });
>    > ```
>
> ::: add
>
> 5. The exposition-only class template _`impls-for`_ is specialized for
>    `starts_on_t` as follows:
>
>    > ```c++
>    > namespace std::execution {
>    >   template<>
>    >   struct @_`impls-for`_@<starts_on_t> : @_`default-impls`_@ {
>    >     static constexpr auto @_`get-attrs`_@ =
>    >       [](const auto& sch, const auto& child) noexcept -> decltype(auto) {
>    >         return @_`see below`_@;
>    >       };
>    >   };
>    > }
>    > ```
>
>    For subexpressions `sch` and `child` and pack of subexpressions `env`, let `sch2` be
>    `get_completion_scheduler<set_value_t>(sch, env...)`, and let `env2` be the pack
>    ```@_`JOIN-ENV`_@(@_`SCHED-ENV`_@(sch2), env)```.
>    ```@_`impls-for`_@<starts_on_t>::@_`get-attrs`_@(sch, child)``` returns an object
>    `attrs` such that
>
>    - [5.1]{.pnum} ```attrs.query(get_completion_scheduler<@_`completion-tag`_@>, env...)``` is
>      expression-equivalent to ```get_completion_scheduler<@_`completion-tag`_@>(child), env2...)```.
>
>    - [5.2]{.pnum} ```attrs.query(get_completion_domain<@_`completion-tag`_@>, env...)``` is
>      expression-equivalent to ```get_completion_domain<@_`completion-tag`_@>(child), env2...)```.
>
>    - [5.3]{.pnum} For a subexpression `q` and pack `args`, ```attrs.query(q, args...)```
>      is expression-equivalent to `get_env(child).query(q, args...)` where the type of `q`
>      satisfies _`forwarding-query`_ and is not a specialization of either
>      `get_completion_scheduler_t` or `get_completion_domain_t`.
>
> :::



[Remove subsection [exec.continues.on]{.sref}]{.ednote}

[Change stable name [exec.schedule.from]{.sref} to [exec.continues.on], and change the
subsection as follows:]{.ednote}

> **33.9.12.[7]{.rm}[6]{.add} ```execution::@[`schedule_from`]{.rm}[`continues_on`]{.add}@             ```{.cpp} [exec[.schedule.from]{.rm}[.continues.on]{.add}]**
>
>
> 1. [`schedule_from`]{.rm}[`continues_on`]{.add} schedules work dependent on the completion
>    of a sender onto a scheduler's associated execution resource.
>
>    [[_Note 1_:`schedule_from` is not meant to be used in user code; it is used in the
>    implementation of `continues_on`.  end note]]{.rm}
>
> 2. The name [`schedule_from`]{.rm}[`continues_on`]{.add} denotes a customization point
>    object. For some subexpressions `sch` and `sndr`, let `Sch` be `decltype((sch))` and
>    `Sndr` be `decltype((sndr))`. If `Sch` does not satisfy scheduler, or `Sndr` does not
>    satisfy `sender`,
>    [`schedule_from(sch, sndr)`{.cpp}]{.rm}[`continues_on(sndr, sch)`{.cpp}]{.add} is
>    ill-formed.
>
> 3. Otherwise, the expression
>    [`schedule_from(sch, sndr)`{.cpp}]{.rm}[`continues_on(sndr, sch)`{.cpp}]{.add} is
>    expression-equivalent to[:]{.rm}
>    [```@_`make-sender`_@(continues_on, sch, schedule_from(sndr))```{.cpp}]{.add}
>
>    ::: rm
>
>    > ```cpp
>    > transform_sender(
>    >    @_`query-with-default`_@(get_domain, sch, default_domain()),
>    >    @_`make-sender`_@(schedule_from, sch, sndr))
>    > ```
>
>    except that sch is evaluated only once.
>
>    :::
>
> 4. The exposition-only class template _`impls-for`_ ([exec.snd.general]{.sref}) is
>    specialized for [`schedule_from_t`]{.rm}[`continues_on_t`]{.add} as follows:
>
>    > ```cpp
>    > namespace std::execution {
>    >    template<>
>    >    struct @_`impls-for`_@<@[`schedule_from_t`]{.rm}[`continues_on_t`]{.add}@> : @_`default-impls`_@ {
>    >       static constexpr auto @_`get-attrs`_@ = @_`see below`_@;
>    >       static constexpr auto @_`get-state`_@ = @_`see below`_@;
>    >       static constexpr auto @_`complete`_@ = @_`see below`_@;
>    >
>    >       template<class Sndr, class... Env>
>    >          static consteval void @_`check-types`_@();
>    >    };
>    > }
>    > ```
>
> 5. The member ```@_`impls-for`_@<@[`schedule_from_t`]{.rm}[`continues_on_t`]{.add}@>::@_`get-attrs`_@```{.cpp}
>    is initialized with a callable object equivalent to the following lambda:
>
>    > ```cpp
>    > [](const auto& data, const auto& child) noexcept -> decltype(auto) {
>    >   @@[```return @_`JOIN-ENV`_@(@_`SCHED-ATTRS`_@(data), @_`FWD-ENV`_@(get_env(child)));```]{.rm}@@
>    >   @@[```return @_`see below`_@;```]{.add}@@
>    > }
>    > ```
>
>    ::: add
>
>    Given a pack of subexpressions `env`, let `Env` be the pack ```decltype(env)``` and
>    let `Sch` and `Sndr` be the decayed types of `data` and `child` respectively. The
>    above lambda returns an object `attrs` such that
>
>    - [5.1]{.pnum} ```attrs.query(get_completion_scheduler<@_`completion-tag`_@>, env...)```
>      is expression-equivalent to
>
>      - [5.1.1]{.pnum}
>        ```get_completion_scheduler<@_`completion-tag`_@>(data, @_`FWD-ENV`_@(env)...)```
>        if either ```@_`completion-tag`_@``` is `set_value_t` or
>        ```@_`never-completes-with`_@<Sndr, @_`completion-tag`_@, @_`FWD-ENV-T`_@(Env)...>```
>        is `true`.
>
>      - [5.1.2]{.pnum} Otherwise,
>        ```get_completion_scheduler<@_`completion-tag`_@>(get_env(child), @_`FWD-ENV`_@(env)...)```
>        if
>        ```@_`never-completes-with`_@<schedule_result_t<Sch>, @_`completion-tag`_@, @_`FWD-ENV-T`_@(Env)...>```
>        is `true`.
>
>    - [5.2]{.pnum} ```attrs.query(get_completion_domain<@_`completion-tag`_@>, env...)```
>      is expression-equivalent to `D()` where `D` is the type of
>
>      - [5.2.1]{.pnum}
>        ```get_completion_domain<@_`completion-tag`_@>(data, @_`FWD-ENV`_@(env)...)```
>        if either ```@_`completion-tag`_@``` is `set_value_t` or
>        ```@_`never-completes-with`_@<Sndr, @_`completion-tag`_@, @_`FWD-ENV-T`_@(Env)...>```
>        is `true`.
>
>      - [5.2.2]{.pnum} Otherwise,
>        ```get_completion_domain<@_`completion-tag`_@>(get_env(child), @_`FWD-ENV`_@(env)...)```
>        if
>        ```@_`never-completes-with`_@<schedule_result_t<Sch>, @_`completion-tag`_@, @_`FWD-ENV-T`_@(Env)...>```
>        is `true`.
>
>    - [5.3]{.pnum} For a pack of subexpressions `as` and a query object `q` whose type
>      satisfies _`forwarding-query`_ and is not a specialization of
>      `get_completion_scheduler_t` or `get_completion_domain_t`, ```attrs.(q, as...)```
>      is expression-equivalent to `get_env(child).query(q, as...)`.
>
>    :::
>
> 6. The member ```@_`impls-for`_@<@[`schedule_from_t`]{.rm}[`continues_on_t`]{.add}@>::@_`get-state`_@```{.cpp}
>    is initialized with a callable object equivalent to the following lambda:
>
>    [&hellip; as before &hellip;]{.blue}
>
> ```cpp
> template<class Sndr, class... Env>
>   static consteval void @_`check-types`_@();
> ```
>
> [&hellip; as before &hellip;]{.blue}
>
> 12. The member ```@_`impls-for`_@<@[`schedule_from_t`]{.rm}[`continues_on_t`]{.add}@>::@_`complete`_@```{.cpp}
>     is initialized with a callable object equivalent to the following lambda:
>
>     [&hellip; as before &hellip;]{.blue}
>
> 13. Let `out_sndr` be a subexpression denoting a sender returned from
>     [`schedule_from(sch, sndr)`]{.rm}[`continues_on(sndr, sch)`]{.add} or one equal to
>     such, and let `OutSndr` be the type `decltype((out_sndr))`. Let `out_rcvr` be
>     [&hellip; as before &hellip;]{.blue}


[After [exec.continues.on]{.sref}, add a new subsection with stable name
[exec.schedule.from] as follows:]{.ednote}

> ::: add
>
> ### ```execution::schedule_from                         ```{.cpp} [exec.schedule.from]
>
> 1. `schedule_from` offers scheduler authors a way to customize how to transition off of
>    their schedulers' associated execution contexts.
>
>    [`schedule_from` is not meant to be used in user code; it is used in the
>    implementation of `continues_on`.]{.note}
>
> 2. The name `schedule_from` denotes a customization point object. For some subexpression
>    `sndr`, if `decltype(sndr)` does not satisfy `sender`, `schedule_from(sndr)` is
>    ill-formed.
>
> 3. Otherwise, the expression `schedule_from(sndr)` is expression-equivalent to
>    ```@_`make-sender`_@(schedule_from, {}, sndr)```.
>
> :::

[Change [exec.on]{.sref} as follows:]{.ednote}


> ### ```execution::on             ```{.cpp} [exec.on]
>
> 1. The `on` sender adaptor has two forms [&hellip; as before &hellip;]{.blue}
>
> 2. The name `on` denotes a [&hellip; as before &hellip;]{.blue}
>
> 3. Otherwise, if `decltype((sndr))` satisfies `sender`, the expression `on(sch, sndr)` is expression-equivalent to:
>
>
>    ```cpp
>    @[`transform_sender(`]{.rm}@
>      @@[```@_`query-with-default`_@(get_domain, sch, default_domain()),```]{.rm}@@
>      make-sender(on, sch, sndr)@[`)`]{.rm}@
>    ```
>
>    [except that `sch` is evaluated only once.]{.rm}
>
> 4. For subexpressions `sndr`, `sch`, and `closure`, if
>
>    - [4.1]{.pnum} `decltype((sch))` does not satisfy `scheduler`, or
>    - [4.2]{.pnum} `decltype((sndr))` does not satisfy `sender`, or
>    - [4.3]{.pnum} `closure` is not a pipeable sender adaptor closure object ([exec.adapt.obj]{.sref}),
>
>    the expression `on(sndr, sch, closure)` is ill-formed; otherwise, it is expression-equivalent to:
>
>    ```cpp
>    @[`transform_sender(`]{.rm}@
>      @@[```@_`get-domain-early`_@(sndr),```]{.rm}@@
>      make-sender(on, @_`product-type`_@{sch, closure}, sndr)@[`)`]{.rm}@
>    ```
>
>    [except that `sndr` is evaluated only once.]{.rm}
>
> 5. Let `out_sndr` and `env` be subexpressions, let `OutSndr` be `decltype((out_sndr))`,
>    and let `Env` be `decltype((env))`. If ```@_`sender-for`_@<OutSndr, on_t>``` is
>    `false`, then the expression[s `on.transform_env(out_sndr, env)` and]{.rm}
>    ```on.transform_sender(@[`set_value, `]{.add}@out_sndr, env)``` [are]{.rm}[is]{.add} ill-formed.
>
> ::: rm
>
> 6. Otherwise: Let _`not-a-scheduler`_ be an unspecified empty class type.
>
> 7. The expression `on.transform_env(out_sndr, env)` has effects equivalent to:
>
>    > ```cpp
>    > auto&& [_, data, _] = out_sndr;
>    > if constexpr (scheduler<decltype(data)>) {
>    >   return @_`JOIN-ENV`_@(@_`SCHED-ENV`_@(std::forward_like<OutSndr>(data)), @_`FWD-ENV`_@(std::forward<Env>(env)));
>    > } else {
>    >   return std::forward<Env>(env);
>    > }
>    > ```
>
> :::
>
> 8. [Otherwise, ]{.add} [T]{.rm}[t]{.add}he expression
>    ```on.transform_sender(@[set_value, ]{.add}@out_sndr, env)``` has effects equivalent to:
>
>    > ```cpp
>    > auto&& [_, data, child] = out_sndr;
>    > if constexpr (scheduler<decltype(data)>) {
>    >   auto orig_sch =
>    >     @_`query-with-default`_@(get_scheduler, env, @_`not-a-scheduler`_@());
>    >
>    >   @@[```if constexpr (same_as<decltype(orig_sch), @_`not-a-scheduler`_@>) {```]{.rm}@@
>    >     @@[```return @_`not-a-sender`_@{};```]{.rm}@@
>    >   @@[```} else {```]{.rm}@@
>    >     return continues_on(
>    >       starts_on(std::forward_like<OutSndr>(data), std::forward_like<OutSndr>(child)),
>    >       std::move(orig_sch));
>    >   @@[`}`]{.rm}@@
>    > } else {
>    >   auto& [sch, closure] = data;
>    >   @@[```auto orig_sch = @_`query-with-default`_@(```]{.rm}@@
>    >     @@[```get_completion_scheduler<set_value_t>,```]{.rm}@@
>    >     @@[```get_env(child),```]{.rm}@@
>    >     @@[```@_`query-with-default`_@(get_scheduler, env, @_`not-a-scheduler`_@()));```]{.rm}@@
>    >   @@[```auto orig_sch = @_`call-with-default`_@(```]{.add}@@
>    >     @@[```get_completion_scheduler<set_value_t>,```]{.add}@@
>    >     @@[```@_`not-a-scheduler`_@(),```]{.add}@@
>    >     @@[```get_env(child),```]{.add}@@
>    >     @@[```env);```]{.add}@@
>    >
>    >   @@[```if constexpr (same_as<decltype(orig_sch), @_`not-a-scheduler`_@>) {```]{.rm}@@
>    >     @@[```return @_`not-a-sender`_@{};```]{.rm}@@
>    >   @@[```} else {```]{.rm}@@
>    >     return @[`write_env(`]{.rm}@
>    >       continues_on(
>    >         std::forward_like<OutSndr>(closure)(
>    >           continues_on(
>    >             @[`write_env(`]{.rm}@std::forward_like<OutSndr>(child)@@[```, @_`SCHED-ENV`_@(orig_sch))```]{.rm}@@,
>    >             sch)),
>    >         orig_sch)@[`,`]{.rm}@
>    >       @@[```@_`SCHED-ENV`_@(sch))```]{.rm}@@;
>    >   @@[`}`]{.rm}@@
>    > }
>    > ```
>
> ::: add
>
> 9. The exposition-only class template _`impls-for`_ ([exec.snd.expos]{.sref}) is
>    specialized for `on_t` as follows:
>
>    > ```cpp
>    > namespace std::execution {
>    >   template<>
>    >   struct @_`impls-for`_@<on_t> : @_`default-impls`_@ {
>    >     static constexpr auto @_`get-attrs`_@ =
>    >       [](const auto& data, const auto& child) noexcept {
>    >         return @_`see below`_@;
>    >       };
>    >   };
>    > }
>    > ```
>
>    Given a pack of subexpressions `env`, let `Env` be the pack `decltype(env)` and
>    let `Data` and `Child` be the decayed types of `data` and `child` respectively.
>    The above lambda returns an object `attrs` such that
>
>    - [5.1]{.pnum} If `Data` satisfies `scheduler`:
>
>      - [5.1.1]{.pnum} ```attrs.query(get_completion_scheduler<set_value_t>, env...)```
>        is expression-equivalent to `get_scheduler(env...[0])`
>
>      - [5.1.2]{.pnum} ```attrs.query(get_completion_scheduler<@_`completion-tag`_@>, env...)```
>        is [TODO]{.blue}
>
>      - [5.1.3]{.pnum} ```attrs.query(get_completion_domain<set_value_t>, env...)```
>        is expression-equivalent to
>        ```@_`call-with-default`_@(get_domain, default_domain(), env...[0])```
>
>      - [5.1.4]{.pnum} ```attrs.query(get_completion_domain<@_`completion-tag`_@>, env...)```
>        is [TODO]{.blue}
>
>      - [5.1.5]{.pnum} For a pack of subexpressions `as` and a query object `q` that satisfies
>        _`forwarding-query`_, ```attrs.query(q, as...)``` is expression-equivalent to
>        ```get_env(child).query(q, as...)```.
>
>    - [5.2]{.pnum} Otherwise, for a pack of subexpressions `as` and a query object `q` that
>      satisfies _`forwarding-query`_, `attrs.query(q, as...)` is expression-equivalent to
>      `get_env(child).query(q, as...)`. [TODO: is there more to say here?]{.blue}
>
> :::


[Change [exec.then]{.sref} paragraph 3 as follows:]{.ednote}

> 3. Otherwise, the expression ```@_`then-cpo`_@(sndr, f)``` is expression-equivalent to:
>
>    > ```cpp
>    > @@```@[transform_sender(_`get-domain-early`_(sndr),]{.rm}@ @_`make-sender`_@(@_`then-cpo`_@, f, sndr)@[`)`]{.rm}@```@@
>    > ```
>
>    [except that `sndr` is evaluated only once.]{.rm}
>
> [TODO: incomplete, these algorithms need to check that their 3 completion domains are unique.]{.blue}
>

[Change [exec.let]{.sref} as follows:]{.ednote}

> 1. `let_value`, `let_error`, and `let_stopped` [&hellip; as before &hellip;]{.blue}
>
> 2. For `let_value`, `let_error`, and `let_stopped`, let _`set-cpo`_ be `set_value`,
>    `set_error`, and `set_stopped`, respectively. Let the expression _`let-cpo`_ be one
>    of `let_value`, `let_error`, or `let_stopped`. For [a]{.rm} subexpression[s]{.add}
>    `sndr` [and `e`]{.add}, let ```@_`let-env`_@(sndr@[`, e`]{.add}@)``` be
>    expression-equivalent to the first well-formed expression below:
>
>    - [2.1]{.pnum} ```@_`SCHED-ENV`_@(get_completion_scheduler<@_`decayed-typeof`_@<@_`set-cpo`_@>>(get_env(sndr)@[`, e`]{.add}@)@[`, e`]{.add}@)```
>
>    ::: rm
>
>    - [2.2]{.pnum} ```@_`MAKE-ENV`_@(get_domain, get_domain(get_env(sndr)))```
>
>    :::
>
>    ::: add
>
>    - [2.2]{.pnum} ```@_`MAKE-ENV`_@(get_completion_domain<@_`decayed-typeof`_@<@_`set-cpo`_@>>, get_completion_domain<@_`decayed-typeof`_@<@_`set-cpo`_@>>(get_env(sndr), e))```
>
>    :::
>
>    - [2.3]{.pnum} ```(void(sndr), env<>{})```
>
> 3. The names `let_value`, `let_error`, and `let_stopped` denote [&hellip; as before &hellip;]{.blue}
>
> 4. Otherwise, the expression ```@_`let-cpo`_@(sndr, f)``` is expression-equivalent to:
>
>    > ```cpp
>    > @@[```transform_sender(@_`get-domain-early`_@(sndr),```]{.rm}@@ @_`make-sender`_@(@_`let-cpo`_@, f, sndr)@[`)`]{.rm}@
>    > ```
>
>    [except that `sndr` is evaluated only once.]{.rm}
>
> 5. The exposition-only class template _`impls-for`_ ([exec.snd.expos]{.sref}) is specialized
>    for _`let-cpo`_ as follows:
>
>    > ```cpp
>    > namespace std::execution {
>    >   template<class State, class Rcvr, class... Args>
>    >   void @_`let-bind`_@(State& state, Rcvr& rcvr, Args&&... args);      // exposition only
>    >
>    >   template<>
>    >   struct @_`impls-for`_@<@_`decayed-typeof`_@<@_`let-cpo`_@>> : @_`default-impls`_@ {
>    >     @@[```static constexpr auto @_`get-attrs`_@ = @_`see below`_@;```]{.add}@@
>    >     static constexpr auto @_`get-state`_@ = @_`see below`_@;
>    >     static constexpr auto @_`complete`_@ = @_`see below`_@;
>    >
>    >     template<class Sndr, class... Env>
>    >       static consteval void @_`check-types`_@();
>    >   };
>    > }
>    > ```
>
> 6. [&hellip; as before &hellip;]{.blue}
>
> 7. [&hellip; as before &hellip;]{.blue}
>
> ::: add
>
> 8. ```@_`impls-for`_@<@_`decayed-typeof`_@<@_`let-cpo`_@>>::@_`get-attrs`_@``` is
>    initialized with a callable object equivalent to the following:
>
>    > ```cpp
>    > [](const auto& data, const auto& child) {
>    >   @[TODO]{.blue}@
>    > }
>    > ```
>
> :::
>
> 8. ```@_`impls-for`_@<@_`decayed-typeof`_@<@_`let-cpo`_@>>::@_`get-state`_@``` is
>    initialized with a callable object equivalent to the following:
>
>    > ```cpp
>    > []<class Sndr, class Rcvr>(Sndr&& sndr, Rcvr& rcvr) requires @_`see below`_@ {
>    >   auto& [_, fn, child] = sndr;
>    >   using fn_t = decay_t<decltype(fn)>;
>    >   using env_t = decltype(@_`let-env`_@(child@[`, get_env(rcvr)`]{.add}@));
>    >   using args_variant_t = @_`see below`_@;
>    >   using ops2_variant_t = @_`see below`_@;
>    >
>    >   struct @_`state-type`_@ {
>    >     fn_t fn;                    // exposition only
>    >     env_t env;                  // exposition only
>    >     args_variant_t args;        // exposition only
>    >     ops2_variant_t ops2;        // exposition only
>    >   };
>    >   return @_`state-type`_@{@_`allocator-aware-forward`_@(std::forward_like<Sndr>(fn), rcvr),
>    >                     @_`let-env`_@(child@[`, get_env(rcvr)`]{.add}@), {}, {}};
>    > }
>    > ```
>
> [leave paragraphs 9-13 unchanged]{.ednote}
>
> ::: rm
>
> 14. Let `sndr` and `env` be subexpressions, and let `Sndr` be `decltype((sndr))`. If
>     ```@_`sender-for`_@<Sndr, @_`decayed-typeof`_@<@_`let-cpo`_@>>``` is `false`, then
>     the expression ```@_`let-cpo`_@.transform_env(sndr, env)``` is ill-formed.
>     Otherwise, it is equal to:
>
>     > ```cpp
>     > auto& [_, _, child] = sndr;
>     > return @_`JOIN-ENV`_@(@_`let-env`_@(child), @_`FWD-ENV`_@(env));
>     > ```
>
> :::
>
> 15. Let the subexpression `out_sndr` denote [&hellip; as before &hellip;]{.blue}

[Change [exec.bulk]{.sref} paragraph 3 and 4 as follows:]{.ednote}

> 3. Otherwise, the expression ```@_`bulk-algo`_@(sndr, policy, shape, f)``` is
>    expression-equivalent to:
>
>    > ```c++
>    > @@[```transform_sender(@_`get-domain-early`_@(sndr),```]{.rm}@@ @_`make-sender`_@(
>    >    @_`bulk-algo`_@, @_`product-type`_@<@_`see below`_@, Shape, Func>{policy, shape, f}, sndr)@[`)`]{.rm}@
>    > ```
>
>    [except that `sndr` is evaluated only once.]{.rm}
>
>    The first template argument of _`product-type`_ is `Policy` if `Policy` models
>    `copy_constructible`, and `const Policy&` otherwise.
> 
> 4. Let `sndr` and `env` be subexpressions such that `Sndr` is `decltype((sndr))`. If
>    ```@_`sender-for`_@<Sndr, bulk_t>``` is `false`, then the expression
>    ```bulk.transform_sender(@[`set_value,`]{.add}@ sndr, env)```
>    is ill-formed; otherwise, it is equivalent to:
> 
>    ```cpp
>    auto [_, data, child] = sndr;
>    auto& [policy, shape, f] = data;
>    auto new_f = [func = std::move(f)](Shape begin, Shape end, auto&&... vs)
>        noexcept(noexcept(f(begin, vs...))) {
>      while (begin != end) func(begin++, vs...);
>    }
>    return bulk_chunked(std::move(child), policy, shape, std::move(new_f));
>    ```
> 
>    [This causes the `bulk(sndr, policy, shape, f)` sender to be expressed in terms of
>    `bulk_chunked(sndr, policy, shape, f)` when it is connected to a receiver whose
>    execution domain does not customize `bulk`.]{.note}


[Change [exec.when.all]{.sref} paragraphs 2 and 3 as follows:]{.ednote}

> 2. The names `when_all` and `when_all_with_variant` denote customization point objects.
>    Let `sndrs` be a pack of subexpressions, let `Sndrs` be a pack of the types
>    `decltype((sndrs))...`, [let `e` be a subexpression,]{.add} and let
>    [`CD`]{.rm}[```@_`when-all-domain`_@(e)```]{.add} be the [type]{.rm}[expression]{.add}
>    [```common_type_t<decltype(@_`get-domain-early`_@(sndrs))...>```]{.rm}.
>    [```common_type_t<decltype(get_completion_domain<set_value_t>(sndrs, e))...>()```]{.add}.
>    [Let `CD2` be `CD` if `CD` is well-formed, and `default_domain`
>    otherwise.]{.rm} The expressions `when_all(sndrs...)` and `when_all_with_variant(sndrs...)`
>    are ill-formed if any of the following is `true`:
>
>    - [2.1]{.pnum} `sizeof...(sndrs)` is `0`, or
>
>    - [2.2]{.pnum} `(sender<Sndrs> && ...)` is `false`.
>
> 3. The expression `when_all(sndrs...)` is expression-equivalent to:
>
>    > ```cpp
>    > @[`transform_sender(CD2(),`]{.rm}@ @_`make-sender`_@(when_all, {}, sndrs...)@[`)`]{.rm}@
>    > ```

[Change [exec.when.all]{.sref} paragraph 10 as follows:]{.ednote}

> 10. The member ```@_`impls-for`_@<when_all_t>::@_`get-attrs`_@``` is initialized with a
>     callable object equivalent to the following lambda expression:
>
>     > ```c++
>     > [](auto&&, auto&&... child) noexcept {
>     >   @@[```if constexpr (same_as<CD, default_domain>) {```]{.rm}@@
>     >     @@[```return env<>();```]{.rm}@@
>     >   @@[```} else {```]{.rm}@@
>     >     @@[```return @_`MAKE-ENV`_@(get_domain, CD());```]{.rm}@@
>     >   @@[```}```]{.rm}@@
>     >   @@[```return @_`see below`_@;```]{.add}@@
>     > }
>     > ```
>
>     ::: add
>
>     For a subexpression `e`, the lambda expression above returns an object `attrs` such
>     that
>
>     - [10.1]{.pnum} `get_completion_domain<set_value_t>(attrs, e)` is expression-equivalent
>       to ```@_`when-all-domain`_@(e)```.
>
>     - [10.2]{.pnum} [TODO: more?]{.blue}
>
>     :::

[Change [exec.when.all]{.sref} paragraphs 19 and 20 as follows:]{.ednote}

> 19. The expression `when_all_with_variant(sndrs...)` is expression-equivalent to:
>
>     > ```cpp
>     > @[`transform_sender(CD2(),`]{.rm}@ @_`make-sender`_@(when_all_with_variant, {}, sndrs...)@[`);`]{.rm}@
>     > ```
> 
> 20. Given subexpressions `sndr` and `env`, if
>     ```@_`sender-for`_@<decltype((sndr)), when_all_with_variant_t>``` is `false`, then the
>     expression ```when_all_with_variant.transform_sender(@[`set_value,`]{.add}@ sndr, env)```
>     is ill-formed; otherwise, it is equivalent to:
> 
>     > ```cpp
>     > auto&& [_, _, ...child] = sndr;
>     > return when_all(into_variant(std::forward_like<decltype((sndr))>(child))...);
>     > ```
> 
>     [This causes the `when_all_with_variant(sndrs...)` sender to become
>     `when_all(into_variant(sndrs)...)` when it is connected with a receiver whose
>     execution domain does not customize `when_all_with_variant`.]{.note}


[Change [exec.into.variant]{.sref} paragraph 3 as follows:]{.ednote}

> 3. Otherwise, the expression `into_variant(sndr)` is expression-equivalent to:
>
>    > ```cpp
>    > @@[```transform_sender(@_`get-domain-early`_@(sndr), ```]{.rm}@@
>    >                  @_`make-sender`_@(into_variant, {}, sndr)@[`);`]{.rm}@
>    > ```


[Change [exec.stopped.opt]{.sref} paragrpah 2 as follows:]{.ednote}

2. The name `stopped_as_optional` denotes a pipeable sender adaptor object.
   For a subexpression `sndr`, let `Sndr` be `decltype((sndr))`.
   The expression `stopped_as_optional(sndr)` is expression-equivalent to:

   > ```cpp
   > transform_sender(get-domain-early(sndr),
   >                  make-sender(stopped_as_optional, {}, sndr))
   > ```

   except that `sndr` is only evaluated once.




[TODO: incomplete]{.ednote}


<!-- -->

# Proposed wording, option 2: Remove algorithm customization {#proposed-wording-2}

[In [execution.syn]{.sref}, make the following changes:]{.ednote}

> ```cpp
> @[&hellip; as before &hellip;]{.blue}@
>
> namespace std::execution {
>   // [exec.queries], queries
>   @@[```struct get_domain_t { @_`unspecified`_@ };```]{.rm}@@
>   struct get_scheduler_t { @_`unspecified`_@ };
>   struct get_delegation_scheduler_t { @_`unspecified`_@ };
>   struct get_forward_progress_guarantee_t { @_`unspecified`_@ };
>   template<class CPO>
>     struct get_completion_scheduler_t { @_`unspecified`_@ };
>   struct get_await_completion_adaptor_t { @_`unspecified`_@ };
>
>   @@[```inline constexpr get_domain_t get_domain{};```]{.rm}@@
>   inline constexpr get_scheduler_t get_scheduler{};
>   inline constexpr get_delegation_scheduler_t get_delegation_scheduler{};
>   enum class forward_progress_guarantee;
>   inline constexpr get_forward_progress_guarantee_t get_forward_progress_guarantee{};
>   template<class CPO>
>     constexpr get_completion_scheduler_t<CPO> get_completion_scheduler{};
>   inline constexpr get_await_completion_adaptor_t get_await_completion_adaptor{};
>
> @[&hellip; as before &hellip;]{.blue}@
>
>   // [exec.env], class template env
>   template<queryable... Envs>
>     struct env;
>
>   @@[_```// [exec.domain.default], execution domains```_]{.rm}@@
>   @@[```struct default_domain;```]{.rm}@@
>
>   // [exec.sched], schedulers
>   struct scheduler_t {};
>
> @[&hellip; as before &hellip;]{.blue}@
>
>   template<sender Sndr>
>     using tag_of_t = @_`see below`_@;
>
>   @@[_```// [exec.snd.transform], sender transformations```_]{.rm}@@
>   @@[```template<class Domain, sender Sndr, @_`queryable`_@... Env>```]{.rm}@@
>       @@[```requires (sizeof...(Env) <= 1)```]{.rm}@@
>     @@[```constexpr sender decltype(auto) transform_sender(```]{.rm}@@
>       @@[```Domain dom, Sndr&& sndr, const Env&... env) noexcept(@_`see below`_@);```]{.rm}@@
>
>   @@[_```// [exec.snd.transform.env], environment transformations```_]{.rm}@@
>   @@[```template<class Domain, sender Sndr, queryable Env>```]{.rm}@@
>     @@[```constexpr queryable decltype(auto) transform_env(```]{.rm}@@
>       @@[```Domain dom, Sndr&& sndr, Env&& env) noexcept;```]{.rm}@@
>
>   @@[_```// [exec.snd.apply], sender algorithm application```_]{.rm}@@
>   @@[```template<class Domain, class Tag, sender Sndr, class... Args>```]{.rm}@@
>     @@[```constexpr decltype(auto) apply_sender(```]{.rm}@@
>       @@[```Domain dom, Tag, Sndr&& sndr, Args&&... args) noexcept(@_`see below`_@);```]{.rm}@@
>
>   // [exec.connect], the connect sender algorithm
>   struct connect_t;
>   inline constexpr connect_t connect{};
>
> @[&hellip; as before &hellip;]{.blue}@
> ```


[Remove subsection [exec.get.domain]{.sref}.]{.ednote}


[In [exec.sched]{.sref}, change paragraphs 1 and 5 and strike paragraph 6 as
follows:]{.ednote}

> 1. The `scheduler` concept defines the requirements of a scheduler type
>    ([exec.async.ops]{.sref}). `schedule` is a customization point object that accepts a
>    scheduler. A valid invocation of `schedule` is a schedule-expression.
>
>    > ```cpp
>    > namespace std::execution {
>    >   template<class Sch>
>    >     concept scheduler =
>    >       derived_from<typename remove_cvref_t<Sch>::scheduler_concept, scheduler_t> &&
>    >       @_queryable_@<Sch> &&
>    >       requires(Sch&& sch) {
>    >         { schedule(std::forward<Sch>(sch)) } -> sender;
>    >         @[`{ auto(get_completion_scheduler<set_value_t>(`]{.rm}@
>    >             @[`get_env(schedule(std::forward<Sch>(sch))))) }`]{.rm}@
>    >               @[`-> same_as<remove_cvref_t<Sch>>;`]{.rm}@
>    >       } &&
>    >       equality_comparable<remove_cvref_t<Sch>> &&
>    >       copyable<remove_cvref_t<Sch>>;
>    > }
>    > ```
>
> > [&hellip; as before &hellip;]{.blue}
>
> 5. For a given scheduler expression `sch`, [if]{.add} the expression
>    ```@[auto(]{.add}@get_completion_scheduler<set_value_t>(get_env(schedule(sch)))@[)]{.add}@```{.cpp}
>    [is well-formed, it shall have type `remove_cvref_t<Sch>` and]{.add} shall compare
>    equal to `sch`.
>
> ::: rm
>
> 6. For a given scheduler expression `sch`, if the expression `get_domain(sch)`{.cpp} is
>    well-formed, then the expression `get_domain(get_env(schedule(sch)))`{.cpp} is also
>    well-formed and has the same type.
>
> :::



[In [exec.snd.general]{.sref}, change paragraph 1 as follows:]{.ednote}

> 1. Subclauses [exec.factories]{.sref} and [exec.adapt]{.sref} define [customizable]{.rm}
>    algorithms that return senders. [Each algorithm has a default implementation.]{.rm} Let
>    `sndr`{.cpp} be the result of an invocation of such an algorithm or an object equal to the
>    result ([concepts.equality]{.sref}), and let `Sndr`{.cpp} be `decltype((sndr))`{.cpp}. Let `rcvr`{.cpp}
>    be a receiver of type `Rcvr`{.cpp} with associated environment env of type `Env`{.cpp} such that
>    `sender_to<Sndr, Rcvr>`{.cpp} is `true`{.cpp}. [For the default implementation of the algorithm
>    that produced `sndr`{.cpp}, c]{.rm}[C]{.add}onnecting `sndr`{.cpp} to `rcvr`{.cpp} and starting the
>    resulting operation state ([exec.async.ops]{.sref}) necessarily results in the
>    potential evaluation ([basic.def.odr]{.sref}) of a set of completion operations whose
>    first argument is a subexpression equal to `rcvr`{.cpp}. Let `Sigs`{.cpp} be a pack of completion
>    signatures corresponding to this set of completion operations, and let `CS`{.cpp} be the type
>    of the expression `get_completion_signatures<Sndr, Env>()`{.cpp}. Then `CS`{.cpp} is a
>    specialization of the class template `completion_signatures`{.cpp} ([exec.cmplsig]{.sref}),
>    the set of whose template arguments is `Sigs`{.cpp}. If none of the types in `Sigs`{.cpp} are
>    dependent on the type `Env`{.cpp}, then the expression `get_completion_signatures<Sndr>()`{.cpp} is
>    well-formed and its type is `CS`{.cpp}. [If a user-provided implementation of the algorithm
>    that produced `sndr`{.cpp} is selected instead of the default:]{.rm}
>
>    - [[1.1]{.pnum} Any completion signature that is in the set of types denoted by
>      `completion_signatures_of_t<Sndr, Env>`{.cpp} and that is not part of `Sigs`{.cpp} shall
>      correspond to error or stopped completion operations, unless otherwise specified.]{.rm}
>
>    - [[1.2]{.pnum} If none of the types in `Sigs`{.cpp} are dependent on the type `Env`{.cpp}, then
>      `completion_signatures_of_t<Sndr>`{.cpp} and `completion_signatures_of_t<Sndr, Env>`{.cpp} shall
>      denote the same type.]{.rm}

[Change [exec.snd.expos]{.sref} paragraph 6 as follows:]{.ednote}

> 6. For a scheduler `sch`{.cpp}, ```@_`SCHED-ATTRS`_@(sch)```{.cpp} is [an expression `o1`{.cpp} whose type
>    satisfies _`queryable`_ such that `o1.query(get_completion_scheduler<Tag>)`{.cpp} is an
>    expression with the same type and value as `sch`]{.rm} [equivalent to
>    ```@_`MAKE-ENV`_@(get_completion_scheduler<set_value_t>, sch)```]{.add} [where `Tag`{.cpp} is one of
>    `set_value_t`{.cpp} or `set_stopped_t`, and such that `o1.query(get_domain)`{.cpp} is
>    expression-equivalent to `sch.query(get_domain)`]{.rm}. ```@_`SCHED-ENV`_@(sch)```{.cpp} is
>    [an expression `o2`{.cpp} whose type satisfies _`queryable`_ such that
>    `o2.query(get_scheduler)`{.cpp} is a prvalue with the same type and value as `sch`{.cpp}, and
>    such that `o2.query(get_domain)`{.cpp} is expression-equivalent to
>    `sch.query(get_domain)`]{.rm} [equivalent to
>    ```@_`MAKE-ENV`_@(get_scheduler, sch)```]{.add}.

[Remove the prototype of the exposition-only _`completion-domain`_ function just before
[exec.snd.expos]{.sref} paragraph 8, and with it remove paragraphs 8 and 9, which specify
the function's behavior.]{.ednote}

[Remove [exec.snd.expos]{.sref} paragraphs 13 and 14 and the prototypes for the
_`get-domain-early`_ and _`get-domain-late`_ functions.]{.ednote}

[Remove subsection [exec.domain.default]{.sref}.]{.ednote}

[Remove subsection [exec.snd.transform]{.sref}.]{.ednote}

[Remove subsection [exec.snd.transform.env]{.sref}.]{.ednote}

[Remove subsection [exec.snd.apply]{.sref}.]{.ednote}

[Change [exec.getcomplsigs]{.sref} as follows:]{.ednote}

> 1. Let _`except`_ be an rvalue subexpression of an unspecified class type _`Except`_ such
>    that ```move_constructible<@_`Except`_@> && derived_from<@_`Except`_@, exception>```{.cpp}
>    is `true`{.cpp}. Let ```@_`CHECKED-COMPLSIGS`_@(@_`e`_@)```{.cpp} be _`e`_ if _`e`_ is
>    a core constant expression whose type satisfies _`valid-completion-signatures`_;
>    otherwise, it is the following expression:
>
>    > ```cpp
>    > (@_`e`_@, throw @_`except`_@, completion_signatures())
>    > ```
>
>    Let ```@_`get-complsigs`_@<Sndr, Env...>()```{.cpp} be expression-equivalent to
>    ```remove_reference_t<Sndr>::template get_completion_signatures<Sndr, Env...>()```{.cpp}.
>    [Let `NewSndr`{.cpp} be `Sndr`{.cpp} if `sizeof...(Env) == 0`{.cpp} is `true`;
>    otherwise, ```decltype(@_`s`_@)```{.cpp} where _`s`_ is the following expression:]{.rm}
>    [Let `NewSndr`{.cpp} be
>    ```decltype(tag_of_t<Sndr>().@_`transform-sender`_@(declval<Sndr>(), declval<Env>()...))```
>    if that expression is well-formed, and `Sndr` otherwise.]{.add}
>
>    ::: rm
>
>    > ```cpp
>    > @@[```transform_sender(```]{.rm}@@
>    >   @@[```@_`get-domain-late`_@(declval<Sndr>(), declval<Env>()...),```]{.rm}@@
>    >   @@[```declval<Sndr>(),```]{.rm}@@
>    >   @@[```declval<Env>()...)```]{.rm}@@
>    > ```
>
>    :::
>
> 2. _Constraints_: `sizeof...(Env) <= 1`{.cpp} is `true`{.cpp}.
>
> 3. _Effects_: Equivalent to:  [&hellip; as before &hellip;]{.blue}


[Change [exec.connect]{.sref} as follows:]{.ednote}

> 1. `connect` connects ([exec.async.ops]{.sref}) a sender with a receiver.
>
> 2. The name `connect` denotes a customization point object. For subexpressions `sndr` and
>    `rcvr`, let `Sndr` be `decltype((sndr))` and `Rcvr` be `decltype((rcvr))`[,]{.rm}[;]{.add} let
>    `new_sndr` be the expression
>    [```transform_sender(decltype(@_`get-domain-late`_@(sndr, get_env(rcvr))){}, sndr, get_env(rcvr))```{.cpp}]{.rm}
>    [```tag_of_t<Sndr>().@_`transform-sender`_@(sndr, get_env(rcvr))```{.cpp} if that
>    expression is well-formed, and `sndr` otherwise;]{.add}
>    and let `DS` and `DR` be ```decay_t<decltype((new_sndr))>```{.cpp} and
>    `decay_t<Rcvr>`, respectively.
>
> 3. Let _`connect-awaitable-promise`_ be
>    [&hellip; as before &hellip;]{.blue}


[Change [exec.schedule]{.sref} paragraph 4 as follows:]{.ednote}

4. If the expression

   > ```cpp
   > get_completion_scheduler<set_value_t>(get_env(sch.schedule()))@[` == sch`]{.rm}@
   > ```

   is [ill-formed or]{.rm} [well-formed and does not]{.add} evaluate[s]{.rm} to
   [`false`]{.rm} [`sch`]{.add}, the behavior of calling `schedule(sch)` is undefined.

[From [exec.adapt.general]{.sref}, strike paragraph (3.6) as follows:]{.ednote}

> 3. Unless otherwise specified:
>
>    [&hellip; as before &hellip;]{.blue}
>
>    - [3.5]{.pnum} An adaptor whose child senders are all non-dependent
>      ([exec.async.ops]{.sref}) is itself non-dependent.
>
>    - [3.6]{.pnum} [These requirements apply to any function that is selected by the
>      implementation of the sender adaptor.]{.rm}
>
>    - [3.7]{.pnum} _Recommended practice_: Implementations should use the completion
>      signatures of the adaptors to communicate type errors to users and to propagate any such
>      type errors from child senders.

[Change [exec.starts.on]{.sref} paragraph 3 as follows:]{.ednote}

> 3. Otherwise, the expression `starts_on(sch, sndr)`{.cpp} is expression-equivalent to[:]{.rm}
>    [```@_`make-sender`_@(starts_on, sch, sndr)```{.cpp}.]{.add}
>
>    ::: rm
>
>    > ```cpp
>    > transform_sender(
>    >   @_`query-with-default`_@(get_domain, sch, default_domain()),
>    >   @_`make-sender`_@(starts_on, sch, sndr))
>    > ```
>
>    [except that `sch` is evaluated only once.]{.rm}
>
>    :::
>
> 4. Let `out_sndr` and `env` be subexpressions such that `OutSndr` is `decltype((out_sndr))`{.cpp}. If
>    ```@_`sender-for`_@<OutSndr, starts_on_t>``` is `false`, then the [expressions
>    `starts_on.transform_env(out_sndr, env)` and]{.rm} [expression]{.add}
>    ```starts_on.@[transform_sender]{.rm}[_`transform-sender`_]{.add}@(out_sndr, env)```
>    [are]{.rm} [is]{.add} ill-formed; otherwise [it is equivalent to:]{.add}
>
>    ::: rm
>
>    - [4.1]{.pnum} `starts_on.transform_env(out_sndr, env)` is equivalent to:
>
>      > ```cpp
>      > auto&& [_, sch, _] = out_sndr;
>      > return @_`JOIN-ENV`_@(@_`SCHED-ENV`_@(sch), @_`FWD-ENV`_@(env));
>      > ```
>
>    - [4.2]{.pnum} `starts_on.transform_sender(out_sndr, env)` is equivalent to:
>
>    :::
>
> > > ```cpp
> > > auto&& [_, sch, sndr] = out_sndr;
> > > return let_value(
> > >   schedule(sch),
> > >   [sndr = std::forward_like<OutSndr>(sndr)]() mutable
> > >     noexcept(is_nothrow_move_constructible_v<decay_t<OutSndr>>) {
> > >     return std::move(sndr);
> > >   });
> > > ```
>
> 5. Let `out_sndr` be
>    [&hellip; as before &hellip;]{.blue}


[Remove subsection [exec.continues.on]{.sref}]{.ednote}

[Change [exec.schedule.from]{.sref} to [exec.continues.on] and change it as follows:]{.ednote}

> **33.9.12.[7]{.rm}[6]{.add} ```execution::@[`schedule_from`]{.rm}[`continues_on`]{.add}@             ```{.cpp} [exec[.schedule.from]{.rm}[.continues.on]{.add}]**
>
>
> 1. [`schedule_from`]{.rm}[`continues_on`]{.add} schedules work dependent on the completion
>    of a sender onto a scheduler's associated execution resource.
>
>    [[_Note 1_:`schedule_from` is not meant to be used in user code; it is used in the
>    implementation of `continues_on`.  end note]]{.rm}
>
> 2. The name [`schedule_from`]{.rm}[`continues_on`]{.add} denotes a customization point
>    object. For some subexpressions `sch` and `sndr`, let `Sch` be `decltype((sch))` and
>    `Sndr` be `decltype((sndr))`. If `Sch` does not satisfy scheduler, or `Sndr` does not
>    satisfy `sender`,
>    [`schedule_from(sch, sndr)`{.cpp}]{.rm}[`continues_on(sndr, sch)`{.cpp}]{.add} is
>    ill-formed.
>
> 3. Otherwise, the expression
>    [`schedule_from(sch, sndr)`{.cpp}]{.rm}[`continues_on(sndr, sch)`{.cpp}]{.add} is
>    expression-equivalent to[:]{.rm} [```@_`make-sender`_@(continues_on, sch, sndr)```{.cpp}]{.add}
>
>    ::: rm
>
>    > ```cpp
>    > transform_sender(
>    >    @_`query-with-default`_@(get_domain, sch, default_domain()),
>    >    @_`make-sender`_@(schedule_from, sch, sndr))
>    > ```
>
>    except that sch is evaluated only once.
>
>    :::
>
> 4. The exposition-only class template _`impls-for`_ ([exec.snd.general]{.sref}) is
>    specialized for [`schedule_from_t`]{.rm}[`continues_on_t`]{.add} as follows:
>
>    > ```cpp
>    > namespace std::execution {
>    >    template<>
>    >    struct @_`impls-for`_@<@[`schedule_from_t`]{.rm}[`continues_on_t`]{.add}@> : @_`default-impls`_@ {
>    >       static constexpr auto @_`get-attrs`_@ = @_`see below`_@;
>    >       static constexpr auto @_`get-state`_@ = @_`see below`_@;
>    >       static constexpr auto @_`complete`_@ = @_`see below`_@;
>    >
>    >       template<class Sndr, class... Env>
>    >          static consteval void @_`check-types`_@();
>    >    };
>    > }
>    > ```
>
> 5. The member ```@_`impls-for`_@<@[`schedule_from_t`]{.rm}[`continues_on_t`]{.add}@>::@_`get-attrs`_@```{.cpp}
>    is initialized with a callable object equivalent to the following lambda:
>
>    > ```cpp
>    > [](const auto& data, const auto& child) noexcept -> decltype(auto) {
>    >    return @_`JOIN-ENV`_@(@_`SCHED-ATTRS`_@(data), @_`FWD-ENV`_@(get_env(child)));
>    > }
>    > ```
>
> 6. The member ```@_`impls-for`_@<@[`schedule_from_t`]{.rm}[`continues_on_t`]{.add}@>::@_`get-state`_@```{.cpp}
>    is initialized with a callable object equivalent to the following lambda:
>
>    [&hellip; as before &hellip;]{.blue}
>
> > ```cpp
> > template<class Sndr, class... Env>
> >   static consteval void @_`check-types`_@();
> > ```
>
> [&hellip; as before &hellip;]{.blue}
>
> 12. The member ```@_`impls-for`_@<@[`schedule_from_t`]{.rm}[`continues_on_t`]{.add}@>::@_`complete`_@```{.cpp}
>     is initialized with a callable object equivalent to the following lambda:
>
>     [&hellip; as before &hellip;]{.blue}
>
> 13. Let `out_sndr` be a subexpression denoting a sender returned from
>     [`schedule_from(sch, sndr)`]{.rm}[`continues_on(sndr, sch)`]{.add} or one equal to
>     such, and let `OutSndr` be the type `decltype((out_sndr))`. Let `out_rcvr` be
>     [&hellip; as before &hellip;]{.blue}


[Change [exec.on]{.sref} paragraphs 3-8 as follows:]{.ednote}


> 3. Otherwise, if `decltype((sndr))` satisfies `sender`, the expression `on(sch, sndr)` is
>    expression-equivalent to[:]{.rm} [```@_`make-sender`_@(on, sch, sndr)```{.cpp}.]{.add}
>
>    ::: rm
>
>    > ```cpp
>    > transform_sender(
>    >    @_`query-with-default`_@(get_domain, sch, default_domain()),
>    >    @_`make-sender`_@(on, sch, sndr))
>    > ```
>
>    except that `sch` is evaluated only once.
>
>    :::
>
>
> 4. For subexpressions `sndr`, `sch`, and `closure`, if
>
>    - [4.1]{.pnum} `decltype((sch))` does not satisfy `scheduler`, or
>
>    - [4.2]{.pnum} `decltype((sndr))` does not satisfy `sender`, or
>
>    - [4.3]{.pnum} `closure` is not a pipeable sender adaptor closure object
>      ([exec.adapt.obj]), the expression `on(sndr, sch, closure)` is ill-formed;
>      otherwise, it is expression-equivalent to[:]{.rm}
>      [```@_`make-sender`_@(on, @_`product-type`_@{sch, closure}, sndr)```{.cpp}.]{.add}
>
>      ::: rm
>
>      > ```cpp
>      > transform_sender(
>      >    @_`get-domain-early`_@(sndr),
>      >    @_`make-sender`_@(on, @_`product-type`_@{sch, closure}, sndr))
>      > ```
>
>      except that `sndr` is evaluated only once.
>
>      :::
>
> 5. Let `out_sndr` and `env` be subexpressions, let `OutSndr` be `decltype((out_sndr))`{.cpp},
>    and let `Env` be `decltype((env))`{.cpp}. If ```@_`sender-for`_@<OutSndr, on_t>```{.cpp}
>    is `false`, then the [expressions `on.transform_env(out_sndr, env)`{.cpp} and]{.rm}
>    [expression]{.add} ```on.@[`transform_sender`]{.rm}[_`transform-sender`_]{.add}@(out_sndr, env)```{.cpp}
>    [are]{.rm} [is]{.add} ill-formed.
>
> 6. Otherwise: Let _`not-a-scheduler`_ be an unspecified empty class type.
>
> ::: rm
>
> 7. The expression `on.transform_env(out_sndr, env)` has effects equivalent to:
>
>    > ```cpp
>    > auto&& [_, data, _] = out_sndr;
>    > if constexpr (scheduler<decltype(data)>) {
>    >   return @_`JOIN-ENV`_@(@_`SCHED-ENV`_@(std::forward_like<OutSndr>(data)), @_`FWD-ENV`_@(std::forward<Env>(env)));
>    > } else {
>    >   return std::forward<Env>(env);
>    > }
>    > ```
>
> :::
>
> 8. The expression ```on.@[`transform_sender`]{.rm}[_`transform-sender`_]{.add}@(out_sndr, env)```{.cpp}
>    has effects equivalent to:
>
>    > ```cpp
>    > auto&& [_, data, child] = out_sndr;
>    > if constexpr (scheduler<decltype(data)>) {
>    >    auto orig_sch =
>    >       @_`query-with-default`_@(get_scheduler, env, @_`not-a-scheduler`_@());
>    >
>    >    if constexpr (same_as<decltype(orig_sch), @_`not-a-scheduler`_@>) {
>    >       return @_`not-a-sender`_@{};
>    >    } else {
>    >       return continues_on(
>    >          starts_on(std::forward_like<OutSndr>(data), std::forward_like<OutSndr>(child)),
>    >          std::move(orig_sch));
>    >    }
>    > } else {
>    >    auto& [sch, closure] = data;
>    >    auto orig_sch = @_`query-with-default`_@(
>    >       get_completion_scheduler<set_value_t>,
>    >       get_env(child),
>    >       @_`query-with-default`_@(get_scheduler, env, @_`not-a-scheduler`_@()));
>    >
>    >    if constexpr (same_as<decltype(orig_sch), @_`not-a-scheduler`_@>) {
>    >       return @_`not-a-sender`_@{};
>    >    } else {
>    >       return @[`write_env`]{.rm} [`continues_on`]{.add}@(
>    >          @[`continues_on`]{.rm} [`write_env`]{.add}@(
>    >             std::forward_like<OutSndr>(closure)(
>    >                continues_on(
>    >                   write_env(std::forward_like<OutSndr>(child), @_`SCHED-ENV`_@(orig_sch)),
>    >                   sch)),
>    >             @[`orig_sch`]{.rm}@ @@[```@_`SCHED-ENV`_@(sch)```]{.add}@@),
>    >          @@[```@_`SCHED-ENV`_@(sch)```]{.rm}@@ @[`orig_sch`]{.add}@);
>    >    }
>    > }
>    > ```


[Change [exec.then]{.sref} paragraph 3 as follows:]{.ednote}

> 3. Otherwise, the expression ```@_`then-cpo`_@(sndr, f)```{.cpp} is expression-equivalent
>    to[:]{.rm} [```@_`make-sender`_@(@_`then-cpo`_@, f, sndr)```{.cpp}.]{.add}
>
>    ::: rm
>
>    > ```cpp
>    > transform_sender(@_`get-domain-early`_@(sndr), @_`make-sender`_@(@_`then-cpo`_@, f, sndr))
>    > ```
>
>    except that `sndr` is evaluated only once.
>
>    :::


[Change [exec.let]{.sref} paragraphs 2-4 as follows:]{.ednote}

> 2. For `let_value`, `let_error`, and `let_stopped`, let _`set-cpo`_ be `set_value`,
>    `set_error`, and `set_stopped`, respectively. Let the expression _`let-cpo`_ be one of
>    `let_value`, `let_error`, or `let_stopped`. For a subexpression `sndr`, let
>    ```@_`let-env`_@(sndr)```{.cpp} be expression-equivalent to
>    the first well-formed expression below:
>
>    - [2.1]{.pnum} ```@_`SCHED-ENV`_@(@_`get_completion_scheduler`_@<@_`decayed-typeof`_@<@_`set-cpo`_@>>(get_env(sndr)))```{.cpp}
>
>    ::: rm
>
>    - [2.2]{.pnum} ```@_`MAKE-ENV`_@(get_domain, get_domain(get_env(sndr)))```{.cpp}
>
>    :::
>
>    - [2.3]{.pnum} `(void(sndr), env<>{})`{.cpp}
>
> 3. The names `let_value`, `let_error`, and `let_stopped` denote
>    [&hellip; as before &hellip;]{.blue}
>
> 4. Otherwise, the expression ```@_`let-cpo`_@(sndr, f)```{.cpp} is expression-equivalent
>    to[:]{.rm} [```@_`make-sender`_@(@_`let-cpo`_@, f, sndr)```{.cpp}.]{.add}
>
>    ::: rm
>
>    > ```cpp
>    > transform_sender(@_`get-domain-early`_@(sndr), @_`make-sender`_@(@_`let-cpo`_@, f, sndr))
>    > ```
>
>    except that `sndr` is evaluated only once.
>
>    :::

<a name="proposed-wording-for-bulk"></a>

[Change [exec.bulk]{.sref} paragraphs 3 and 4 and insert paragraphs 5 and 6 as
follows:]{.ednote}

> 3. Otherwise, the expression ```@_`bulk-algo`_@(sndr, policy, shape, f)```{.cpp} is
>    expression-equivalent to:
>
>    ```cpp
>    @@[```transform_sender(@_`get-domain-early`_@(sndr),```{.cpp}]{.rm}@@ @_`make-sender`_@(
>       @_`bulk-algo`_@, @_`product-type`_@<@_`see below`_@, Shape, Func>{policy, shape, f}, sndr)@[`)`]{.rm}@
>    ```
>
>    [except that `sndr` is evaluated only once.]{.rm} The first template argument of
>    _`product-type`_ is `Policy` if `Policy` models `copy_constructible`, and `const Policy&`
>    otherwise.
>
> 4. Let `sndr` [and `env` be subexpressions]{.rm} [be an expression]{.add} such that
>    `Sndr` is `decltype((sndr))`. If ```@_`sender-for`_@<Sndr, bulk_t>```{.cpp} is
>    `false`, then the expression [`bulk.transform_sender(sndr, env)`{.cpp}]{.rm}
>    [```@_`as-bulk-chunked`_@(sndr)```{.cpp}]{.add} is ill-formed;
>    otherwise, it is equivalent to:
>
>    > ```cpp
>    > auto [_, data, child] = sndr;
>    > auto& [policy, shape, f] = data;
>    > auto new_f = [func = std::move(f)](Shape begin, Shape end, auto&&... vs)
>    >     noexcept(noexcept(f(begin, vs...))) {
>    >   while (begin != end)
>    >     func(begin++, vs...);
>    > }
>    > return bulk_chunked(std::move(child), policy, shape, std::move(new_f));
>    > ```
>
>    [[This causes the `bulk(sndr, policy, shape, f)` sender to be expressed in terms
>    of `bulk_chunked(sndr, policy, shape, f)` when it is connected to a receiver [whose
>    execution domain does not customize `bulk`]{.rm}.]{.note}]{.rm}
>
> ::: add
>
> 5. Let `sndr` and `env` be subexpressions, let `Sndr` be `decltype((sndr))`, and let
>    `sch` be expression-equivalent to
>    ```get_completion_scheduler<set_value_t>(get_env(sndr.@_`get`_@<2>()))```{.cpp}. If
>    ```@_`sender-for`_@<Sndr, @_`decayed-typeof`_@<@_`bulk-algo`_@>>```{.cpp} is `false`,
>    the expression ```@_`bulk-algo`_@.@_`transform-sender`_@(sndr, env)```{.cpp} is
>    ill-formed; otherwise, it is expression-equivalent to:
>
>    - [6.1]{.pnum} ```sch.@_`bulk-transform`_@(sndr, env)```{.cpp} if that expression is
>      well-formed; otherwise,
>
>    - [6.2]{.pnum} ```sch.@_`bulk-transform`_@(@_`as-bulk-chunked`_@(sndr), env)```{.cpp}
>      if that expression is well-formed; otherwise,
>
>    - [6.3]{.pnum} ```@_`bulk-algo`_@.@_`transform-sender`_@(sndr, env)```{.cpp} is
>      ill-formed.
>
> :::

[Change [exec.when.all]{.sref} as follows:]{.ednote}

> 1. `when_all` and `when_all_with_variant` both [&hellip; as before &hellip;]{.blue}
>
> 2. The names `when_all` and `when_all_with_variant` denote customization point objects.
>    Let `sndrs` be a pack of subexpressions[,]{.rm} [and]{.add} let `Sndrs` be a pack of
>    the types `decltype((sndrs))...`{.cpp}[, and let `CD` be the type
>    ```common_type_t<decltype(@_`get-domain-early`_@(sndrs))...>```{.cpp}. Let `CD2` be
>    `CD` if `CD` is well-formed, and `default_domain` otherwise]{.rm}. The expressions
>    `when_all(sndrs...)` and `when_all_with_variant(sndrs...)` are ill-formed if any of the
>    following is `true`:
>
>    - [2.1]{.pnum} `sizeof...(sndrs)`{.cpp} is `0`{.cpp}, or
>
>    - [2.2]{.pnum} `(sender<Sndrs> && ...)`{.cpp} is `false`{.cpp}.
>
> 3. The expression `when_all(sndrs...)` is expression-equivalent to[:]{.rm}
>    [```@_`make-sender`_@(when_all, {}, sndrs...)```.]{.add}
>
>    ::: rm
>
>    > ```cpp
>    > transform_sender(CD2(), @_`make-sender`_@(when_all, {}, sndrs...))
>    > ```
>
>    :::
>
> 4. The exposition-only class template _`impls-for`_ ([exec.snd.general]{.sref}) is
>    specialized for `when_all_t` as follows:
>
>    > ```cpp
>    > namespace std::execution {
>    >    template<>
>    >    struct @_`impls-for`_@<when_all_t> : @_`default-impls`_@ {
>    >       @@[```static constexpr auto @_`get-attrs`_@ = @_`see below`_@;```]{.rm}@@
>    >       static constexpr auto @_`get-env`_@ = @_`see below`_@;
>    >       static constexpr auto @_`get-state`_@ = @_`see below`_@;
>    >       static constexpr auto @_`start`_@ = @_`see below`_@;
>    >       static constexpr auto @_`complete`_@ = @_`see below`_@;
>    >
>    >       template<class Sndr, class... Env>
>    >          static consteval void @_`check-types`_@();
>    >    };
>    > }
>    > ```
>
> [&hellip; as before &hellip;]{.blue}
>
> 9. _Throws_: Any exception thrown as a result of evaluating the _Effects_[, or an exception
>    of an unspecified type derived from `exception` when `CD` is ill-formed]{.rm}.
>
> ::: rm
>
> 10. The member ```@_`impls-for`_@<when_all_t>::@_`get-attrs`_@```{.vpp} is initialized
>     with a callable object equivalent to the following lambda expression:
>
>     > ```cpp
>     > [](auto&&, auto&&... child) noexcept {
>     >    if constexpr (same_as<CD, default_domain>) {
>     >       return env<>();
>     >    } else {
>     >       return @_`MAKE-ENV`_@(get_domain, CD());
>     >    }
>     > }
>     > ```
>
> :::
>
> [&hellip; as before &hellip;]{.blue}
>
> 19. The expression `when_all_with_variant(sndrs...)`{.cpp} is expression-equivalent
>     to[:]{.rm} [```@_`make-sender`_@(when_all_with_variant, {}, sndrs...)```{.cpp}.]{.add}
>
>     ::: rm
>
>     > ```cpp
>     > transform_sender(CD2(), @_`make-sender`_@(when_all_with_variant, {}, sndrs...));
>     > ```
>
>     :::
>
> 20. Given subexpressions `sndr` and `env`, if
>     ```@_`sender-for`_@<decltype((sndr)), when_all_with_variant_t>```{.cpp} is
>     `false`{.cpp}, then the expression
>     ```when_all_with_variant.@[`transform_sender`]{.rm}[_`transform-sender`_]{.add}@(sndr, env)```{.cpp}
>     is ill-formed; otherwise, it is equivalent to:
>
>     > ```cpp
>     > auto&& [_, _, ...child] = sndr;
>     > return when_all(into_variant(std::forward_like<decltype((sndr))>(child))...);
>     > ```
>
>     [_Note 1_:This causes the `when_all_with_variant(sndrs...)`{.cpp} sender to become
>     `when_all(into_variant(sndrs)...)`{.cpp} when it is connected with a receiver [whose
>     execution domain does not customize `when_all_with_variant`]{.rm}.  _end note_]

[Change [exec.into.variant]{.sref} paragraph 3 as follows:]{.ednote}

> 3. Otherwise, the expression `into_variant(sndr)`{.cpp} is expression-equivalent to[:]{.rm}
>    [```@_`make-sender`_@(into_variant, {}, sndr)```{.cpp}.]{.add}
>
>    ::: rm
>
>    > ```cpp
>    > transform_sender(@_`get-domain-early`_@(sndr), @_`make-sender`_@(into_variant, {}, sndr))
>    > ```
>
>    except that `sndr` is only evaluated once.
>
>    :::

[Change [exec.stopped.opt]{.sref} paragraphs 2 and 4 as follows:]{.ednote}

> 2. The name `stopped_as_optional` denotes a pipeable sender adaptor object. For a
>    subexpression `sndr`, let `Sndr` be `decltype((sndr))`{.cpp}. The expression
>    `stopped_as_optional(sndr)` is expression-equivalent to[:]{.rm}
>    [```@_`make-sender`_@(stopped_as_optional, {}, sndr)```{.cpp}.]{.add}
>
>    ::: rm
>
>    > ```cpp
>    > transform_sender(@_`get-domain-early`_@(sndr), @_`make-sender`_@(stopped_as_optional, {}, sndr))
>    > ```
>
>    except that `sndr` is only evaluated once.
>
>    :::
>
> 3. The exposition-only class template _`impls-for`_ [&hellip; as before &hellip;]{.blue}
>
> 4. Let `sndr` and `env` be subexpressions such that `Sndr` is `decltype((sndr))`{.cpp}
>    and `Env` is `decltype((env))`{.cpp}. If ```@_`sender-for`_@<Sndr, stopped_as_optional_t>```{.cpp}
>    is `false` then the expression
>    ```stopped_as_optional.@[`transform_sender`]{.rm}[_`transform-sender`_]{.add}@(sndr, env)```{.cpp}
>    is ill-formed; otherwise,
>    if ```sender_in<@_`child-type`_@<Sndr>, @_`FWD-ENV-T`_@(Env)>```{.cpp} is `false`, the expression
>    ```stopped_as_optional.@[`transform_sender`]{.rm}[_`transform-sender`_]{.add}@(sndr, env)```{.cpp}
>    is equivalent to ```@_`not-a-sender`_@()```{.cpp}; otherwise, it is equivalent to:
>
>    > ```cpp
>    > auto&& [_, _, child] = sndr;
>    > using V = @_`single-sender-value-type`_@<@_`child-type`_@<Sndr>, @_`FWD-ENV-T`_@(Env)>;
>    > return let_stopped(
>    >   then(std::forward_like<Sndr>(child),
>    >         []<class... Ts>(Ts&&... ts) noexcept(is_nothrow_constructible_v<V, Ts...>) {
>    >            return optional<V>(in_place, std::forward<Ts>(ts)...);
>    >         }),
>    >   []() noexcept { return just(optional<V>()); });
>    > ```
>

[Change [exec.stopped.err]{.sref} paragraphs 2 and 3 as follows:]{.ednote}

> 2. The name `stopped_as_error` denotes a pipeable sender adaptor object. For some
>    subexpressions `sndr` and `err`, let `Sndr` be `decltype((sndr))`{.cpp} and let `Err`
>    be `decltype((err))`. If the type `Sndr` does not satisfy `sender` or if the type
>    `Err` does not satisfy _`movable-value`_, `stopped_as_error(sndr, err)` is
>    ill-formed. Otherwise, the expression `stopped_as_error(sndr)` is
>    expression-equivalent to[:]{.rm}
>    [```@_`make-sender`_@(stopped_as_error, err, sndr)```{.cpp}.]{.add}
>
>    ::: rm
>
>    > ```cpp
>    > transform_sender(@_`get-domain-early`_@(sndr), @_`make-sender`_@(stopped_as_error, err, sndr))
>    > ```
>
>    except that `sndr` is only evaluated once.
>
>    :::
>
> 2. Let `sndr` and `env` be subexpressions such that `Sndr` is `decltype((sndr))`{.cpp}
>    and `Env` is `decltype((env))`{.cpp}. If ```@_`sender-for`_@<Sndr, stopped_as_error_t>```{.cpp}
>    is `false` then the expression
>    ```stopped_as_error.@[`transform_sender`]{.rm}[_`transform-sender`_]{.add}@(sndr, env)```{.cpp}
>    is ill-formed; otherwise, it is equivalent to:
>
>    > ```cpp
>    > auto&& [_, err, child] = sndr;
>    > using E = decltype(auto(err));
>    > return let_stopped(
>    >   std::forward_like<Sndr>(child),
>    >   [err = std::forward_like<Sndr>(err)]() noexcept(is_nothrow_move_constructible_v<E>) {
>    >     return just_error(std::move(err));
>    >   });
>    > ```

[Change [exec.associate]{.sref} paragraph 10 as follows:]{.ednote}

> 10. The name `associate` denotes a pipeable sender adaptor object. For subexpressions `sndr`
>     and `token`:
>
>     - [10.1]{.pnum} If `decltype((sndr))`{.cpp} does not satisfy `sender`, or
>       `remove_cvref_t<decltype((token))>`{.cpp} does not satisfy `scope_token`, then
>       `associate(sndr, token)` is ill-formed.
>
>     - [10.2]{.pnum} Otherwise, the expression `associate(sndr, token)` is
>       expression-equivalent to[:]{.rm}
>       [```@_`make-sender`_@(associate, @_`associate-data`_@(token, sndr))```{.cpp}.]{.add}
>
>       ::: rm
>
>       > ```cpp
>       > transform_sender(@_`get-domain-early`_@(sndr),
>       >                  @_`make-sender`_@(associate, @_`associate-data`_@(token, sndr)))
>       > ```
>
>       except that `sndr` is evaluated only once.
>
>       :::

[Change [exec.sync.wait]{.sref} paragraphs 4 and 9 as follows:]{.ednote}

> 4. The name `this_thread::sync_wait`{.cpp} denotes a customization point object. For a
>    subexpression `sndr`, let `Sndr` be `decltype((sndr))`{.cpp}. The expression
>    `this_thread::sync_wait(sndr)`{.cpp} is expression-equivalent to [the
>    following, except that `sndr` is evaluated only once:]{.rm}
>    [```sync_wait.@_`apply`_@(sndr)```{.cpp}, where _`apply`_ is the exposition-only
>    member function specified below.]{.add}
>
>    ::: rm
>
>    > ```cpp
>    > apply_sender(@_`get-domain-early`_@(sndr), sync_wait, sndr)
>    > ```
>
>    :::
>
>    _Mandates_:
>
>    - [4.1]{.pnum} ```sender_in<Sndr, @_`sync-wait-env`_@>```{.cpp} is true.
>
>    - [4.2]{.pnum} The type ```@_`sync-wait-result-type`_@<Sndr>```{.cpp} is well-formed.
>
>    ::: rm
>
>    - [4.3]{.pnum} ```same_as<decltype(@_`e`_@), @_`sync-wait-result-type`_@<Sndr>>```{.cpp}
>      is `true`, where _`e`_ is the `apply_sender` expression i>
>    :::
>
> [&hellip; as before &hellip;]{.blue}
>
> 9. For a subexpression `sndr`, let `Sndr` be `decltype((sndr))`{.cpp}. If
>    ```sender_to<Sndr, @_`sync-wait-receiver`_@<Sndr>>```{.cpp} is `false`{.cpp}, the
>    expression ```sync_wait.@[`apply_sender`]{.rm}[_`apply`_]{.add}@(sndr)```{.cpp} is
>    ill-formed; otherwise, it is equivalent to:
>
>    ```cpp
>    @_`sync-wait-state`_@<Sndr> state;
>    auto op = connect(sndr, @_`sync-wait-receiver`_@<Sndr>{&state});
>    start(op);
>
>    state.loop.run();
>    if (state.error) {
>      rethrow_exception(std::move(state.error));
>    }
>    return std::move(state.result);
>    ```

[Change _Note 1_ in [exec.sync.wait]{.sref} paragraph 10.1 as follows:]{.ednote}

> [_Note 1_:The [default]{.rm} implementation of `sync_wait` achieves forward progress
> guarantee delegation by providing a `run_loop` scheduler via the
> `get_delegation_scheduler` query on the _`sync-wait-receiver`_'s environment. The
> `run_loop` is driven by the current thread of execution.  _end note_]


[Change [exec.sync.wait.var]{.sref} paragraphs 1 and 2 as follows:]{.ednote}

> 1. The name `this_thread::sync_wait_with_variant` denotes a customization point
>    object. For a subexpression `sndr`, let `Sndr` be
>    `decltype(into_variant(sndr))`{.cpp}. The expression
>    `this_thread::sync_wait_with_variant(sndr)`{.sref} is expression-equivalent to [the
>    following, except `sndr` is evaluated only once:]{.rm}
>    [```sync_wait_with_variant.@_`apply`_@(sndr)```{.cpp}, where _`apply`_ is the
>    exposition-only member function specified below.]{.add}
>
>    ::: rm
>
>    > ```cpp
>    > apply_sender(get-domain-early(sndr), sync_wait_with_variant, sndr)
>    > ```
>
>    :::
>
>    _Mandates_:
>
>    - [1.1]{.pnum} ```sender_in<Sndr, @_`sync-wait-env`_@>```{.cpp} is `true`{.cpp}.
>
>    - [1.2]{.pnum} The type ```@_`sync-wait-with-variant-result-type`_@<Sndr>```{.cpp} is well-formed.
>
>    ::: rm
>
>    - [1.3]{.pnum} ```same_as<decltype(@_`e`_@), @_`sync-wait-with-variant-result-type`_@<Sndr>>```{.cpp}
>      is `true`{.cpp}, where _`e`_ is the `apply_sender` expression i>
>    :::
>
> 2. The expression ```sync_wait_with_variant.@[`apply_sender`]{.rm}[_`apply`_]{.add}@(sndr)```{.cpp}
>    is equivalent to:
>
>    > ```cpp
>    > using result_type = @_`sync-wait-with-variant-result-type`_@<Sndr>;
>    > if (auto opt_value = sync_wait(into_variant(sndr))) {
>    >   return result_type(std::move(get<0>(*opt_value)));
>    > }
>    > return result_type(nullopt);
>    > ```

[Change _Note 1_ in [exec.sync.wait]{.sref} paragraph 10.1 as follows:]{.ednote}

> [_Note 1_:The [default]{.rm} implementation of `sync_wait_with_variant` achieves
> forward progress guarantee delegation ([intro.progress]{.sref}) by relying on the
> forward progress guarantee delegation provided by `sync_wait`.  _end note_]


[Change [exec.env]{.sref} as follows:]{.ednote}

> > ```cpp
> > namespace std::execution {
> >   template<@_`queryable`_@... Envs>
> >   struct env {
> >     @Envs~0~ envs~0~@;               // exposition only
> >     @Envs~1~ envs~1~@;               // exposition only
> >       
> >     @Envs~*n*-1~ envs~*n*-1~@;            // exposition only
> >
> >     template<class QueryTag@[`, class... Args`]{.add}@>
> >       constexpr decltype(auto) query(QueryTag q@[`, Args&&... args`]{.add}@) const noexcept(@_`see below`_@);
> >   };
> >
> >   template<class... Envs>
> >     env(Envs...) -> env<unwrap_reference_t<Envs>...>;
> > }
> > ```
>
> 1. The class template `env` is used to construct a queryable object from several
>    queryable objects. Query invocations on the resulting object are resolved by
>    attempting to query each subobject in lexical order.
>
> > [&hellip; as before &hellip;]{.blue}
>
> > ```cpp
> > template<class QueryTag@[`, class... Args`]{.add}@>
> > constexpr decltype(auto) query(QueryTag q@[`, Args&&... args`]{.add}@) const noexcept(@_`see below`_@);
> > ```
>
> 5. Let _`has-query`_ be the following exposition-only concept:
>
>    > ```cpp
>    > template<class Env, class QueryTag@[`, class... Args`]{.add}@>
>    >   concept @_`has-query`_@ =                   // exposition only
>    >     requires (const Env& env@[`, Args&&... args`]{.add}@) {
>    >       env.query(QueryTag()@[`, std::forward<Args>(args)...`]{.add}@);
>    >     };
>    > ```
>
> 6. Let _`fe`_ be the first element of ```@_envs_~0~@, @_envs_~1~@, @&hellip;@ @_envs_~_n_-1~@```{.cpp}
>    such that the expression ```@_`fe`_@.query(q@[`, std::forward<Args>(args)...`]{.add}@)```{.cpp}
>    is well-formed.
>
> 7. _Constraints_: ```(@_`has-query`_@<Envs, QueryTag@[`, Args...`]{.add}@> || ...)```{.cpp} is `true`{.cpp}.
>
> 8. _Effects_: Equivalent to: ```return @_`fe`_@.query(q@[`, std::forward<Args>(args)...`]{.add}@);```{.cpp}
>
> 9. _Remarks_: The expression in the `noexcept`{.cpp} clause is equivalent to
>    ```noexcept(@_`fe`_@.query(q@[`, std::forward<Args>(args)...`]{.add}@))```{.cpp}.


[In [exec.run.loop.types]{.sref}, add a new paragraph after paragraph 4 as follows:]{.ednote}

> 4. Let _`sch`_ be an expression of type _`run-loop-scheduler`_. The expression
>    `schedule(sch)`{.cpp} has type _`run-loop-sender`_ and is not potentially-throwing if
>    _`sch`_ is not potentially-throwing.
>
> ::: add
>
> 5. For type _`set-tag`_ other than `set_error_t`, the expression
>    ```get_completion_scheduler<@_`set-tag`_@>(get_env(schedule(@_`sch`_@))) == @_`sch`_@```{.cpp}
>    evaluates to `true`.
>
> :::


[Change [exec.affine.on]{.sref} paragraph 3 as follows:]{.ednote}

> 3. Otherwise, the expression `affine_on(sndr, sch)`{.cpp} is expression-equivalent
>    to[:]{.rm} [```@_`make-sender`_@(affine_on, sch, sndr)```{.cpp}.]{.add}
>
>    ::: rm
>
>    > ```cpp
>    > transform_sender(@_`get-domain-early`_@(sndr), @_`make-sender`_@(affine_on, sch, sndr))
>    > ```
>
>    except that `sndr` is evaluated only once.
>
>    :::


[Change paragraph 3 of [exec.inline.scheduler]{.sref} as follows:]{.ednote}

> 3. Let sndr be an expression of type _`inline-sender`_, let `rcvr` be an expression such
>    that `receiver_of<decltype((rcvr)), CS>`{.cpp} is `true`{.cpp} where `CS` is
>    `completion_signatures<set_value_t()>`{.cpp}, then[:]{.rm} [Move the text of (3.1)
>    below into this paragraph.]{.ednote}
>
>    [3.1]{.pnum} the expression `connect(sndr, rcvr)` has type
>    ```@_`inline-state`_@<remove_cvref_t<decltype((rcvr))>>```{.cpp} and is
>    potentially-throwing if and only if `((void)sndr, auto(rcvr))`{.cpp} is
>    potentially-throwing[, and]{.rm}[.]{.add}
>
>    ::: rm
>
>    [3.2]{.pnum} the expression
>    `get_completion_scheduler<set_value_t>(get_env(sndr))`{.cpp} has type
>    `inline_scheduler` and is potentially-throwing if and only if `get_env(sndr)`{.cpp} is
>    potentially-throwing.
>
>    :::

[Change [exec.task.scheduler]{.sref} as follows:]{.ednote}

> ```cpp
> namespace std::execution {
>   class task_scheduler {
>     @@[```class @_`ts-sender`_@;                    @_// exposition only_@```]{.rm}@@
>
>     @@[```template<receiver R>```]{.rm}@@
>       @@[```class state;                      @_// exposition only_@```]{.rm}@@
>
>     @@[```template<class Sch>```]{.add}@@
>       @@[```class @_`backend-for`_@;              @_// exposition only_@```]{.add}@@
>   public:
>     using scheduler_concept = scheduler_t;
>
>     template<class Sch, class Allocator = allocator<void>>
>       requires (!same_as<task_scheduler, remove_cvref_t<Sch>>) && scheduler<Sch>
>     explicit task_scheduler(Sch&& sch, Allocator alloc = {});
>
>     @[_`ts-sender`_]{.rm}[_`see below`_]{.add}@ schedule();
>
>     @@[```template <class Sndr, class Env>     @_// exposition only_@```]{.add}@@
>       @@[```@_`see below`_@ @_`bulk-transform`_@(Sndr&& sndr, const Env& env);```]{.add}@@
>
>     friend bool operator==(const task_scheduler& lhs, const task_scheduler& rhs) noexcept;
>
>     template<class Sch>
>       requires (!same_as<task_scheduler, Sch>) && scheduler<Sch>
>     friend bool operator==(const task_scheduler& lhs, const Sch& rhs) noexcept;
>
>   private:
>     shared_ptr<@[`void`]{.rm}[`parallel_scheduler_backend`]{.add}@> @_`sch_`_@; // exposition only
>                                                      @[_`// see [exec.sysctxrepl.psb]`_]{.add}@
>   };
> }
> ```
>
> 1. `task_scheduler` is a class that models `scheduler` ([exec.sched]{.sref}). Given an object
>    `s` of type `task_scheduler`, let ```@_`SCHED`_@(s)```{.cpp} be [the _`sched_`_ member
>    of]{.add} the object owned by ``s.@_`sch_`_@``.
>
> ::: add
>
> 2. For an lvalue `r` of type derived from `receiver_proxy`, let ```@_`WRAP-RCVR`_@(r)```{.cpp}
>    be an object of a type that models `receiver` and whose
>    completion handlers result in invoking the corresponding completion handlers of `r`.
>
> > ```cpp
> > template<class Sch>
> > struct @_`backend-for`_@ : parallel_scheduler_backend {           @_`// exposition only`_@
> >   explicit @_`backend-for`_@(Sch sch) : sched_(std::move(sch)) {}
> >
> >   void schedule(receiver_proxy& r, span<byte> s) noexcept override;
> >   void schedule_bulk_chunked(size_t shape, bulk_item_receiver_proxy& r,
> >                              span<byte> s) noexcept override;
> >   void schedule_bulk_unchunked(size_t shape, bulk_item_receiver_proxy& r,
> >                                span<byte> s) noexcept override;
> >
> >   Sch @_`sched_`_@; @_`// exposition only`_@
> > };
> > ```
>
> 3. Let `sndr` be a sender whose only value completion signature is
>    `set_value_t()` and for which the expression
>    ```get_completion_scheduler<set_value_t>(get_env(sndr)) == @_`sched_`_@```{.cpp} is
>    `true`.
>
> > ```cpp
> > void schedule(receiver_proxy& r, span<byte> s) noexcept override;
> > ```
>
> 4. _Effects_: Constructs an operation state `os` with
>    ```connect(schedule(@_`sched_`_@), @_`WRAP-RCVR`_@(r))```{.cpp} and calls `start(os)`.
>
> > ```cpp
> > void schedule_bulk_chunked(size_t shape, bulk_item_receiver_proxy& r,
> >                            span<byte> s) noexcept override;
> > ```
>
> 5. _Effects_: Let `chunk_size` be an integer less than or equal to `shape`, let
>    `num_chunks` be `(shape + chunk_size - 1) / chunk_size`, and let `fn` be a function
>    object such that for an integer `i`, `fn(i)` calls `r.execute(i * chunk_size, m)`,
>    where `m` is the lesser of `(i + 1) * chunk_size` and `shape`. Constructs an
>    operation state `os` as if with
>    ```connect(bulk(sndr, par, num_chunks, fn), @_`WRAP-RCVR`_@(r))```{.cpp} and calls
>    `start(os)`.
>
> > ```cpp
> > void schedule_bulk_unchunked(size_t shape, bulk_item_receiver_proxy& r,
> >                              span<byte> s) noexcept override;
> > ```
>
> 6. _Effects_: Let `fn` be a function object such that for an integer `i`, `fn(i)` is
>    equivalent to `r.execute(i, i + 1)`. Constructs an operation state `os` as if with
>    ```connect(bulk(sndr, par, shape, fn), @_`WRAP-RCVR`_@(r))```{.cpp} and calls
>    `start(os)`.
>
> :::
>
> > ```cpp
> > template<class Sch, class Allocator = allocator<void>>
> >   requires(!same_as<task_scheduler, remove_cvref_t<Sch>>) && scheduler<Sch>
> > explicit task_scheduler(Sch&& sch, Allocator alloc = {});
> > ```
>
> 2. _Effects_: Initialize _`sch_`_ with
>    ```allocate_shared<@[_`backend-for`_<]{.add}@remove_cvref_t<Sch>@[`>`]{.add}@>(alloc, std::forward<Sch>(sch))```{.cpp}.
>
> [Paragraphs 3-7 are kept unmodified. Remove paragraphs 8-12 and add the following
> paragraphs:]{.ednote}
>
> ::: add
>
> ```cpp
> @_`see below`_@ schedule();
> ```
>
> 8. _Returns_: a prvalue `sndr` whose type `Sndr` models `sender` such that:
>
>    - [8.1]{.pnum} `get_completion_scheduler<set_value_t>(get_env(sndr))`{.cpp} is equal
>      to `*this`{.cpp}.
>
>    - [8.2]{.pnum} If a receiver `rcvr` is connected to `sndr` and the resulting
>      operation state is started, calls ``@_`sch_`_@->schedule(r, s)``, where
>
>      - [8.2.1]{.pnum} `r` is a proxy for `rcvr` with base
>        `system_context_replaceability::receiver_proxy`{.cpp}
>        ([exec.par.scheduler]{.sref}) and
>
>      - [8.2.2]{.pnum} `s` is a preallocated backend storage for `r`.
>
> ```cpp
> template <class BulkSndr, class Env>     @_// exposition only_@
>   @_`see below`_@ @_`bulk-transform`_@(BulkSndr&& bulk_sndr, const Env& env);
> ```
>
> 9. _Constraints_: `sender_in<BulkSndr, Env>` is `true` and either
>    ```@_`sender-for`_@<BulkSndr, bulk_chunked_t>```{.cpp} or
>    ```@_`sender-for`_@<BulkSndr, bulk_unchunked_t>```{.cpp} is `true`.
>
> 10. _Returns_: a prvalue `sndr` whose type models `sender` such that:
>
>     - [10.1]{.pnum} `get_completion_scheduler<set_value_t>(get_env(sndr))`{.cpp} is
>       equal to `*this`{.cpp}.
>
>     - [10.2]{.pnum} `bulk_sndr` is connected to an unspecified receiver if a receiver
>       `rcvr` is connected to `sndr`. If the resulting operation state is started,
>
>       - [10.2.1]{.pnum} If `bulk_sndr` completes with values `vals`, let `args` be a
>         pack of lvalue subexpressions designating objects decay-copied from `vals`. Then
>
>         - [10.2.1.1]{.pnum} If `bulk_sndr` is the result of calling `bulk_chunked(child,
>           policy, shape, f)`, ```@_`sch_`_@->schedule_bulk_chunked(shape, r, s)```{.cpp} is
>           called where `r` is a bulk chunked proxy for `rcvr` with callable `f` and
>           arguments `args`, and `s` is a preallocated backend storage for `r`.
>
>         - [10.2.1.2]{.pnum} Otherwise, `bulk_sndr` is the result of calling
>           `bulk_unchunked(child, policy, shape, f)`. Calls
>           ```@_`sch_`_@->schedule_bulk_unchunked(shape, r, s)```{.cpp} where `r` is a bulk
>           unchunked proxy for `rcvr` with callable `f` and arguments `args`, and `s` is
>           a preallocated backend storage for `r`.
>
>       - [10.2.2]{.pnum} All other completion operations are forwarded unchanged.
>
> :::


<a name="proposed-wording-for-parallel-scheduler"></a>

[In [exec.par.scheduler]{.sref}, add a new paragraph after paragraph 3, another before
paragraph 10, and change paragraphs 10 and 11 as follows:]{.ednote}


> 3. The expression `get_forward_progress_guarantee(sch)`{.cpp} returns
>    `forward_progress_guarantee::parallel`.
>
> ::: add
>
> [?.]{.npnum} The expression
> `get_completion_scheduler<set_value_t>(get_env(schedule(sch))) == sch`{.cpp} evaluates
> to `true`.
>
> :::
>
> [&hellip; as before &hellip;]{.blue}
>
> ::: add
>
> [?.]{.npnum} Let `sch` be a subexpression of type `parallel_scheduler`. For
>     subexpressions `sndr` and `env`, if `tag_of_t<Sndr>` is neither `bulk_chunked_t` nor
>     `bulk_unchunked_t`, the expression ```sch.@_`bulk-transform`_@(sndr, env)```{.cpp}
>     is ill-formed; otherwise, let `child`, `pol`, `shape`, and `f` be subexpressions
>     equal to the arguments used to create `sndr`.
>
> :::
>
> 10. [`parallel_scheduler` provides a customized implementation of the `bulk_chunked`
>     algorithm ([exec.bulk]{.sref}). If a receiver `rcvr` is connected to the sender
>     returned by `bulk_chunked(sndr, pol, shape, f)`{.cpp}]{.rm} [When the tag type of
>     `sndr` is `bulk_chunked_t`, the expression
>     ```sch.@_`bulk-transform`_@(sndr, env)```{.cpp} returns a sender such
>     that if it is connected to a receiver `rcvr`]{.add} and the resulting operation
>     state is started, then:
>
>     - [10.1]{.pnum} If [`sndr`]{.rm}[`child`]{.add} completes with values `vals`, let
>       `args` be a pack of lvalue subexpressions designating `vals`, then
>       `b.schedule_bulk_chunked(shape, r, s)`{.cpp} is called, where
>
>       - [10.1.1]{.pnum} `r` is a bulk chunked proxy for `rcvr` with callable `f` and
>         arguments `args` and
>
>       - [10.1.2]{.pnum} `s` is a preallocated backend storage for `r`.
>
>     - [10.2]{.pnum} All other completion operations are forwarded unchanged.
>
>     [Customizing the behavior of `bulk_chunked` affects the [default]{.rm}
>     implementation of `bulk`.]{.note}
>
> 11. [`parallel_scheduler` provides a customized implementation of the `bulk_unchunked`
>     algorithm ([exec.bulk]{.sref}). If a receiver `rcvr` is connected to the sender
>     returned by `bulk_unchunked(sndr, pol, shape, f)`{.cpp}]{.rm} [When the tag type of
>     `sndr` is `bulk_unchunked_t`, the expression ```sch.@_`bulk-transform`_@(sndr, env)```{.cpp}
>     returns a sender such that if it is connected to a receiver `rcvr`]{.add} and the
>     resulting operation state is started, then:
>
>     - [11.1]{.pnum} If [`sndr`]{.rm}[`child`]{.add} completes with values `vals`, let
>       `args` be a pack of lvalue subexpressions designating `vals`, then
>       `b.schedule_bulk_unchunked(shape, r, s)`{.cpp} is called, where
>
>       - [11.1.1]{.pnum} `r` is a bulk unchunked proxy for `rcvr` with callable `f` and
>         arguments `args` and
>
>       - [11.1.2]{.pnum} `s` is a preallocated backend storage for `r`.
>
>     - [11.2]{.pnum} All other completion operations are forwarded unchanged.


# Appendix A: Listing for updated `transform_sender`

The proposal requires some changes to how `transform_sender` operates. This new
`transform_sender` still accepts a sender and an environment like the current one, but it
no longer accepts a domain. It computes the two domains, starting and completing, and
applies the two transforms, recursing if a transform changes the type of the sender.

The implementation of `transform_sender` might look something like this:

> ```cpp
> template <class A, class B>
> concept @_`same-decayed`_@ = std::same_as<std::decay_t<A>, std::decay_t<B>>;
>
> template <class Domain, class Tag>
> struct @_`transform-sender-recurse`_@
> {
>   template <class Sndr, class Env>
>   using @_`result-t`_@ =
>     decltype(Domain().transform_sender(Tag(), declval<Sndr>(), declval<const Env&>()));
>
>   constexpr @_`transform-sender-recurse`_@(Domain, Tag) noexcept {}
>
>   template <class Sndr, class Env>
>   decltype(auto) operator()(Sndr&& sndr, const Env& env) const
>   {
>     if constexpr (!requires { typename @_`result-t`_@<Sndr, Env>; })
>     {
>       // Domain does not have a transform_sender for this sndr so use default_domain instead.
>       return @_`transform-sender-recurse`_@<default_domain, Tag>()(forward<Sndr>(sndr), env);
>     }
>     else if constexpr (@_`same-decayed`_@<Sndr, @_`result-t`_@<Sndr, Env>>)
>     {
>       // Domain can transform the sender but its type does not change. End recursion.
>       return Domain().transform_sender(Tag(), std::forward<Sndr>(sndr), env);
>     }
>     else if constexpr (same_as<Tag, start_t>)
>     {
>       // The starting domain cannot change, so recurse on Domain
>       return @_`transform-sender-recurse`_@<Domain, Tag>()(
>         Domain().transform_sender(set_value, std::forward<Sndr>(sndr), env), env);
>     }
>     else
>     {
>       // The type of sndr changes after being transformed, so the type of the completion
>       // domain could change too. Recurse on the (possibly) new domain:
>       using attrs_t  = env_of_t<@_`result-t`_@<Sndr, Env>>;
>       using domain_t = decltype(get_completion_domain<set_value_t>(declval<attrs_t>(), env));
>
>       return @_`transform-sender-recurse`_@<domain_t, Tag>()(
>         Domain().transform_sender(set_value, std::forward<Sndr>(sndr), env), env);
>     }
>   }
> };
>
> template <class Sndr, class Env>
> auto transform_sender(Sndr&& sndr, const Env& env)
> {
>   auto starting_domain    = get_domain(env);
>   auto complete_domain    = get_completion_domain<set_value_t>(get_env(sndr), env);
>
>   auto starting_transform = @_`transform-sender-recurse`_@(starting_domain, start);
>   auto complete_transform = @_`transform-sender-recurse`_@(complete_domain, set_value);
>
>   return starting_transform(complete_transform(std::forward<Sndr>(sndr), env), env);
> }
> ```

With this definition of `transform_sender`, `connect(sndr, rcvr)` is equivalent to
`transform_sender(sndr, get_env(rcvr)).connect(rcvr)`.




<!-- -->
