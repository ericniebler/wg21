---
title: "Defer Sender Algorithm Customization to Post-C++26"
document: D3826R0
date: today
audience:
  - "SG1 Concurrency and Parallelism Working Group"
  - "LEWG Library Evolution Working Group"
  - "LWG Library Working Group"
author:
  - name: Eric Niebler
    email: <eric.niebler@gmail.com>
toc: true
---


# Background

In the current Working Draft, [exec]{.sref} has sender algorithms that are customizable.
While the sender/receiver concepts and the algorithms themselves have been stable for
several years now, the customization mechanism has seen a fair bit of recent churn.
[@P3718R0] is the latest effort to shore up the mechanism. Unfortunately, there are gaps
in its proposed resolution. This paper details those gaps.

The problems are fixable although the fixes are non-trivial. The time for elaborate fixes
has passed. This paper proposes to remove the ability to customize sender algorithms for
C++26. A future paper will propose to add the feature back post-'26.

The author feels that postponing the feature (details below) will be a less disruptive and
safer change than trying to patch it at the last minute. Most common usages of
sender/receiver will not be affected. The negative impacts are described below.

# The problem with P3718

[@P3718R0] identifies real problems with the status quo of sender algorithm customization.
It proposes using information from the sender about where it will *complete* during
"early" customization, which happens when a sender algorithm constructs and returns a
sender; and it proposes using information from the receiver about where the operation will
*start* during "late" customization, when the sender and the receiver are connected.

The problem with this separation of responsibilities is that many senders do not know
where they will complete until they know where they will be started. A simple example is
the `just()`{.cpp} sender; it completes inline wherever it is started. And the information about
where a sender will start is not known during early customization, when the sender is being
asked for this information.

For the expression `then(sndr, fn)`{.cpp} for example, if the `then`{.cpp} CPO asks `sndr`{.cpp} where it
will complete, `sndr`{.cpp} might not be able to answer, in which case no "early" customization
is performed. And during "late" (`connect`-time) customization, only the receiver's
information about where the operation will start is used to find a customization.
Presumably an algorithm like `then(sndr, fn)`{.cpp} would want to dispatch based on where the
function `fn`{.cpp} will execute, but for some expressions that cannot be achieved with what
is proposed in P3718.

An illustrative example is:

> ```cpp
> namespace ex = std::execution;
> auto sndr = ex::starts_on(gpu, ex::just()) | ex::then(fn);
> std::this_thread::sync_wait(std::move(sndr));
> ```

... where `gpu`{.cpp} is a scheduler that runs work (unsurprisingly) on a GPU.

`fn`{.cpp} will execute on the GPU, so a GPU implementation of `then`{.cpp} should be used. By the
proposed resolution of P3718, algorithm customization proceeds as follows:

* During early customization, when `starts_on(gpu, just()) | then(fn)`{.cpp} is executing,
  the `then`{.cpp} CPO asks the `starts_on(gpu, just())`{.cpp} sender where it will complete
  as if by:

  > ```cpp
  > auto&& @_`tmp1`_@ = ex::starts_on(gpu, ex::just());
  > auto @_`dom1`_@ = ex::get_domain(ex::get_env(@_`tmp1`_@));
  > ```

* The `starts_on`{.cpp} sender will in turn ask the `just()`{.cpp} sender, as if by:

  > ```cpp
  > auto&& @_`tmp2`_@ = ex::just();
  > auto @_`dom2`_@ = ex::get_domain(ex::get_env(@_`tmp2`_@));
  > ```

  As discussed above, the `just()`{.cpp} sender doesn't know where it will complete until
  it knows where it will be started, but that information is not available. As a result,
  _`dom2`_ ends up as `default_domain`{.cpp}, which is then reported as the domain for the
  `starts_on`{.cpp} sender. That's incorrect. The `starts_on`{.cpp} sender will complete on the GPU.

* The `then`{.cpp} CPO uses `default_domain`{.cpp} to find an implementation of the `then`{.cpp} algorithm,
  which will find the default implementation. As a result, the `then`{.cpp} CPO returns an
  ordinary `then`{.cpp} sender.

* When that `then`{.cpp} sender is connected to `sync_wait`{.cpp}'s receiver, late customization
  happens. `connect`{.cpp} asks `sync_wait`{.cpp}'s receiver where the `then`{.cpp} sender will be started.
  It does that with `get_domain(get_env(rcvr))`{.cpp}. `sync_wait`{.cpp} starts operations on
  the current thread, so the `get_domain`{.cpp} query will return `default_domain`{.cpp}. As with
  early customization, late customization will also not find a GPU implementation.

The end result of all of this is that a CPU implementation will be used to evaluate
the `then`{.cpp} algorithm on the GPU. That is a bad state of affairs.

# Removal process

The algorithm customization feature can be removed cleanly. Here is what it will entail:

1. Remove the type `default_domain`{.cpp} ([exec.domain.default]{.sref}).

2. Remove the functions:

   * `transform_sender`{.cpp} ([exec.snd.transform]{.sref}),
   * `transform_env`{.cpp} ([exec.snd.transform.env]{.sref}), and
   * `apply_sender`{.cpp} ([exec.snd.apply]{.sref}).

3. Remove the query object `get_domain`{.cpp} ([exec.get.domain]{.sref}).

4. Remove the exposition-only helpers:

   * _`completion-domain`_ ([exec.snd.expos]{.sref}/8-9),
   * _`get-domain-early`_ ([exec.snd.expos]{.sref}/13), and
   * _`get-domain-late`_ ([exec.snd.expos]{.sref}/14).

5. Change the functions `get_completion_signatures`{.cpp} ([exec.getcomplsigs]{.sref}) and
   `connect`{.cpp} ([exec.connect]{.sref}) to operate on a sender determined as follows
   instead of passing the sender through `transform_sender`{.cpp} first:

   * If the sender has a tag with an exposition-only _`transform-sender`_ member function,
     pass the sender to this function with the receiver's environment and continue the
     operation on the resulting sender.
   
   * Otherwise, perform the operation on the passed-in sender.

6. For the following algorithms that are currently expressed in terms of a sender
   transformation to a lowered form, move the lowering from
   `@_alg_@.transform_sender(sndr, env)`{.cpp} to `@_alg_@.@_transform-sender_@(sndr, env)`.

   * `starts_on`{.cpp} ([exec.starts.on]{.sref}),
   * `continues_on`{.cpp} ([exec.continues.on]{.sref}),
   * `on`{.cpp} ([exec.on]{.sref}),
   * `bulk`{.cpp} ([exec.bulk]{.sref}),
   * `when_all_with_variant`{.cpp} ([exec.when.all]{.sref}),
   * `stopped_as_optional`{.cpp} ([exec.stopped.opt]{.sref}), and
   * `stopped_as_error`{.cpp} ([exec.stopped.err]{.sref}).

7. For each sender adaptor algorithm in [exec.adapt]{.sref} that is specified to be
   expression-equivalant to some `transform_sender`{.cpp} invocation of the form:

   > ```cpp
   > transform_sender(@_`some-computed-domain`_@(), @_`make-sender`_@(tag, {args...}, sndr));
   > ```

   Change the expression to:

   > ```cpp
   > @_`make-sender`_@(tag, {args...}, sndr);
   > ```

   For example, in [exec.continues.on]{.sref}/3, the following:

   > ```cpp
   > transform_sender(@_`get-domain-early`_@(sndr), @_`make-sender`_@(continues_on, sch, sndr))
   > ```

   would be changed to:

   > ```cpp
   > @_`make-sender`_@(continues_on, sch, sndr)
   > ```

   Additionally, if there is some caveat of the form "except that `sndr`{.cpp} is
   evaluated only once," that caveat should be removed as appropriate.

8. Merge the `schedule_from`{.cpp} ([exec.schedule.from]{.sref}) and `continues_on`{.cpp}
   ([exec.continues.on]{.sref}) algorithms into one algorithm called `continues_on`{.cpp}.
   (Currently they are separate so that they can be customized independently; by default
   `continues_on`{.cpp} merely dispatches to `schedule_from`{.cpp}.)

9. Change [exec.sync.wait]{.sref} and [exec.sync.wait.var]{.sref} to dispatch directly to
   their default implementations instead of computing a domain and using `apply_sender`{.cpp} to
   dispatch to an implementation.

10. Change [exec.affine.on]{.sref} TODO

11. Tweak the wording of `parallel_scheduler`{.cpp} ([exec.par.scheduler]{.sref}) to indicate
   that it (`parallel_scheduler`) is permitted to run the `bulk`{.cpp} family of algorithms in
   parallel in accordance with those algorithms' semantics, rather than suggesting that
   those algorithms are "customized" for `parallel_scheduler`{.cpp}. The mechanism for such
   is left unspecified.

This is admittedly a lot of changes, but each of these changes represents a simplification
from the status quo. The result will be a vastly simpler specification for [exec].

# Downsides of delaying sender alg customization

Until we add the feature back...

* ... users will not have a standard API for accelerating the standard `bulk`{.cpp} family of
  algorithms on their own parallel execution contexts (e.g., thread pools). 

* ... hardware vendors like NVIDIA will not be able to ship a scheduler for an exotic
  (non-CPU-ish) execution context and have it work with any standard-conforming
  implementation of std::execution.

This is only a temporary state of affairs. I describe below how the feature can be added
post-C++26 non-intrusively.

# Adding the feature back

Post-C++26, we can add back a way to query a sender/receiver for the domains on which
the async operation will start and complete. Such a query will have a default: the
`default_domain`{.cpp} that represents execution on a standard thread of execution. The query
will be a so-called "forwarding" query, so it will get passed through adaptation layers
automatically without needing to change any senders or receivers.

At this point, we can change `connect`{.cpp}, `get_completion_signatures`{.cpp}, and the sender
algorithms to check for this domain information and use it to find transforms and/or
customizations. This will not affect any senders already in the wild, none of which will
have such a domain query.


# Proposed resolution

[THIS SECTION IS INCOMPLETE]{.ednote}

[In [execution.syn]{.sref}, make the following changes:]{.ednote}

> ```cpp
> @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
> 
> namespace std::execution {
>   // [exec.queries], queries
>   @@[```struct get_domain_t { @_`unspecified`_@ };```]{.rm}@@
>   struct get_scheduler_t { @_`unspecified`_@ };
>   struct get_delegation_scheduler_t { @_`unspecified`_@ };
>   struct get_forward_progress_guarantee_t { @_`unspecified`_@ };
>   template<class CPO>
>     struct get_completion_scheduler_t { @_`unspecified`_@ };
>   struct get_await_completion_adaptor_t { @_`unspecified`_@ };
> 
>   @@[```inline constexpr get_domain_t get_domain{};```]{.rm}@@
>   inline constexpr get_scheduler_t get_scheduler{};
>   inline constexpr get_delegation_scheduler_t get_delegation_scheduler{};
>   enum class forward_progress_guarantee;
>   inline constexpr get_forward_progress_guarantee_t get_forward_progress_guarantee{};
>   template<class CPO>
>     constexpr get_completion_scheduler_t<CPO> get_completion_scheduler{};
>   inline constexpr get_await_completion_adaptor_t get_await_completion_adaptor{};
>
> @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
> 
>   // [exec.env], class template env
>   template<queryable... Envs>
>     struct env;
> 
>   @@[_```// [exec.domain.default], execution domains```_]{.rm}@@
>   @@[```struct default_domain;```]{.rm}@@
> 
>   // [exec.sched], schedulers
>   struct scheduler_t {};
>
> @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
> 
>   template<sender Sndr>
>     using tag_of_t = @_`see below`_@;
> 
>   @@[_```// [exec.snd.transform], sender transformations```_]{.rm}@@
>   @@[```template<class Domain, sender Sndr, queryable... Env>```]{.rm}@@
>       @@[```requires (sizeof...(Env) <= 1)```]{.rm}@@
>     @@[```constexpr sender decltype(auto) transform_sender(```]{.rm}@@
>       @@[```Domain dom, Sndr&& sndr, const Env&... env) noexcept(@_`see below`_@);```]{.rm}@@
>
>   @@[_```// [exec.snd.transform.env], environment transformations```_]{.rm}@@
>   @@[```template<class Domain, sender Sndr, queryable Env>```]{.rm}@@
>     @@[```constexpr queryable decltype(auto) transform_env(```]{.rm}@@
>       @@[```Domain dom, Sndr&& sndr, Env&& env) noexcept;```]{.rm}@@
>
>   @@[_```// [exec.snd.apply], sender algorithm application```_]{.rm}@@
>   @@[```template<class Domain, class Tag, sender Sndr, class... Args>```]{.rm}@@
>     @@[```constexpr decltype(auto) apply_sender(```]{.rm}@@
>       @@[```Domain dom, Tag, Sndr&& sndr, Args&&... args) noexcept(@_`see below`_@);```]{.rm}@@
> 
>   // [exec.connect], the connect sender algorithm
>   struct connect_t;
>   inline constexpr connect_t connect{};
>
> @<span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>@
> ```


[Remove subsection [exec.get.domain]{.sref}.]{.ednote}


[In [exec.sched]{.sref}, remove paragraph 6 as follows:]{.ednote}

::: rm

> 6. [For a given scheduler expression `sch`{.cpp}, if the expression `get_domain(sch)`{.cpp} is
>    well-formed, then the expression `get_domain(get_env(schedule(sch)))`{.cpp} is also
>    well-formed and has the same type.]{.rm}

:::

[In [exec.snd.general]{.sref}, change paragraph 1 as follows:]{.ednote}

> 1. Subclauses [exec.factories]{.sref} and [exec.adapt]{.sref} define [customizable]{.rm}
>    algorithms that return senders. [Each algorithm has a default implementation.]{.rm} Let
>    `sndr`{.cpp} be the result of an invocation of such an algorithm or an object equal to the
>    result ([concepts.equality]{.sref}), and let `Sndr`{.cpp} be `decltype((sndr))`{.cpp}. Let `rcvr`{.cpp}
>    be a receiver of type `Rcvr`{.cpp} with associated environment env of type `Env`{.cpp} such that
>    `sender_to<Sndr, Rcvr>`{.cpp} is `true`{.cpp}. [For the default implementation of the algorithm
>    that produced `sndr`{.cpp}, c]{.rm}[C]{.add}onnecting `sndr`{.cpp} to `rcvr`{.cpp} and starting the
>    resulting operation state ([exec.async.ops]{.sref}) necessarily results in the
>    potential evaluation ([basic.def.odr]{.sref}) of a set of completion operations whose
>    first argument is a subexpression equal to `rcvr`{.cpp}. Let `Sigs`{.cpp} be a pack of completion
>    signatures corresponding to this set of completion operations, and let `CS`{.cpp} be the type
>    of the expression `get_completion_signatures<Sndr, Env>()`{.cpp}. Then `CS`{.cpp} is a
>    specialization of the class template `completion_signatures`{.cpp} ([exec.cmplsig]{.sref}),
>    the set of whose template arguments is `Sigs`{.cpp}. If none of the types in `Sigs`{.cpp} are
>    dependent on the type `Env`{.cpp}, then the expression `get_completion_signatures<Sndr>()`{.cpp} is
>    well-formed and its type is `CS`{.cpp}. [If a user-provided implementation of the algorithm
>    that produced `sndr`{.cpp} is selected instead of the default:]{.rm}
> 
>    - [[1.1]{.pnum} Any completion signature that is in the set of types denoted by
>      `completion_signatures_of_t<Sndr, Env>`{.cpp} and that is not part of `Sigs`{.cpp} shall
>      correspond to error or stopped completion operations, unless otherwise specified.]{.rm}
> 
>    - [[1.2]{.pnum} If none of the types in `Sigs`{.cpp} are dependent on the type `Env`{.cpp}, then
>      `completion_signatures_of_t<Sndr>`{.cpp} and `completion_signatures_of_t<Sndr, Env>`{.cpp} shall
>      denote the same type.]{.rm}

[Change [exec.snd.expos]{.sref} paragraph 6 as follows:]{.ednote}

> 6. For a scheduler `sch`{.cpp}, ```@_`SCHED-ATTRS`_@(sch)```{.cpp} is [an expression `o1`{.cpp} whose type
>    satisfies _`queryable`_ such that `o1.query(get_completion_scheduler<Tag>)`{.cpp} is an
>    expression with the same type and value as `sch`]{.rm} [equivalent to
>    ```@_`MAKE-ENV`_@(get_completion_scheduler<Tag>, sch)```]{.add} where `Tag`{.cpp} is one of
>    `set_value_t`{.cpp} or `set_stopped_t`[, and such that `o1.query(get_domain)`{.cpp} is
>    expression-equivalent to `sch.query(get_domain)`]{.rm}. ```@_`SCHED-ENV`_@(sch)```{.cpp} is
>    [an expression `o2`{.cpp} whose type satisfies _`queryable`_ such that
>    `o2.query(get_scheduler)`{.cpp} is a prvalue with the same type and value as `sch`{.cpp}, and
>    such that `o2.query(get_domain)`{.cpp} is expression-equivalent to
>    `sch.query(get_domain)`]{.rm} [equivalent to
>    ```@_`MAKE-ENV`_@(get_scheduler, sch)```]{.add}.

[Remove the prototype of the exposition-only _`completion-domain`_ function just before
[exec.snd.expos]{.sref} paragraph 8, and with it remove paragraphs 8 and 9, which specify
the function's behavior.]{.ednote}

[Remove [exec.snd.expos]{.sref} paragraphs 13 and 14 and the prototypes for the
_`get-domain-early`_ and _`get-domain-late`_ functions.]{.ednote}

[Remove subsection [exec.domain.default]{.sref}.]{.ednote}

[Remove subsection [exec.snd.transform]{.sref}.]{.ednote}

[Remove subsection [exec.snd.transform.env]{.sref}.]{.ednote}

[Remove subsection [exec.snd.apply]{.sref}.]{.ednote}

[Change [exec.getcomplsigs]{.sref} as follows:]{.ednote}

> 1. Let _`except`_ be an rvalue subexpression of an unspecified class type _`Except`_ such
>    that ```move_constructible<@_`Except`_@> && derived_from<@_`Except`_@, exception>```{.cpp}
>    is `true`{.cpp}. Let ```@_`CHECKED-COMPLSIGS`_@(@_`e`_@)```{.cpp} be _`e`_ if _`e`_ is
>    a core constant expression whose type satisfies _`valid-completion-signatures`_;
>    otherwise, it is the following expression:
>    
>    > ```cpp
>    > (@_`e`_@, throw @_`except`_@, completion_signatures())
>    > ```
>    
>    Let ```@_`get-complsigs`_@<Sndr, Env...>()```{.cpp} be expression-equivalent to
>    ```remove_reference_t<Sndr>​::​template get_completion_signatures<Sndr, Env...>()```{.cpp}.
>    [Let `NewSndr`{.cpp} be `Sndr`{.cpp} if `sizeof...(Env) == 0`{.cpp} is `true`;
>    otherwise, ```decltype(@_`s`_@)```{.cpp} where _`s`_ is the following expression:]{.rm}
>    [Let `NewSndr`{.cpp} be
>    ```decltype(tag_of_t<Sndr>().@_`transform-sender`_@(declval<Sndr>(), declval<Env>()...))```
>    if that expression is well-formed, and `Sndr` otherwise.]{.add}
> 
>    ::: rm
> 
>    > ```cpp   
>    > @@[```transform_sender(```]{.rm}@@
>    >   @@[```@_`get-domain-late`_@(declval<Sndr>(), declval<Env>()...),```]{.rm}@@
>    >   @@[```declval<Sndr>(),```]{.rm}@@
>    >   @@[```declval<Env>()...)```]{.rm}@@
>    > ```
> 
>    :::
> 
> 2. _Constraints_: `sizeof...(Env) <= 1`{.cpp} is `true`{.cpp}.
> 
> 3. _Effects_: Equivalent to:  <span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>


[Change [exec.connect]{.sref} as follows:]{.ednote}

> 1. `connect` connects ([exec.async.ops]{.sref}) a sender with a receiver.
> 
> 2. The name `connect` denotes a customization point object. For subexpressions `sndr` and
>    `rcvr`, let `Sndr` be `decltype((sndr))` and `Rcvr` be `decltype((rcvr))`[,]{.rm}[;]{.add} let
>    `new_sndr` be the expression
>    [```transform_sender(decltype(@_`get-domain-late`_@(sndr, get_env(rcvr))){}, sndr, get_env(rcvr))```{.cpp}]{.rm}
>    [```tag_of_t<Sndr>().@_`transform-sender`_@(sndr, get_env(rcvr))```{.cpp} if that
>    expression is well-formed, and `sndr` otherwise;]{.add}
>    and let `DS` and `DR` be ```decay_t<decltype((new_sndr))>```{.cpp} and
>    `decay_t<Rcvr>`, respectively.
> 
> 3. Let _`connect-awaitable-promise`_ be
>    <span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>


[From [exec.adapt.general]{.sref}, strike paragraph (3.6) as follows:]{.ednote}

> 3. Unless otherwise specified:
>
>    <span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>
>
>    - [3.5]{.pnum} An adaptor whose child senders are all non-dependent
>      ([exec.async.ops]{.sref}) is itself non-dependent.
>    
>    - [3.6]{.pnum} [These requirements apply to any function that is selected by the
>      implementation of the sender adaptor.]{.rm}
>    
>    - [3.7]{.pnum} _Recommended practice_: Implementations should use the completion
>      signatures of the adaptors to communicate type errors to users and to propagate any such
>      type errors from child senders.

[Change [exec.starts.on]{.sref} paragraph 3 as follows:]{.ednote}

> 3. Otherwise, the expression `starts_on(sch, sndr)`{.cpp} is expression-equivalent to[:]{.rm}
>    [```@_`make-sender`_@(starts_on, sch, sndr)```{.cpp}.]{.add}
> 
>    ::: rm
> 
>    > ```cpp
>    > transform_sender(
>    >   @_`query-with-default`_@(get_domain, sch, default_domain()),
>    >   @_`make-sender`_@(starts_on, sch, sndr))
>    > ```
> 
>    [except that `sch` is evaluated only once.]{.rm}
> 
>    :::
>
> 4. Let `out_sndr` and `env` be subexpressions such that `OutSndr` is `decltype((out_sndr))`{.cpp}. If
>    ```@_`sender-for`_@<OutSndr, starts_on_t>``` is `false`, then the [expressions
>    `starts_on.transform_env(out_sndr, env)` and]{.rm} [expression]{.add}
>    ```starts_on.@[transform_sender]{.rm}[_`transform-sender`_]{.add}@(out_sndr, env)```
>    [are]{.rm} [is]{.add} ill-formed; otherwise [it is equivalent to:]{.add}
>
>    ::: rm
>
>    - [4.1]{.pnum} `starts_on.transform_env(out_sndr, env)` is equivalent to:
>
>      > ```cpp
>      > auto&& [_, sch, _] = out_sndr;
>      > return @_`JOIN-ENV`_@(@_`SCHED-ENV`_@(sch), @_`FWD-ENV`_@(env));
>      > ```
>
>    - [4.2]{.pnum} `starts_on.transform_sender(out_sndr, env)` is equivalent to:
>
>    :::
>
> > > ```cpp
> > > auto&& [_, sch, sndr] = out_sndr;
> > > return let_value(
> > >   schedule(sch),
> > >   [sndr = std::forward_like<OutSndr>(sndr)]() mutable
> > >     noexcept(is_nothrow_move_constructible_v<decay_t<OutSndr>>) {
> > >     return std::move(sndr);
> > >   });
> > > ```
>
> 5. Let `out_sndr` be 
>    <span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>


[Remove subsection [exec.continues.on]{.sref}]{.ednote}

[Change [exec.schedule.from]{.sref} to [exec.continues.on] and change it as follows:]{.ednote}

> **33.9.12.[7]{.rm}[6]{.add} ```execution::@[`schedule_from`]{.rm}[`continues_on`]{.add}@             ```{.cpp} [exec[.schedule.from]{.rm}[.continues.on]{.add}]**
> 
> 
> 1. [`schedule_from`]{.rm}[`continues_on`]{.add} schedules work dependent on the completion
>    of a sender onto a scheduler's associated execution resource.
> 
>    [[_Note 1_:` schedule_from` is not meant to be used in user code; it is used in the
>    implementation of `continues_on`. — end note]]{.rm}
> 
> 2. The name [`schedule_from`]{.rm}[`continues_on`]{.add} denotes a customization point
>    object. For some subexpressions `sch` and `sndr`, let `Sch` be `decltype((sch))` and
>    `Sndr` be `decltype((sndr))`. If `Sch` does not satisfy scheduler, or `Sndr` does not
>    satisfy `sender`,
>    [`schedule_from(sch, sndr)`{.cpp}]{.rm}[`continues_on(sndr, sch)`{.cpp}]{.add} is
>    ill-formed.
> 
> 3. Otherwise, the expression
>    [`schedule_from(sch, sndr)`{.cpp}]{.rm}[`continues_on(sndr, sch)`{.cpp}]{.add} is
>    expression-equivalent to[:]{.rm} [```@_`make-sender`_@(continues_on, sch, sndr)```{.cpp}]{.add}
> 
>    ::: rm
> 
>    > ```cpp
>    > transform_sender(
>    >    @_`query-with-default`_@(get_domain, sch, default_domain()),
>    >    @_`make-sender`_@(schedule_from, sch, sndr))
>    > ```
> 
>    except that sch is evaluated only once.
> 
>    :::
> 
> 4. The exposition-only class template _`impls-for`_ ([exec.snd.general]{.sref}) is
>    specialized for [`schedule_from_t`]{.rm}[`continues_on_t`]{.add} as follows:
> 
>    > ```cpp
>    > namespace std::execution {
>    >    template<>
>    >    struct @_`impls-for`_@<@[`schedule_from_t`]{.rm}[`continues_on_t`]{.add}@> : @_`default-impls`_@ {
>    >       static constexpr auto @_`get-attrs`_@ = @_`see below`_@;
>    >       static constexpr auto @_`get-state`_@ = @_`see below`_@;
>    >       static constexpr auto @_`complete`_@ = @_`see below`_@;
>    >
>    >       template<class Sndr, class... Env>
>    >          static consteval void @_`check-types`_@();
>    >    };
>    > }
>    > ```
> 
> 5. The member ```@_`impls-for`_@<@[`schedule_from_t`]{.rm}[`continues_on_t`]{.add}@>​::@_`​get-attrs`_@```{.cpp}
>    is initialized with a callable object equivalent to the following lambda:
> 
>    > ```cpp
>    > [](const auto& data, const auto& child) noexcept -> decltype(auto) {
>    >    return @_`JOIN-ENV`_@(@_`SCHED-ATTRS`_@(data), @_`FWD-ENV`_@(get_env(child)));
>    > }
>    > ```
> 
> 6. The member ```@_`impls-for`_@<@[`schedule_from_t`]{.rm}[`continues_on_t`]{.add}@>​::@_`​get-state`_@```{.cpp}
>    is initialized with a callable object equivalent to the following lambda:
> 
>    <span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>
> 
> > ```cpp
> > template<class Sndr, class... Env>
> >   static consteval void @_`check-types`_@();
> > ```
> 
> 7. _Effects_: Equivalent to:
> 
>    <span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>
> 
> 8. Objects of the local class _`state-type`_ can be used to initialize a structured binding.
> 
> 9. Let `Sigs` be a pack of
>    <span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>
> 
> 10. `receiver_t` is an alias for
>    <span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>
> 
> 11. The expression in the `noexcept` clause 
>    <span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>
> 
> 12. The member ```@_`impls-for`_@<@[`schedule_from_t`]{.rm}[`continues_on_t`]{.add}@>​::@_`complete`_@```{.cpp}
>     is initialized with a callable object equivalent to the following lambda:
> 
>     > <span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>
> 
> 13. Let `out_sndr` be a subexpression denoting a sender returned from
>     [`schedule_from(sch, sndr)`]{.rm}[`continues_on(sndr, sch)`]{.add} or one equal to
>     such, and let `OutSndr` be the type `decltype((out_sndr))`. Let `out_rcvr` be
>    <span style="color:blue;font-style:italic">&hellip; as before &hellip;</span>

<!--

[Remove [exec.starts.on] paragraphs 4 and 5, and replace them with the following
paragraph:]{.ednote}

4. The exposition-only class template _`impls-for`_ ([exec.snd.general]{.sref}) is
   specialized for `starts_on_t` as follows:

   namespace std::execution {
     template<>
       struct impls-for<starts_on_t> : default-impls {
         static constexpr auto get-attrs = see below;
         static constexpr auto get-state = see below;
         static constexpr auto complete = see below;
         
         template<class Sndr, class... Env>
           static consteval void check-types();
       };
   }

5. The member impls-for<schedule_from_t>​::​get-attrs is initialized with a callable object equivalent to the following lambda:
[](const auto& data, const auto& child) noexcept -> decltype(auto) {
  return JOIN-ENV(SCHED-ATTRS(data), FWD-ENV(get_env(child)));
}

-->

[THIS SECTION IS INCOMPLETE]{.ednote}
