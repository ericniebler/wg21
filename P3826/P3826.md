---
title: "Fix Sender Algorithm Customization"
document: P3826R3
date: today
audience:
  - "SG1 Concurrency and Parallelism Working Group"
  - "LEWG Library Evolution Working Group"
  - "LWG Library Working Group"
author:
  - name: Eric Niebler
    email: <eric.niebler@gmail.com>
toc: true
---

# Background

In the current Working Draft, [exec]{.sref} has sender algorithms that are customizable.
While the sender/receiver concepts and the algorithms themselves have been stable for
several years now, the customization mechanism has seen a fair bit of recent churn.
[@P3718R0] is the latest effort to shore up the mechanism. Unfortunately, there are gaps
in its proposed resolution. This paper details those gaps.

The problem and its solution are easy to describe, but the changes are not trivial. The
fix has been implemented twice, largely independently and causing no bug reports. This
paper proposes to fix the issue for C++26.

# Revision history

## R3

* Addresses feedback from the LEWG review of R2 (see [](#design-review-feedback)).
   - Adds a `get_completion_domain<>(attrs, env...)` query that defaults to
     `get_completion_domain<set_value_t>(attrs, env...)`.
* Remove all discussion of deferring algorithm customization to C++29.

## R2

* Adds `indeterminate_domain<>`.

## R1

* Adds an alternative resolution that suggests how to fix algorithm customization for
  C++26.

## R0

* Initial revision that proposes deferring algorithm customization to C++29.

# The problem with P3718

[@P3718R0] identifies real problems with the status quo of sender algorithm customization.
It proposes using information from the sender about where it will *complete* during
"early" customization, which happens when a sender algorithm constructs and returns a
sender; and it proposes using information from the receiver about where the operation will
*start* during "late" customization, when the sender and the receiver are connected.

The problem with this separation of responsibilities is:

<center>**Many senders do not know where they will complete until they know where they will be
started.**</center>

A simple example is the `just()`{.cpp} sender; it completes inline wherever it is started.
The information about where a sender will start is not known during early customization,
when the sender is being asked for this information.

And even if we knew where the sender will start, there is no generic interface for asking
a sender where it will complete _given where it will start_. There currently is no such
API, which is the whole problem in a nutshell.

## An illustrative example

This section illustrates the above problem by walking through the algorithm selection
process proposed by P3718. Consider the following example:

> ```cpp
> namespace ex = std::execution;
> auto sndr = ex::starts_on(gpu, ex::just()) | ex::then(fn);
> std::this_thread::sync_wait(std::move(sndr));
> ```

... where `gpu` is a scheduler that runs work (unsurprisingly) on a GPU.

`fn`{.cpp} will execute on the GPU, so a GPU implementation of `then`{.cpp} should be used. By the
proposed resolution of P3718, algorithm customization proceeds as follows:

* During early customization, when `starts_on(gpu, just()) | then(fn)`{.cpp} is executing,
  the `then`{.cpp} CPO asks the `starts_on(gpu, just())`{.cpp} sender where it will complete
  as if by:

  > ```cpp
  > auto& [_, fn, child1] = *this; // *this is a then sender
  >                                // child1 is a starts_on sender
  > auto dom1 = ex::get_domain(ex::get_env(child1));
  > ```

* The `starts_on`{.cpp} sender will in turn ask the `just()`{.cpp} sender, as if by:

  > ```cpp
  > auto& [_, sch, child2] = *this;  // *this is a starts_on sender
  >                                  // child2 is a just sender
  > auto dom2 = ex::get_domain(ex::get_env(child2));
  > ```

  As discussed, the `just()`{.cpp} sender doesn't know where it will complete until
  it knows where it will be started, but that information is not yet available. As a
  result, `dom2` ends up as `default_domain`{.cpp}, which is then reported as the domain
  for the `starts_on`{.cpp} sender. That's incorrect. The `starts_on`{.cpp} sender will
  complete on the GPU.

* The `then`{.cpp} CPO uses `default_domain`{.cpp} to find an implementation of the
  `then`{.cpp} algorithm, which will find the default implementation. As a result, the
  `then`{.cpp} CPO returns an ordinary `then`{.cpp} sender.

* When that `then`{.cpp} sender is connected to `sync_wait`{.cpp}'s receiver, late
  customization happens. `connect`{.cpp} asks `sync_wait`{.cpp}'s receiver where the
  `then`{.cpp} sender will be started. It does that with the query
  `get_domain(get_env(rcvr))`{.cpp}. `sync_wait`{.cpp} starts operations on the current
  thread, so the `get_domain`{.cpp} query will return `default_domain`{.cpp}. As with
  early customization, late customization will also not find a GPU implementation.

The end result of all of this is that a default (which is effectively a CPU)
implementation will be used to evaluate the `then`{.cpp} algorithm on the GPU. That is a
bad state of affairs.

# Solutions considered

Here is a list of possible ways to address this problem for C++26, sorted by descending
awfulness.

## Remove all of the C++26 `std::execution` additions

Although the safest option, I hope most agree that such a drastic step is not warranted by
this issue. Pulling the `sender` abstraction and everything that depends on it would result
in the removal of:

- The sender/receiver-related concepts and customization points, without which
  the ecosystem will have no shared async abstraction, and which will set back the
  adoption of structured concurrency three years.

- The sender algorithms, which capture common async patterns and make them reusable,

- `execution::counting_scope` and `execution::simple_counting_scope`, and related
  features for incremental adoption of structured concurrency,

- `execution::parallel_scheduler` and all of its related APIs, and

- `execution::task` and `execution::task_scheduler` (C++26 will _still_
  not have a standard coroutine task type <small><em>&lt;heavy sigh&gt;</em></small>).

This option should only be considered if all the other options are determined to have
unacceptable risk.

## Remove all of the customizable sender algorithms

This option would keep all of the above library components with the exception of the
customizable sender algorithms:

- `then`, `upon_error`, `upon_stopped`
- `let_value`, `let_error`, `let_stopped`
- `bulk`, `bulk_chunked`, `bulk_unchunked`
- `starts_on`, `continues_on`, `on`
- `when_all`, `when_all_with_variant`
- `stopped_as_optional`, `stopped_as_error`
- `into_variant`
- `sync_wait`
- `affine_on`

This would leave users with no easy standard way to start work on a given execution
context, or transition to another execution context, or to execute work in parallel,
or to wait for work to finish.

In fact, without the `bulk` algorithms, we leave no way for the `parallel_scheduler`
to execute work in parallel!

While still delivering a standard async abstraction with minimal risk, the loss of the
algorithms would make it _just_ an abstraction. Like coroutines, adoption of senders as an
async _lingua franca_ will be hampered by lack of standard library support.

## Remove sender algorithm customization

In this option, we ship everything currently in the Working Draft but remove the ability to
customize the algorithms. This gives us a free hand to design a better customization
mechanism for C++29 -- provided we have confidence that those new customization hooks
can be added without break existing behavior.

This option is not as low-risk as it may seem. Firstly, it is difficult to be confident
that algorithm customization can be added back without breaking code. Improved
customization hooks have been implemented, and wording for the removal has been written
such that that the new hooks can be standardized without breaking changes, to the best of
the author's ability.

Secondly, algorithm customizability is a load-bearing feature. Taking it out is not hard
but it isn't trivial either. Customizability is used by the `parallel_scheduler` to
accelerate the `bulk` family of algorithms. Although the `task_scheduler` does not
currently customize `bulk`, it should. Some design work is necessary before algorithm
customization can be removed.

## Ship everything as-is and fix algorithm customization in a DR

This option is not as reckless as it sounds. We have a fix and the fix has been
implemented in a working and publicly available `execution` library
([CCCL](https://github.com/NVIDIA/cccl)). It would not be the first time the Committee
shipped a standard with known defects, and the DR process exists for just this purpose.

One potential problem is that, as DRs go, this one would be large-ish. I do not
know if this presents a problem procedurally. If it does, then fixing the problem
now would make more sense. Any future DRs are likely to be smaller.

## Fix algorithm customization now

This is the option this paper proposes. The fix is easy to describe:

<center>**When asking a sender where it will complete, _tell it where it will start_.**</center>

That is done by passing the receiver's environment when asking the sender for its
completion domain. Instead of `get_domain(get_env(sndr))`, the query would be
`get_domain(get_env(sndr), get_env(rcvr))` (but with a query other than
`get_domain`, read on).

That change has some ripple effects, the biggest of which is that the receiver is not
known during early customization. Therefore, early customization is irreparably broken and
must be removed.

::: callout

[There are no algorithms in `std::execution` that are affected by the removal of early
customization since they all do their work lazily. Should a future algorithm be added that
eagerly connects a sender, that algorithm should accept an optional execution environment
by which users can provide the starting domain. That is not onerous.]{.callout-content}

:::

There are other ripples from the proposed change. They are described in full detail in
section [](#fixing-algorithm-customization).

There are risks with trying to fix the problem now. It is a design change happening
uncomfortably close to the release of C++26. One mitigating factor is that the major
Standard Library vendors seem to be in no rush to implement `std::execution`. If there are
lingering problems, they could be fixed with the usual DR process.

This fix has been implemented in NVIDIA's [CCCL](https://github.com/NVIDIA/cccl) library
since mid-September 2025 (see
[NVIDIA/cccl#5793](https://github.com/NVIDIA/cccl/pull/5793)) and in
[stdexec](https://github.com/NVIDIA/stdexec) since late November (see
[NVIDIA/stdexec#1683](https://github.com/NVIDIA/stdexec/pull/1683)). At the time of
writing (early January, 2026), the changes have not resulted in any bug reports.

# Fixing algorithm customization

Selecting the right implementation of an algorithm requires requires two things:

1. Identifying the starting and completing domain of the algorithm's async operation, and

2. Using that information to select the preferred implementation for the algorithm
   that operation represents.

Let's take these two separately.

## Determining the starting and completing domains

As described in [](#fix-algorithm-customization-now), so-called "early" customization,
which determines the return type of `then(sndr, fn)` for example, is irreparably broken.
It needs the sender to know where it will complete, which it can't in general.

So the first step is to remove early customization. There is no plan to add it back later.

That leaves "late" customization, which is performed by the `connect` customization point.
The receiver, which is an extension of caller, knows where the operation will start.
If the sender is given this information -- that is, if the sender is told where it will
start -- it can accurately report where it will complete. This is the key insight.

When `connect` queries a sender's attributes for its completion domain, it should pass the
receiver's environment. That way a sender has all available information when computing
its completion domain.

### `get_completion_domain`

It is sometimes the case that a sender's value and error completions can happen on
different domains. For example, imagine trying to schedule work on a GPU. If it succeeds,
you are in the GPU domain, Bob's your uncle. If scheduling fails, however, the error
cannot be reported on the GPU because we failed to make it there!

So asking a sender for a singular completion domain is not flexible enough.

When asking for a completion _scheduler_, we have three queries, one for each completion
disposition: `get_completion_scheduler<set_[value|error|stopped]_t>`. Similarly, we should
have three separate queries for a sender's completion domain:
`get_completion_domain<set_[value|error|stopped]_t>`.

::: callout

[ASIDE]{.callout-header} [If we have the `get_completion_scheduler` queries, why do we need
`get_completion_domain`? We can ask the completion scheduler for its domain, right? The
answer is that there are times when a sender's completion domain is knowable but the
completion scheduler is not. E.g., `when_all(s1, s2)`{.cpp} completes on the completion
scheduler of either `s1` or `s2`, so its completion scheduler is indeterminate.
But if `s1` and `s2` have the same completion _domain_, then we know that `when_all`
will complete in that domain.]{.callout-context}

:::

The addition of the completion domain queries creates a nice symmetry as shown in the
table below (with additions in green):

|                     | Receiver        |  Sender   |
|---------------------|-----------------|-----------|
| Query for scheduler | `get_scheduler` | `get_completion_scheduler<set_value_t>`<br/>`get_completion_scheduler<set_error_t>`<br/>`get_completion_scheduler<set_stopped_t>`  |
| Query for domain    | `get_domain`    | [`get_completion_domain<set_value_t>`<br/>`get_completion_domain<set_error_t>`<br/>`get_completion_domain<set_stopped_t>`]{.green} |

For a sender `sndr` and an environment `env`, we can get the sender's `set_value`
completion domain as follows:

> ```cpp
> auto completion_domain = get_completion_domain<set_value_t>(get_env(sndr), env);
> ```

A sender like `just()` would implement this query as follows:

> ```cpp
> struct just_attrs
> {
>   auto query(get_completion_domain_t<set_value_t>, const auto& env) const noexcept
>   {
>     // an inline sender completes where it starts. the domain of the environment is where
>     // the sender will start, so return that.
>     return get_domain(env);
>   }
>   //...
> };
>
> template<class... Values>
> struct just_sender
> {
>   //...
>   auto get_env() const noexcept
>   {
>     return just_attrs{};
>   }
>   //...
> };
> ```

::: callout

[Note]{.callout-header} [A query that accepts an additional argument is novel in
`std::execution`, but the query system was designed to support this usage. See
[exec.queryable.concept]{.sref}.]{.callout-content}

:::

Most algorithms will want to dispatched based on where the operation will complete
_successfully_ and would thus use the `get_completion_domain<set_value_t>` query. To
accommodate those algorithms that might want to dispatch differently, this paper proposes
to add a fourth form for the `get_completion_domain` query: `get_completion_domain<>`
(without a completion tag parameter). See [](#design-review-feedback) for details
about this query.

Just as the `get_completion_domain` queries accept an optional `env` argument, so
too should the `get_completion_scheduler` queries.

## Algorithm dispatching in `connect`

With the addition of the `get_completion_domain<*>` queries that can accept the
receiver's environment, `connect` can now know the starting and completing domains of the
async operation it is constructing. When passed arguments `sndr` and `rcvr`, the starting
domain is:

> ```c++
> // Get the operation's starting domain:
> auto starting_domain = get_domain(get_env(rcvr));
> ```

To get the completion domain:

> ```c++
> // Get the operation's completion domain:
> auto completion_domain = get_completion_domain<>(get_env(sndr), get_env(rcvr));
> ```

Now `connect` has all the information it needs to select the correct algorithm
implementation. Great!

But this presents the `connect` function with a dilemma: how does it use _two_ domains to
pick _one_ algorithm implementation?

Consider that the starting domain might want a say in how `start` works, and the
completing domain might want a say in how `set_value` works. So should we let the starting
domain customize `start` and the completing domain customize `set_value`?

No. `start` and `set_value` are bookends around an async operation; they must match. Often
`set_value` needs state that is set up in `start`. Customizing the two independently is
madness.

### Solving the double-dispatch problem

The solution is to use sender transforms. Each domain can apply its transform in turn. I
do not have a reason to believe the order matters, but it is important that when asked to
transform a sender, a domain knows whether it is the "starting" domain or the "completing"
domain.

Here is how a domain might customize `bulk` when it is the completing domain:

> ```cpp
> struct thread_pool_domain
> {
>   template<@_`sender-for`_@<bulk_t> Sndr, class Env>
>   auto transform_sender(set_value_t, Sndr&& sndr, const Env& env) const
>   {
>     //...
>   }
> };
> ```

Since it has `set_value_t` as its first argument, this transform is only applied when
`thread_pool_domain` is an operation's completion domain. Had the first argument been
`start_t`, the transform would only be used when `thread_pool_domain` is a starting
domain.

### `transform_sender`

In this proposed design, the `connect` CPO does a few things:

1. Determines the starting and completing domains,

2. Applies the completing domain's transform (if any),

3. Applies the starting domain's transform (if any) to the resulting sender,

4. Connnects the twice-transformed sender to the receiver.

The first three steps are doing something different than connecting a sender and receiver,
so it makes sense to factor them out into their own utility. As it so happens we already
have such a utility: `transform_sender`.

The proposal requires some changes to how `transform_sender` operates. This new
`transform_sender` still accepts a sender and an environment, but it no longer accepts a
domain. It computes the two domains and applies the two transforms, recursing if a
transform changes the type of the sender.

A possible implementation of `transform_sender` is listed in
[](#appendix-a-listing-for-updated-transform_sender).

With the definition of `transform_sender` in Appendix A, `connect(sndr, rcvr)` is
equivalent to `transform_sender(sndr, get_env(rcvr)).connect(rcvr)` (except `rcvr`
is evaluated only once).


## Revisiting the problematic example

Let's see how this new approach addresses the problems noted in the motivating example
[above](#an-illustrative-example). The troublesome code is:

> ```cpp
> namespace ex = std::execution;
> auto sndr = ex::starts_on(gpu, ex::just()) | ex::then(fn);
> std::this_thread::sync_wait(std::move(sndr));
> ```

[](#an-illustrative-example) describes how the current design and the "fixed" one proposed
in [@P3718R0] go off the rails while determining the domain in which the function `fn`
will execute, causing it to use a CPU implementation instead of a GPU one.

In the new design, when the `then` sender is being connected to `sync_wait`'s receiver,
the starting domain will still be the `default_domain`, but when asking the sender where
it will complete, the answer will be different. Let's see how:

* When asked for its completion domain, the `then` sender will ask the `starts_on` sender
  where it will complete, as if by:

  > ```cpp
  > auto& [_, fn, child1] = *this; // *this is a then sender
  >                                // child1 is a starts_on sender
  > auto dom1 = ex::get_completion_domain<ex::set_value_t>(ex::get_env(child1), ex::get_env(rcvr));
  > ```

* In turn, the `starts_on` sender asks the `just` sender where it will complete,
  _telling it where it will start_. (This is the new bit.) It looks like:

  > ```cpp
  > auto& [_, sch, child2] = *this;  // *this is a starts_on sender
  >                                  // child2 is a just sender
  > // ask for the scheduler's completion domain:
  > auto sch_dom = ex::get_completion_domain<ex::set_value_t>(sch, get_env(rcvr));
  > // construct an env that reflects the fact that child2 will be started on sch:
  > auto env2 = ex::env{ex::prop{ex::get_scheduler, sch},
  >                     ex::prop{ex::get_domain, sch_dom},
  >                     ex::get_env(rcvr)};
  > // pass the new env when asking child2 for its completion domain:
  > auto dom2 = ex::get_completion_domain<ex::set_value_t>(ex::get_env(child2), env2);
  > ```

* The `just`{.cpp} sender, when asked where it will complete, will respond with the domain
  on which it is started. In other words,
  `get_completion_domain<set_value_t>(get_env(just()), env2)` will return
  `get_domain(env2)`, which is `sch_dom`.

* Having correctly determined that the `then` sender will start on the default domain
  and complete on the GPU domain, `connect` can select the right implementation for the
  `then` algorithm. It does that as follows:

  > ```cpp
  > auto&& env = ex::get_env(rcvr);
  > return ex::transform_sender(forward<Sndr>(sndr), env).connect(forward<Rcvr>(rcvr));
  > ```

  The `transform_sender` call will execute the following (simplified):

  > ```cpp
  > ex::default_domain().transform_sender(
  >   ex::start,
  >   gpu_domain().transform_sender(ex::set_value, sndr, env),
  >   env)
  > ```

  where `gpu_domain` is the domain of the `gpu` scheduler. The `default_domain` does not
  apply any transformation to `then` senders, so this expression reduces to:

  > ```cpp
  > gpu_domain().transform_sender(ex::set_value, sndr, ex::get_env(rcvr))
  > ```

  So in the new customization scheme, the GPU domain gets a crack at transforming the
  `then` sender before it is connected to a receiver, as it should.


## Customizing `continues_on` and `schedule_from`

One of the uglier parts of the current algorithm customization design is that it needs
special case handling for the `continues_on` and `schedule_from` algorithms. The proposed
design gives us an opportunity to clean this up significantly.

### Background

In order to transition between two execution contexts, each of which may know nothing
about the other, it is necessary to do it in two steps: a transition _from_ a context to
the default domain, and a transition from the default domain _to_ another context. A
scheduler can customize either or both of these two steps by customizing the
`continues_on` and `schedule_from` algorithms.

The customization of `continues_on` is found using the completion domain of `sndr`, making
it the sanctioned way to transition _off of_ a context. `schedule_from` finds its
customization using the domain of `sch`, making it useful for transitioning _onto_ a
context.

When not customized, connecting the sender `continues_on(sndr, sch)` performs a switcheroo
and connects `schedule_from(sch, sndr)` instead. In that way, both the source and
destination contexts get a say in how the execution transfer is mediated.

What if a domain wants to customize `continues_on`? Asking `continues_on(sndr, sch)` for
its completion domain will yield the domain of `sch`, but `continues_on` wants to use the
completion domain of `sndr`. The usual `transform_sender` mechanism does not seem to cut
it.

This is handled in the current draft wording by making `continues_on` a special case in
`transform_sender`. In [@P3718R0], the special casing is replaced with a
`get_domain_override` attribute query, by which the `continues_on` sender can force
`transform_sender` to use a different domain.

Both of these solutions are hacks.

### A simplification

A better way to solve this problem is to divide responsibilities differently
between `continues_on` and `schedule_from`. Suppose that only `continues_on`
transfers execution, and `schedule_from` does nothing and only exists so it
can be customized. The `continues_on` customization point would look like:

```c++
constexpr @_`pipeable-adaptor`_@ continues_on =
  []<class Sndr, class Sch>(this auto self, Sndr&& sndr, Sch sch)
  {
    return @_`make-sender`_@(self, sch, schedule_from(forward<Sndr>(sndr)));
  };
```

The `schedule_from` customization point would look like this:

```c++
constexpr auto schedule_from =
  []<class Sndr>(this auto self, Sndr&& sndr)
  {
    return @_`make-sender`_@(self, {}, forward<Sndr>(sndr));
  };
```

Semantically, `schedule_from(sndr)` is equivalent to `sndr`. Crucially, that means that
`schedule_from(sndr)` has the same completion domain as `sndr`. And that makes
`schedule_from` a great way to customize how to transition _off of_ an execution context.

On the other hand, `continues_on(sndr, sch)` completes on the domain of `sch`, making it a
great way to customize how to transition _onto_ an execution context.

By splitting `continues_on` and `schedule_from` in this way, we obviate the need for any
special cases or domain overrides. The usual `transform_sender` mechanism is sufficient.

In the [CCCL](https://github.com/NVIDIA/cccl) project, I have implemented this design and
ported my CUDA stream scheduler to use it. I needed to customize `schedule_from` for the
CUDA stream scheduler to mediate the execution transfer from the GPU back to the CPU.
Besides the `bulk` and `let` algorithms, `schedule_from` is the only algorithm the GPU
scheduler needs to customize.

::: callout

[NOTE]{.callout-title} [Carving the two algorithms this way flips how they are dispatched.
`continues_on` now dispatches based on the domain of `sch`, and `schedule_from` on the
completion domain of the predecessor sender. The original dispatching semantics were
chosen arbitrarily. The author believes the new `continues_on`/`schedule_from` dispatch
semantics are more sensible.]{.callout-content}

:::

## `inline_scheduler` improvements

The suggestion above to extend the `get_completion_scheduler<*>` query presents an
intriguing possibility for the `inline_scheduler`: the ability for it to report the
scheduler on which its scheduling operations complete!

Consider the sender `schedule(inline_scheduler())`. Ask it where it completes today and it
will say, "I complete on the `inline_scheduler`," which isn't terribly useful. However, if
you ask it, "Where will you complete -- and by the way you will be started on the
`parallel_scheduler`?", now that sender can report that it will complete on the
`parallel_scheduler`.

The result is that code that uses the `inline_scheduler` will no longer cause the
_actual_ scheduler to be hidden.

This realization is the motivation behind the change to strike the
`get_completion_scheduler<set_value_t>(get_env(schedule(sch)))` requirement from the
`scheduler` concept. We want that expression to be ill-formed for the `inline_scheduler`.
Instead, we want the following query to be well-formed:

> ```cpp
> get_completion_scheduler<set_value_t>(get_env(schedule(inline_scheduler())), get_env(rcvr))
> ```

That expression should be equivalent to `get_scheduler(get_env(rcvr))`, which says that
the sender of `inline_scheduler` completes wherever it is started.

## Indeterminate domains

When computing completion domains, it is sometimes the case that an operation can
complete on domain `A` or domain `B` for a given disposition (value, error, or stopped).
Imagine such a sender with an indeterminate completion domain for `set_value`. How
does algorithm customization work in that case?

First, we recognize that very few algorithms will ever be customized; a given domain may
only customize a handful. Given `sndr | then(fn)`, there is no difficulty picking the
implementation for `then` even if `sndr` can complete successfully on either domain `A` or
`B`, _provided neither domain customizes `then`_.

That insight makes it advantageous for a sender to report _all_ the domains on which
it might complete for a particular completion channel. It can do that with a 
new domain type: `indeterminate_domain<Domains...>`, which looks like this:

> ```cpp
> template<class... Domains>
> struct indeterminate_domain
> {
>   template<class Tag, class Sndr, class Env>
>   static constexpr auto transform_sender(Tag, Sndr&& sndr, const Env& env)
>   {
>     // Mandates: for all D in Domains, the expression
>     // D().transform_sender(Tag(), forward<Sndr>(sndr), env) is either ill-formed or else
>     // has the same type as
>     // default_domain().transform_sender(Tag(), forward<Sndr>(sndr), env)
>     return default_domain().transform_sender(Tag(), forward<Sndr>(sndr), env);
>   }
> };
> ```

Given an environment `e`, a sender like `when_all(sndrs...)` would have a value completion
domain of

```cpp
@_`COMMON-DOMAIN`_@(@_`COMPL-DOMAIN`_@(set_value_t, sndrs, e)...)
```

where:

- ```@_`COMPL-DOMAIN`_@(T, S, E)``` is the type of
  `get_completion_domain<T>(get_env(S), E)` if that expression is well-formed, or
  `indeterminate_domain<>()` otherwise, and

- ```@_`COMMON-DOMAIN`_@(Ds...)``` is `common_type_t<Ds...>` if that expression is
  well-formed, and `indeterminate_domain<Ds...>` otherwise.

The final piece is to specialize `common_type` such that `indeterminate_domain<As...>` and
`indeterminate_domain<Bs...>` have a common type of `indeterminate_domain<As..., Bs...>`,
and such that `common_type_t<indeterminate_domain<As...>, D>` is
`indeterminate_domain<As..., D>`.

## The procedure for the fix

The steps for fixing algorithm customization are detailed below.

#. Remove the uses of `transform_sender` in the sender adaptor algorithm customization
   points ([exec.adapt]{.sref}). Directly return the result of calling _`make-sender`_
   rather than passing it to `transform_sender`.

#. Remove the exposition-only helpers:

   * _`completion-domain`_ ([exec.snd.expos]{.sref}/8-9),
   * _`get-domain-early`_ ([exec.snd.expos]{.sref}/13), and
   * _`get-domain-late`_ ([exec.snd.expos]{.sref}/14).

#. Add the `get_completion_domain` queries:

   * `get_completion_domain<set_value_t>`
   * `get_completion_domain<set_error_t>`
   * `get_completion_domain<set_stopped_t>`

#. Change the `get_completion_scheduler` queries to accept an optional environment
   argument.

#. Make the `get_domain(env)` query smarter by falling back to the current scheduler's
   domain if `env.query(get_domain)` is ill-formed, and falling back further to
   `default_domain()` if `env` does not have a current scheduler.

#. Restore the ability of `env<...>::query` to accept additional arguments.

#. Rename the current `schedule_from` algorithm to `continues_on` and change it to return
   ```@_`make-sender`_@(continues_on, sch, schedule_from(sndr))```, where `schedule_from`
   is a new algorithm such that `schedule_from(sndr)` is equivalent to
   ```@_`make-sender`_@(schedule_from, {}, sndr)```.

#. Remove the (unused) `transform_env` function and the `transform_env` members
   of the sender algorithm CPOs and from `default_domain`.

#. Change `transform_sender` from `transform_sender(Domain, Sndr, Env...)` to
   `transform_sender(Sndr, Env)`. Have it compute the sender's starting and
   completing domains and apply their transforms to `Sndr` as shown in
   [](#appendix-a-listing-for-updated-transform_sender).

#. Update the usages of `transform_sender` in `connect` and `get_completion_signatures` to
   reflect its new signature.

#. For the `transform_sender` member functions in the sender algorithm CPOs, add
   `set_value_t,` in the front of their parameter list. Parameterize the
   `transform_sender` member in `default_domain` with a leading `Tag` parameter.

#. Add a class template `indeterminate_domain<Domains...>` as described in
   [](#indeterminate-domains).

#. Update the attributes of the sender algorithms to properly report their completion
   schedulers and completion domains given an optional `env` argument. Also update
   the `inline_scheduler` and its schedule-sender to compute their completion
   scheduler and domain from the extra `env` argument.

#. From the `scheduler` concept, replace the required expression

   > ```cpp
   > { auto(get_completion_scheduler<set_value_t>(get_env(schedule(std::forward<Sch>(sch))))) }
   >     -> same_as<remove_cvref_t<Sch>>;
   > ```

   with a semantic requirement that _if_ the above expression is well-formed -- which it
   is for the `parallel_scheduler`, the `task_scheduler`, and `run_loop`'s scheduler --
   then it shall compare equal to `sch`. (See [](#inline_scheduler-improvements) for the motivation
   behind these changes.)

#. For any scheduler `sch` and completion tag `Tag`, require that the expression
   `get_completion_scheduler<Tag>(sch, env...)`, if it is well-formed, has the same type
   and value as `get_completion_scheduler<Tag>(get_env(schedule(sch)), env...)`. Do
   likewise for the `get_completion_domain` queries.

# Addressing feedback from LEWG design review {#design-review-feedback}

[@P3826R2] was reviewed by LEWG at the Fall 2025 meeting in Kona, HI. Two important
issues with the proposed design were raised at that time, both by Robert Leahy:

1. There is a design tension between "non-dependent" senders and algorithm customization.
   Can a sender be non-dependent if a customization could cause the final sender to have a
   different set of completion signatures?

2. The proposed algorithm dispatch mechanism hard-codes the primacy of the value channel.
   `transform_sender` uses a sender's `set_value` completion domain to find a
   customization. But some senders might want `transform_sender` to use a different domain
   to find a customization. How can that be expressed?

Let's take these two issues separately.

## Non-dependent senders vs. algorithm customization

A non-dependent sender is one whose completion signatures do not depend on the receiver's
environment. Non-dependent senders were added in [@P3164R4] as a way to improve the
usability of `std::execution` by allowing some sender expressions to be type-checked
eagerly, upon construction. `just(42)` is an example of a non-dependent sender, whereas
`read_env(get_scheduler)` is dependent because the value it sends is the scheduler found
in the receiver's environment.

By extension `then(just(42), fn)` is also non-dependent, whereas
`then(read_env(get_scheduler), fn)` is dependent. The later expression should be
well-formed unconditionally, but the former should be ill-formed if `fn` is not callable
with an `int` argument, like `[]{}` for example.

But what if a customization of `then` would make `then(just(42), []{})` well-formed?
Were we premature to reject the expression? Can _any_ customizable algorithm ever be
non-dependent?

### The fix

After lengthy discussions, Robert and I came to agree that the problem would be a
non-issue if there were sufficient constraints on how a customization is allowed to change
a sender's completion signatures. In particular, a customization should not change a
sender's value completion signatures.

As it so happens, we are already requiring this of customizations. The following
text is taken from [exec.snd.general]{.sref}.

> 1. [...] For the default implementation of the algorithm that produced `sndr`,
>    connecting `sndr` to `rcvr` and starting the resulting operation state
>    ([exec.async.ops]) necessarily results in the potential evaluation ([basic.def.odr])
>    of a set of completion operations whose first argument is a subexpression equal to
>    `rcvr`. Let `Sigs` be a pack of completion signatures corresponding to this set of
>    completion operations, and let `CS` be the type of the expression
>    `get_completion_signatures<Sndr, Env>()`. Then `CS` is a specialization of the class
>    template `completion_signatures` ([exec.cmplsig]{.sref}), the set of whose template
>    arguments is `Sigs`. [...] If a user-provided implementation of the algorithm that
>    produced `sndr` is selected instead of the default:
> 
>    - [1.1]{.pnum} Any completion signature that is in the set of types denoted by
>      `completion_signatures_of_t<Sndr, Env>` and that is not part of `Sigs` shall
>      correspond to error or stopped completion operations, unless otherwise specified.

Since the current wording already requires customizations to preserve the value
completion signatures of the original sender, no further changes are needed.

## Dispatching algorithms with a domain other than the value completion domain

`transform_sender`, as proposed by this paper, would use an operation's starting
and completing domain to find customizations. But _which_ completing domain, the
value, error, or stopped? R2 of this paper proposed to always use the `set_value`
completion domain.

But consider an algorithm like `translate_error(sndr, fn)` which passes value and stopped
completions through unchanged, but that transforms errors with `fn` before sending them
on. This algorithm may want to dispatch based on where `fn` will be called from, which
would be the error completion domain, _not_ the value completion domain.

After considering the issue, I decided that I agreed with Robert that the proposed design
was deficient in this respect.

### The fix

I propose that in addition to the following queries:

* `get_completion_domain<set_value_t>`
* `get_completion_domain<set_error_t>`
* `get_completion_domain<set_stopped_t>`

we also have:

* `get_completion_domain<>`.

`get_completion_domain<>(attrs, env...)` would return
`attrs.query(get_completion_domain<>, env...)` if that is well-formed. Otherwise, it
defaults to `get_completion_domain<set_value_t>(attrs, env...)`.

`transform_sender` would determine a sender's completion domain by querying for
`get_completion_domain<>`. That way, a sender can implement that query to say, "For the
purposes of algorithm dispatching, use domain `D`." And if a sender does not implement
that query, the `set_value` completion domain will be used instead.

Robert Leahy agrees that this change addresses his concern. This revision adds wording
to that effect.

# Proposed wording {#proposed-wording}

[In [execution.syn]{.sref}, make the following changes:]{.ednote}

> ```cpp
> @[&hellip; as before &hellip;]{.blue}@
>
> namespace std::execution {
>   // [exec.queries], queries
>   struct get_domain_t { @_`unspecified`_@ };
>   struct get_scheduler_t { @_`unspecified`_@ };
>   struct get_delegation_scheduler_t { @_`unspecified`_@ };
>   struct get_forward_progress_guarantee_t { @_`unspecified`_@ };
>   template<class CPO>
>     struct get_completion_scheduler_t { @_`unspecified`_@ };
>   @@[```template<class CPO = void>```]{.add}@@
>     @@[```struct get_completion_domain_t { @_`unspecified`_@ };```]{.add}@@
>   struct get_await_completion_adaptor_t { @_`unspecified`_@ };
>
>   inline constexpr get_domain_t get_domain{};
>   inline constexpr get_scheduler_t get_scheduler{};
>   inline constexpr get_delegation_scheduler_t get_delegation_scheduler{};
>   enum class forward_progress_guarantee;
>   inline constexpr get_forward_progress_guarantee_t get_forward_progress_guarantee{};
>   template<class CPO>
>     constexpr get_completion_scheduler_t<CPO> get_completion_scheduler{};
>   @@[```template<class CPO = void>```]{.add}@@
>     @@[```constexpr get_completion_domain_t<CPO> get_completion_domain{};```]{.add}@@
>   inline constexpr get_await_completion_adaptor_t get_await_completion_adaptor{};
>
>   struct get_env_t { @_`unspecified`_@ };
>   inline constexpr get_env_t get_env{};
> 
>   template<class T>
>     using env_of_t = decltype(get_env(declval<T>()));
> 
>   // [exec.prop], class template prop
>   template<class QueryTag, class ValueType>
>     struct prop;
> 
>   // [exec.env], class template env
>   template<queryable... Envs>
>     struct env;
> 
>   @[_`// [exec.domain.indeterminate], execution domains`_]{.add}@
>   @[`template<class... Domains>`]{.add}@
>     @[`struct indeterminate_domain;`]{.add}@
> 
>   // [exec.domain.default], execution domains
>   struct default_domain;
> 
> @[&hellip; as before &hellip;]{.blue}@
>
>   template<sender Sndr>
>     using tag_of_t = @_`see below`_@;
>
>   // [exec.snd.transform], sender transformations
>   template<@[`class Domain,`]{.rm}@ sender Sndr, @_`queryable`_[...]{.rm}@ Env>
>       requires (sizeof...(Env) <= 1)
>     constexpr sender decltype(auto) transform_sender(
>       @[`Domain dom,`]{.rm}@ Sndr&& sndr, const Env&@[`...`]{.rm}@ env) noexcept(@_`see below`_@);
>
>   @[`// [exec.snd.transform.env], environment transformations`]{.rm}@
>   @@[```template<class Domain, sender Sndr, @_`queryable`_@ Env>```]{.rm}@@
>     @[`constexpr queryable decltype(auto) transform_env(`]{.rm}@
>       @[`Domain dom, Sndr&& sndr, Env&& env) noexcept;`]{.rm}@
>
>   // [exec.snd.apply], sender algorithm application
>   template<class Domain, class Tag, sender Sndr, class... Args>
>     constexpr decltype(auto) apply_sender(
>       Domain dom, Tag, Sndr&& sndr, Args&&... args) noexcept(@_`see below`_@);
>
>   // [exec.connect], the connect sender algorithm
>   struct connect_t;
>   inline constexpr connect_t connect{};
>
> @[&hellip; as before &hellip;]{.blue}@
> ```

[Before subsection [exec.fwd.env]{.sref}, insert a new subsection with stable name
[exec.queries.expos] as follows:]{.ednote}

::: add

> ### Query utilities    [exec.queries.expos]
> 
> 1. [exec.queries] makes use of the following exposition-only entities.
>
> 2. For subexpressions `q` and `tag` and pack `args`, let
>    ```@_`TRY-QUERY`_@(q, tag, args...)```{.cpp} be expression-equivalent to
>    ```@_`AS-CONST`_@(q).query(tag, args...)```{.cpp} if that expression is well-formed, and
>    ```@_`AS-CONST`_@(q).query(tag)```{.cpp} otherwise.
>
> 3. For subexpressions `q` and `tag` and pack `args`, let ```@_`HIDE-SCHED`_@(q)```{.cpp}
>    be an object `o` such that `o.query(tag, args...)` is ill-formed when the decayed
>    type of `tag` is `get_scheduler_t` or `get_domain_t`, and `o.query(tag, args...)`
>    otherwise.

:::


[Change [exec.get.domain] as follows:]{.ednote}

> ### `execution​::​get_domain`     [exec.get.domain]
>
> 1. `get_domain` asks a queryable object for its associated execution domain tag.
>
> 2. The name `get_domain` denotes a query object. For a subexpression `env`,
>    `get_domain(env)` is expression-equivalent to [```@_`MANDATE-NOTHROW`_@(D())```, where
>    `D` is the type of the first of the following expressions that is well-formed]{.add}
>    [Reformatted as a list.]{.ednote}
>
>    - [2.1]{.pnum} ```@[_`MANDATE-NOTHROW`_(]{.rm}[`auto(`]{.add}_`AS-CONST`_@(env).query(get_domain))```{.cpp}
>
>    ::: add
>
>    - [2.2]{.pnum} ```get_completion_domain<set_value_t>(get_scheduler(env), @_`HIDE-SCHED`_@(env))```{.cpp}
>
>    - [2.3]{.pnum} `default_domain()`
>
>    :::
>
> 3. `forwarding_query(execution​::​get_domain)` is a core constant expression and has
>    value `true`.

[Change subsection [exec.get.scheduler]{.sref} as follows:]{.ednote}

> 1. `get_scheduler` asks a queryable object for its associated scheduler.
>
> 2. The name `get_scheduler` denotes a query object. For a subexpression `env`,
>    `get_scheduler(env)` is expression-equivalent to
>
>    > ```cpp
>    > @[`get_completion_scheduler<set_value_t>(`]{.add}_`MANDATE-NOTHROW`_@(@_`AS-CONST`_@(env).query(get_scheduler))@@[```, @_`HIDE-SCHED`_@(env)```]{.add}@@)
>    > ```
>
>    _Mandates_: If the expression above is well-formed, its type satisfies `scheduler`.
>
> 3. `forwarding_query(execution​::​get_scheduler)` is a core constant expression and has
>    value `true`.




[Change subsection [exec.get.compl.sched]{.sref} as follows:]{.ednote}

> ### `execution​::​get_completion_scheduler` [exec.get.compl.sched]
>
> 1. ```get_completion_scheduler<@_`completion-tag`_@>```{.cpp} obtains the completion
>    scheduler associated with a completion tag from a sender's attributes.
>
> 2. The name `get_completion_scheduler` denotes a query object template. For a
>    subexpression `q` [and pack `envs`]{.add}, the expression
>    ```get_completion_scheduler<@_`completion-tag`_@>(q@[`, envs...`]{.add}@)```{.cpp} is ill-formed if
>    _`completion-tag`_ is not one of `set_value_t`, `set_error_t`, or `set_stopped_t`.
>    Otherwise, ```get_completion_scheduler<@_`completion-tag`_@>(q@[`, envs...`]{.add}@)```{.cpp} is
>    expression-equivalent to
>
>    ::: rm
>   
>    > ```cpp
>    > @_`MANDATE-NOTHROW`_@(@_`AS-CONST`_@(q).query(get_completion_scheduler<@_`completion-tag`_@>))
>    > ```
>   
>    :::
>
>    ::: add
>
>    - [3.1]{.pnum}
>      ```@_`MANDATE-NOTHROW`_@(@_`RECURSE-QUERY`_@(@_`TRY-QUERY`_@(q, get_completion_scheduler<@_`completion-tag`_@>, envs...), envs...))```{.cpp}
>      if that expression is well-formed.
>   
>    - [3.2]{.pnum} Otherwise, `auto(q)` if the type of `q` satisfies `scheduler` and
>      `sizeof...(envs) != 0` is `true`.
>   
>    - [3.3]{.pnum} Otherwise, ```get_completion_scheduler<@_`completion-tag`_@>(q, envs...)```{.cpp}
>      is ill-formed.
>
>    :::
>
>    _Mandates_: If [the expression above]{.rm}
>    [```get_completion_scheduler<@_`completion-tag`_@>(q, envs...)```{.cpp}]{.add} is well-formed,
>    its type satisfies `scheduler`.
>
> ::: add
>
> 3. For a type `Tag`, subexpression `sndr`, and pack `env`, let `CS` be
>    `completion_signatures_of_t<decay_t<decltype((sndr))>, decltype((env))...>`. If both
>    `get_completion_scheduler<Tag>(get_env(sndr), env...)` and `CS` are well-formed
>    and ```CS().@_`count-of`_@(Tag()) == 0``` is `true`, the program is ill-formed.
>
> :::
>
> 4. Let _`completion-fn`_ be a completion function ([exec.async.ops]{.sref}); let
>   _`completion-tag`_ be the associated completion tag of _`completion-fn`_; let `args`
>   [and `envs`]{.add} be [a]{.rm} pack[s]{.add} of subexpressions; and let `sndr` be a
>   subexpression such that `sender<decltype((sndr))>`{.cpp} is `true` and
>   ```get_completion_scheduler<@_`completion-tag`_@>(get_env(sndr)@[`, envs...`]{.add}@)```{.cpp}
>   is well-formed and denotes a scheduler `sch`. If an
>   asynchronous operation created by connecting `sndr` with a receiver `rcvr` causes the
>   evaluation of ```@_`completion-fn`_@(rcvr, args...)```{.cpp}, the behavior is
>   undefined unless the evaluation happens on an execution agent that belongs to `sch`'s
>   associated execution resource.
>
> 5. The expression
>    ```forwarding_query(get_completion_scheduler<@_`completion-tag`_@>)``` is a core constant
>    expression and has value `true`.


[After subsection [exec.get.compl.sched]{.sref}, add a new subsection with stable name
[exec.get.compl.domain] as follows.]{.ednote}

::: add

> ### `execution​::​get_completion_domain` [exec.get.compl.domain]
>
> 1. ```get_completion_domain<@_`completion-tag`_@>```{.cpp} obtains the completion
>    domain associated with a completion tag from a sender's attributes.
>
> 2. The name `get_completion_domain` denotes a query object template. For a
>    subexpression `o` and pack `env`, the expression
>    ```get_completion_domain<@_`completion-tag`_@>(o, env...)```{.cpp} is ill-formed if
>    _`completion-tag`_ is not one of `void`, `set_value_t`, `set_error_t`, or `set_stopped_t`.
>    Otherwise, ```get_completion_domain<@_`completion-tag`_@>(o, env...)```{.cpp} is
>    expression-equivalent to ```@_`MANDATE-NOTHROW`_@(D())```, where `D` is:
>
>    - [2.1]{.pnum} The type of
>      ```@_`TRY-QUERY`_@(o, get_completion_domain<@_`completion-tag`_@>, env...)``` if
>      that expression is well-formed.
>
>    - [2.2]{.pnum} Otherwise, the type of ```get_completion_domain<set_value_t>(o, env...)```
>      if _`completion-tag`_ is `void`.
>
>    - [2.3]{.pnum} Otherwise, the type of
>      ```@_`TRY-QUERY`_@(get_completion_scheduler<@_`completion-tag`_@>(o, env...), get_completion_domain<set_value_t>, env...)```
>      if that expression is well-formed.
>
>    - [2.4]{.pnum} Otherwise, `default_domain` if
>      `scheduler<decltype((o))> && sizeof...(env) != 0` is `true`.
>
>    - [2.5]{.pnum} Otherwise, ```get_completion_domain<@_`completion-tag`_@>(o, env...)```
>      is ill-formed.
>
> 3. For a type `Tag`, subexpression `sndr`, and pack `env`, let `CS` be
>    `completion_signatures_of_t<decay_t<decltype((sndr))>, decltype((env))...>`. If both
>    `get_completion_domain<Tag>(get_env(sndr), env...)` and `CS` are well-formed
>    and ```CS().@_`count-of`_@(Tag()) == 0``` is `true`, the program is ill-formed.
>
> 4. Let _`completion-fn`_ be a completion function ([exec.async.ops]); let
>    _`completion-tag`_ be the associated completion tag of _`completion-fn`_; let `args`
>    and `env` be packs of subexpressions; and let `sndr` be a subexpression such that
>    `sender<decltype((sndr))>`{.cpp} is `true` and
>    ```get_completion_domain<@_`completion-tag`_@>(get_env(sndr), env...)```{.cpp} is
>    well-formed and denotes a domain `D`. If an asynchronous operation created by
>    connecting `sndr` with a receiver `rcvr` causes the evaluation of
>    ```@_`completion-fn`_@(rcvr, args...)```{.cpp}, the behavior is undefined unless the
>    evaluation happens on an execution agent of an execution resource whose associated
>    execution domain tag is `D`.
>
> 5. The expression
>    ```forwarding_query(get_completion_domain<@_`completion-tag`_@>)``` is a core constant
>    expression and has value `true`.

:::

[In [exec.sched]{.sref}, change paragraphs 1, 5, and 6 as follows:]{.ednote}

> 1. The `scheduler` concept defines the requirements of a scheduler type
>    ([exec.async.ops]{.sref}). `schedule` is a customization point object that accepts a
>    scheduler. A valid invocation of `schedule` is a schedule-expression.
>
>    > ```cpp
>    > namespace std::execution {
>    >   template<class Sch>
>    >     concept scheduler =
>    >       derived_from<typename remove_cvref_t<Sch>::scheduler_concept, scheduler_t> &&
>    >       @_queryable_@<Sch> &&
>    >       requires(Sch&& sch) {
>    >         { schedule(std::forward<Sch>(sch)) } -> sender;
>    >         @[`{ auto(get_completion_scheduler<set_value_t>(`]{.rm}@
>    >             @[`get_env(schedule(std::forward<Sch>(sch))))) }`]{.rm}@
>    >               @[`-> same_as<remove_cvref_t<Sch>>;`]{.rm}@
>    >       } &&
>    >       equality_comparable<remove_cvref_t<Sch>> &&
>    >       copyable<remove_cvref_t<Sch>>;
>    > }
>    > ```
>
> > [&hellip; as before &hellip;]{.blue}
>
> 5. For a given scheduler expression `sch`, [if]{.add} the expression
>    ```get_completion_scheduler<set_value_t>(get_env(schedule(sch)))```{.cpp} [is
>    well-formed, it]{.add} shall compare equal to `sch`.
>
> 6. For a given scheduler expression `sch` [, type `T`, and pack of
>    subexpressions `env`]{.add}, [if the expression ```get_domain(sch)```{.cpp} is
>    well-formed, then the expression ```get_domain(get_env(schedule(sch)))```{.cpp} is
>    also well-formed and has the same type.]{.rm} [the following two expressions are
>    either both ill-formed, or both well-formed with the same type:]{.add}
>
>    ::: add
>
>    - [6.1]{.pnum} ```get_completion_domain<T>(sch, env...)```
>
>    - [6.2]{.pnum} ```get_completion_domain<T>(get_env(schedule(sch)), env...)```
>
>    Likewise, the following two expressions are either both ill-formed, or both
>    well-formed with the same type and value:
>
>    - [6.3]{.pnum} ```get_completion_scheduler<T>(sch, env...)```
>
>    - [6.4]{.pnum} ```get_completion_scheduler<T>(get_env(schedule(sch)), env...)```
>
>    :::
>
> 7. [&hellip; as before &hellip;]{.blue}
>

[Change [exec.snd.general]{.sref} as follows:]{.ednote}


1. Subclauses [exec.factories]{.sref} and [exec.adapt]{.sref} define customizable
   algorithms that return senders. Each algorithm has a default implementation. Let `sndr`
   be the result of an invocation of such an algorithm or an object equal to the result
   ([concepts.equality]{.sref}), and let `Sndr` be `decltype((sndr))`. Let `rcvr` be a
   receiver of type `Rcvr` with associated environment `env` of type `Env` such that
   `sender_to<Sndr, Rcvr>` is `true`. For the default implementation of the algorithm that
   produced `sndr`, connecting `sndr` to `rcvr` and starting the resulting operation state
   ([exec.async.ops]{.sref}) necessarily results in the potential evaluation
   ([basic.def.odr]{.sref}) of a set of completion operations whose first argument is a
   subexpression equal to `rcvr`. [Broken into a separate paragraph:]{.ednote}

2. Let `Sigs` be a pack of completion signatures corresponding to this set of completion
   operations, and let `CS` be the type of the expression
   `get_completion_signatures<Sndr, Env>()`. Then `CS` is a specialization of the class
   template `completion_signatures` ([exec.cmplsig]{.sref}), the set of whose template
   arguments is `Sigs`. If none of the types in `Sigs` are dependent on the type `Env`,
   then the expression `get_completion_signatures<Sndr>()` is well-formed and its type is
   `CS`.

::: add

3. Each completion operation can potentially be evaluated on one of several different
   execution agents as determined by the semantics of the algorithm, the environment of
   the receiver, and the completions of any child senders. For a completion tag `T`, let
   ```Cs@~_T_~@``` be the set of domain tags associated with the execution agents that
   could potentially evaluate any of the operation's completions with tag `T`, and let
   ```Ds@~_T_~@``` be a pack corresponding to ```Cs@~_T_~@```. If there are no potentially
   evaluated completion operations with tag type `T`, then
   `get_completion_domain<T>(get_env(sndr), env)` is ill-formed; otherwise, it has type
   ```@_`COMMON-DOMAIN`_@<Ds@~_T_~@...>``` ([exec.snd.expos]{.sref}).

   [Let `S` be the sender `then(sndr, fn)`. `S` has the same `set_value` completion domain
   as `sndr`, but if `fn`'s evaluation is potentially throwing, `S`'s `set_error` completion
   domain would be the _`COMMON-DOMAIN`_ of `sndr`'s value and error completion domains,
   in accordance with the semantics of the `then` algorithm
   ([exec.then]{.sref}).]{.example}

4. If `sndr` can determine that all of its completion operations with tag `T` happen on
   execution agents associated with a particular scheduler `S` (as determined by the
   semantics of the algorithm, the environment of the receiver, and the completion
   schedulers of any child senders), then `get_completion_scheduler<T>(get_env(sndr), env)`
   is well-formed and has the type and value of `S`; otherwise, it is ill-formed.

   [Let `S` be the sender from the example above. The `set_value` completion scheduler of
   `S` is the `set_value` completion scheduler of `sndr`, if any. But `S` can only report
   a `set_error` completion scheduler when invocations of `fn` are not potentially
   throwing or when `sndr` has no `set_error` completions. When `fn` can throw, `S` could
   complete with `set_error` either by forwarding an error completion from `sndr` or by
   completing with the exception thrown by `fn`, which would happen on an agent associated
   with `sndr`'s `set_value` completion scheduler.]{.example}

:::

[Broken into a separate paragraph:]{.ednote}

5. If a user-provided implementation of the algorithm that produced `sndr` is
   selected instead of the default:

   - [1.1]{.pnum} Any completion signature that is in the set of types denoted by
     `completion_signatures_of_t<Sndr, Env>` and that is not part of `Sigs` shall
     correspond to error or stopped completion operations, unless otherwise specified.

   - [1.2]{.pnum} If none of the types in `Sigs` are dependent on the type `Env`, then
     `completion_signatures_of_t<Sndr>` and `completion_signatures_of_t<Sndr, Env>` shall
     denote the same type.

6. Various function templates in subclause [exec.snd]{.sref} can throw an exception of
   type _`unspecified-exception`_. Each such exception object is of an unspecified type
   such that a handler of type `exception` matches ([except.handle]{.sref}) the exception
   object but a handler of type `dependent_sender_error` does not.
   
   [There is no requirement that two such exception objects have the same type.]{.note}


[Change [exec.snd.expos]{.sref} paragraph 3 as follows:]{.ednote}

> 3. For a query object `q` [and]{.rm}[,]{.add} a subexpression `v`[, and a pack
>   of subexpressions `as`]{.add}, ```@_`MAKE-ENV`_@(q, v)``` is an expression `env` whose type
>   satisfies _`queryable`_ such that the result of ```env.query(q@[`, as...`]{.add}@)```
>   has a value equal to `v` ([concepts.equality]{.sref}). Unless otherwise stated, the object to
>   which ```env.query(q@[`, as...`]{.add}@)``` refers remains valid while `env` remains
>   valid.

[Before [exec.snd.expos]{.sref} paragraph 6, add two new paragraphs as follows:]{.ednote}

> ::: add
>
> 6. For a pack of subexpressions `domains`, ```@_`COMMON-DOMAIN`_@(domains...)``` is
>    expression-equivalent to `common_type_t<decltype(auto(domains))...>()` if that
>    expression is well-formed, and `indeterminate_domain<Ds...>()` otherwise, where `Ds`
>    is the pack of types consisting of `decltype(auto(domains))...` with duplicate
>    types removed.
> 
> 7. For a type `Tag`, subexpression `sndr`, and pack `env`, ```@_`COMPL-DOMAIN`_@(Tag, sndr, env)```
>    is expression-equivalent to `D()` where `D` is the type of
>    `get_completion_domain<Tag>(get_env(sndr), env...)` if that expression is well-formed
>    or if `sizeof...(env) == 0` is `true`, and `indeterminate_domain()` otherwise.
>
> :::

[Change [exec.snd.expos]{.sref} paragraph 6 (renumbered to 8) about _`SCHED-ATTRS`_ and
_`SCHED-ENV`_ as follows:]{.ednote}

> 8. [For a scheduler `sch`, ```@_`SCHED-ATTRS`_@(sch)``` is an expression o1 whose type
>    satisfies _`queryable`_ such that `o1.query(get_completion_scheduler<Tag>)` is an
>    expression with the same type and value as `sch` where `Tag` is one of `set_value_t`
>    or `set_stopped_t`, and such that `o1.query(get_domain)` is expression-equivalent to
>    `sch.query(get_domain)`.]{.rm} ```@_`SCHED-ENV`_@(sch)``` is an expression `o2` whose type
>    satisfies _`queryable`_ such that `o2.query(get_scheduler)` is a prvalue with the
>    same type and value as `sch`, and such that `o2.query(get_domain)` is
>    expression-equivalent to `sch.query(get_domain)`.


[Remove the prototype of the exposition-only _`completion-domain`_ function just before
[exec.snd.expos]{.sref} paragraph 8, and with it remove paragraphs 8 and 9, which specify
the function's behavior.]{.ednote}

[Remove [exec.snd.expos]{.sref} paragraphs 13 and 14 and the prototypes for the
_`get-domain-early`_ and _`get-domain-late`_ functions.]{.ednote}

[After [exec.snd.expos]{.sref} paragraph 26, change the declaration of the
exposition-only class _`default-impls`_ as follows:]{.ednote}

```cpp
  struct @_`default-impls`_@ {                                        // exposition only
    @@[```static constexpr auto @_`get-attrs`_@ = @_`see below`_@;                // exposition only```]{.rm}@@
    static constexpr auto @_`get-env`_@ = @_`see below`_@;                  // exposition only
    static constexpr auto @_`get-state`_@ = @_`see below`_@;                // exposition only
    static constexpr auto @_`start`_@ = @_`see below`_@;                    // exposition only
    static constexpr auto @_`complete`_@ = @_`see below`_@;                 // exposition only

    template<class Sndr, class... Env>
      static consteval void @_`check-types`_@();                      // exposition only
  };
```

[Strike [exec.snd.expos]{.sref} paragraph 35 as follows:]{.ednote}

> ::: rm
>
> 35. The member ```@_`default-impls​`_@::@_`​get-attrs`_@``` is initialized with a
>     callable object equivalent to the following lambda:
> 
>     > ```cpp
>     > [](const auto&, const auto&... child) noexcept -> decltype(auto) {
>     >   if constexpr (sizeof...(child) == 1)
>     >     return (FWD-ENV(get_env(child)), ...);
>     >   else
>     >     return env<>();
>     > }
>     > ```
>
> :::

[After [exec.snd.expos]{.sref} paragraph 47 (_`not-a-sender`_), add the following
new paragraph]{.ednote}

> ::: add
>
> 48.
> > ```cpp
> > struct @_`not-a-scheduler`_@ {
> >   using scheduler_concept = scheduler_t;
> > 
> >   constexpr auto schedule() const noexcept {
> >     return @_`not-a-sender`_@();
> >   }
> > };
> > ```
>
> :::

[Add the following new paragraphs after [exec.snd.expos]{.sref} paragraph 50 as
follows:]{.ednote}

> ::: add
>
> ```cpp
> template<class Fn, class Default, class... Args>
>   constexpr auto @_`call-with-default`_@(Fn&& fn, Default&& value, Args&&... args) noexcept(@_`see below`_@);
> ```
>
> 52. Let `e` be the expression `std::forward<Fn>(fn)(std::forward<Args>(args)...)` if
>     that expression is well-formed; otherwise, it is
>     `static_cast<Default>(std​::​forward<Default>(value))`.
>
> 53. _Returns_: `e`.
>
> 54. _Remarks_: The expression in the `noexcept` clause is `noexcept(e)`.
>
> 55. ```cpp
> template<class Tag>
>   struct @_`inline-attrs`_@ {
>     @_`see below`_@
>   };
> ```
>
> 56. For a subexpression `env`, ```@_`inline-attrs`_@<Tag>{}.query(get_completion_scheduler<Tag>, env)```
>     is expression-equivalent to `get_scheduler(env)`.
>
> 57. For a subexpression `env`, ```@_`inline-attrs`_@<Tag>{}.query(get_completion_domain<Tag>, env)```
>     is expression-equivalent to `get_domain(env)`.
>
> :::

[Add a new subsection before [exec.domain.default] with stable name
[exec.domain.indeterminate] as follows:]{.ednote}

> ::: add
> 
> ### 33.9.? `execution::indeterminate_domain` [exec.domain.indeterminate]
>
> 1.
> ```cpp
> namespace std::execution {
>   template<class... Domains>
>     struct indeterminate_domain {
>       indeterminate_domain() = default;
>       constexpr indeterminate_domain(auto&&) noexcept {}
> 
>       template<class Tag, sender Sndr, @_`queryable`_@ Env>
>         static constexpr sender decltype(auto) transform_sender(Tag, Sndr&& sndr, const Env& env)
>           noexcept(@_`see below`_@);
>     };
> }
> ```
> 
> ```cpp
> template<class Tag, sender Sndr, @_`queryable`_@ Env>
>   static constexpr sender decltype(auto) transform_sender(Tag, Sndr&& sndr, const Env& env)
>     noexcept(@_`see below`_@);
> ```
> 
> 2. _Mandates_: For each type `D` in `Domains...`, the expression
>    `D().transform_sender(Tag(), std::forward<Sndr>(sndr), env)` is either ill-formed or
>    has the same decayed type as
>    `default_domain().transform_sender(Tag(), std::forward<Sndr>(sndr), env)`.
> 
> 3. _Returns_: `default_domain().transform_sender(Tag(), std::forward<Sndr>(sndr), env)`
> 
> 4. _Remarks_: For a pack of types `Ds`,
>    `common_type_t<indeterminate_domain<Domains...>, indeterminate_domain<Ds...>>` is
>    `indeterminate_domain<Us...>` where `Us` is the pack of types in `Domains..., Ds...`
>    except with duplicate types removed. For a type `D` that is not a specialization of
>    `indeterminate_domain`, `common_type_t<indeterminate_domain<Domains...>, D>` is
>    `D` if `sizeof...(Domains) == 0` is `true`, and
>    `common_type_t<indeterminate_domain<Domains...>, indeterminate_domain<D>>` otherwise.
> 
> :::

[Change [exec.domain.default]{.sref} as follows:]{.ednote}

> ### 33.9.5 `execution​::​default_domain` [exec.domain.default]
>
> 1.
> ```cpp
> namespace std::execution {
>   struct default_domain {
>     template<@[class Tag, ]{.add}@ sender Sndr, @_`queryable`_[`...`]{.rm}@ Env>
>         @[`requires (sizeof...(Env) <= 1)`]{.rm}@
>       static constexpr sender decltype(auto) transform_sender(@[`Tag, `]{.add}@ Sndr&& sndr, const Env&@[`...`]{.rm}@ env)
>         noexcept(@_`see below`_@);
>
>     @@[```template<sender Sndr, @_`queryable`_@ Env>```]{.rm}@@
>       @@[```static constexpr @_`queryable`_@ decltype(auto) transform_env(Sndr&& sndr, Env&& env) noexcept;```]{.rm}@@
>
>     template<class Tag, sender Sndr, class... Args>
>       static constexpr decltype(auto) apply_sender(Tag, Sndr&& sndr, Args&&... args)
>         noexcept(@_`see below`_@);
>   };
> }
> ```
>
> ```cpp
> template<@[class Tag, ]{.add}@ sender Sndr, @_`queryable`_[`...`]{.rm}@ Env>
>     @[`requires (sizeof...(Env) <= 1)`]{.rm}@
>   static constexpr sender decltype(auto) transform_sender(@[`Tag, `]{.add}@ Sndr&& sndr, const Env&@[`...`]{.rm}@ env)
>     noexcept(@_`see below`_@);
> ```
>
> 2. Let `e` be the expression
>
>    > ```cpp
>    > tag_of_t<Sndr>().transform_sender(@[`Tag(), `]{.add}@std::forward<Sndr>(sndr), env@[`...`]{.rm}@)
>    > ```
>
>    if that expression is well-formed; otherwise,
>    ```@[`static_cast<Sndr>(`]{.add}@std​::​forward<Sndr>(sndr)@[`)`]{.add}@```. [See
>    [https://cplusplus.github.io/LWG/issue4368](https://cplusplus.github.io/LWG/issue4368)
>    for why the `static_cast` is necessary.]{.ednote}
>
> 3. _Returns_: `e`.
>
> 4. _Remarks_: The exception specification is equivalent to `noexcept(e)`.
>
> ::: rm
>
> ```cpp
> template<sender Sndr, @_`queryable`_@ Env>
>   constexpr @_`queryable`_@ decltype(auto) transform_env(Sndr&& sndr, Env&& env) noexcept;
> ```
>
> 5. Let e be the expression
>
>    > ```cpp
>    > tag_of_t<Sndr>().transform_env(std::forward<Sndr>(sndr), std::forward<Env>(env))
>    > ```
>
>    if that expression is well-formed; otherwise, ```@_`FWD-ENV`_@(std​::​forward<Env>(env))```.
>
> 6. _Mandates_: `noexcept(e)` is `true`.
>
> 7. _Returns_: `e`.
>
> :::
>
> ```cpp
> template<class Tag, sender Sndr, class... Args>
> constexpr decltype(auto) apply_sender(Tag, Sndr&& sndr, Args&&... args)
>   noexcept(@_`see below`_@);
> ```
>
> 8. Let `e` be the expression
>
>    > ```cpp
>    > Tag().apply_sender(std::forward<Sndr>(sndr), std::forward<Args>(args)...)
>    > ```
>
> 9. _Constraints_: `e` is a well-formed expression.
>
> 10. _Returns_: `e`.
>
> 11. _Remarks_: The exception specification is equivalent to `noexcept(e)`.



[Change [exec.snd.transform]{.sref} as follows:]{.ednote}

> ### `execution::transform_sender`        [exec.snd.transform]
>
> ```cpp
> namespace std::execution {
>   template<@[`class Domain,`]{.rm}@ sender Sndr, @_`queryable`_[`...`]{.rm}@ Env>
>       @[`requires (sizeof...(Env) <= 1)`]{.rm}@
>     constexpr sender decltype(auto) transform_sender(@[`Domain dom,`]{.rm}@ Sndr&& sndr, const Env&@[`...`]{.rm}@ env)
>       noexcept(@_`see below`_@);
> }
> ```
>
> ::: add
>
> 1. For a subexpression `s`, let ```@_`domain-for`_@(start, s)``` be `D()` where
>    `D` is the decayed type of `get_domain(env)` if that expressions that is well-formed,
>    and `default_domain` otherwise.
>
> 2. Let ```@_`domain-for`_@(set_value, s)``` be `D()` where `D` is the decayed
>    type of  `get_completion_domain<>(get_env(sndr), env)` if that
>    is well-formed, and `default_domain` otherwise.
>
> :::
>
> 3. Let ```@_`transformed-sndr`_[`(dom, tag, s)`]{.add}@``` be the expression
>
>    > ```cpp
>    > @[`dom.transform_sender(std::forward<Sndr>(sndr), env...)`]{.rm}@
>    > @[`dom.transform_sender(tag, s, env)`]{.add}@
>    > ```
>
>    if that expression is well-formed; otherwise,
>
>    > ```cpp
>    > @[`default_domain().transform_sender(std::forward<Sndr>(sndr), env...)`]{.rm}@
>    > @[`default_domain().transform_sender(tag, s, env)`]{.add}@
>    > ```
>
>    Let [_`final-sndr`_]{.rm} [```@_`transform-recurse`_@(dom, tag, s)```]{.add} be the
>    expression ```@_`transformed-sndr`_[(dom, tag, s)]{.add}@``` if
>    ```@_`transformed-sndr`_[(dom, tag, s)]{.add}@``` and [`sndr`]{.rm} [`s`]{.add} have
>    the same type ignoring `cv`-qualifiers; otherwise, it is the expression
>    [```transform_sender(dom, @_`transformed-sndr`_@, env...)```]{.rm}
>    [```@_`transform-recurse`_@(dom2, tag, s2)``` where `s2` is
>    ```@_`transformed-sender`_@(dom, tag, s)``` and `dom2` is
>    ```@_`domain-for`_@(tag, s2)```]{.add}.
>
>    ::: add
>
>    Let _`tmp-sndr`_ be the expression
>
>    > ```cpp
>    > @_`transform-recurse`_@(@_`domain-for`_@(set_value, sndr), set_value, sndr)
>    > ```
>
>    and let _`final-sndr`_ be the expression
>
>    > ```cpp
>    > @_`transform-recurse`_@(@_`domain-for`_@(start, @_`tmp-sndr`_@), start, @_`tmp-sndr`_@)
>    > ```
>
>    :::
>
> 2. _Returns_: _`final-sndr`_.
>
> 3. _Remarks_: The exception specification is equivalent to ```noexcept(@_`final-sndr`_@)```.


[Remove section [exec.snd.transform.env]{.sref}.]{.ednote}


[Change [exec.getcomplsigs]{.sref} paragraphs 1 and 4 as follows:]{.ednote}

> ```cpp
> template<class Sndr, class... Env>
>   consteval auto get_completion_signatures() -> @_`valid-completion-signatures`_@ auto;
> ```
>
> 1. Let _`except`_ be an rvalue subexpression of an unspecified class type
>    _`Except`_ such that ```move_constructible<@_`Except`_@> && derived_from<@_`Except`_@, exception>``` is
>    `true`. Let ```@_`CHECKED-COMPLSIGS`_@(@_`e`_@)``` be _`e`_ if _`e`_ is a core constant expression whose type
>    satisfies _`valid-completion-signatures`_; otherwise, it is the following expression:
>    ```(@_`e`_@, throw @_`except`_@, completion_signatures())``` Let ```@_`get-complsigs`_@<Sndr, Env...>()``` be
>    expression-equivalent to
>    `remove_reference_t<Sndr>​::​template get_completion_signatures<Sndr, Env...>()`. Let `NewSndr` be `Sndr` if
>    `sizeof...(Env) == 0` is `true`; otherwise, ```decltype(@_`s`_@)``` where _`s`_ is the following expression:
>
>    > ```cpp
>    > transform_sender(
>    >   @@[```@_`get-domain-late`_@(declval<Sndr>(), declval<Env>()...),```]{.rm}@@
>    >   declval<Sndr>(),
>    >   declval<Env>()...)
>    > ```
>
> 2. [&hellip; as before &hellip;]{.blue}
>
> 3. [&hellip; as before &hellip;]{.blue}
>
> 4. Given a type `Env`, if `completion_signatures_of_t<Sndr>` and
>    `completion_signatures_of_t<Sndr, Env>` are both well-formed, [they shall denote the
>    same type]{.rm} [the latter shall be a superset of the former, with completion
>    signatures that are in `completion_signatures_of_t<Sndr, Env>` but not
>    `completion_signatures_of_t<Sndr>` corresponding to error or stopped completion
>    operations]{.add}.


[Change [exec.connect]{.sref} paragraph 2 as follows:]{.ednote}

> 2. The name `connect` denotes a customization point object. For subexpressions
>    `sndr` and `rcvr`, let `Sndr` be `decltype((sndr))` and `Rcvr` be `decltype((rcvr))`,
>    let `new_sndr` be the expression
>
>    > ```cpp
>    > transform_sender(@@[```decltype(@_`get-domain-late`_@(sndr, get_env(rcvr))){},```]{.rm}@@ sndr, get_env(rcvr))
>    > ```
>
>    and let `DS` and `DR` be `decay_t<decltype((new_sndr))>` and `decay_t<Rcvr>`,
>    respectively.


[Remove [exec.schedule]{.sref} paragraph 4 as follows:]{.ednote}

> ::: rm
>
> 4. If the expression
>
>    > ```cpp
>    > get_completion_scheduler<set_value_t>(get_env(sch.schedule())) == sch
>    > ```
>
>    is ill-formed or evaluates to `false`, the behavior of calling `schedule(sch)` is
>    undefined.
>
> :::


[Change [exec.adapt.general]{.sref} paragraph 3.2-3 as follows:]{.ednote}

> - [3.2]{.pnum} A parent sender ([exec.async.ops]{.sref}) with a single child sender
>   `sndr` has an associated attribute object equal to ```@_`FWD-ENV`_@(get_env(sndr))```
>   ([exec.fwd.env]{.sref}) [modulo the handling of the
>   ```get_completion_scheduler<@_`completion-tag`_@>``` and
>   ```get_completion_domain<@_`completion-tag`_@>``` queries as described in
>   [exec.snd.general]]{.add}.
> 
> - [3.3]{.pnum} A parent sender with more than one child sender has an associated
>   attributes object equal to `env<>{}` [modulo the handling of the
>   ```get_completion_scheduler<@_`completion-tag`_@>``` and
>   ```get_completion_domain<@_`completion-tag`_@>``` queries as described in
>   [exec.snd.general]]{.add}.


[Change [exec.starts.on]{.sref} paragraphs 3 and 4, and insert a new paragraph 5 as
follows:]{.ednote}

> 3. Otherwise, the expression `starts_on(sch, sndr)` is expression-equivalent to:
>
>    > ```cpp
>    > @@[`transform_sender(`]{.rm}@@
>    >   @@[```@_`query-with-default`_@(get_domain, sch, default_domain()),```]{.rm}@@
>    >   @_`make-sender`_@(starts_on, sch, sndr)@[`)`]{.rm}@
>    > ```
>
>    [except that `sch` is evaluated only once.]{.rm}
>
> 4. Let `out_sndr` and env be subexpressions such that `OutSndr` is
>    `decltype((out_sndr))`. If ```@_`sender-for`_@<OutSndr, starts_on_t>``` is `false`,
>    then the expression[s `starts_on.transform_env(out_sndr, env)` and]{.rm}
>    ```starts_on.transform_sender(@[`set_value,`]{.add}@ out_sndr, env)```
>    [are]{.rm}[is]{.add} ill-formed; otherwise
>
>    ::: rm
>
>    - [4.1]{.pnum} `starts_on.transform_env(out_sndr, env)` is equivalent to:
>
>    > ```cpp
>    > auto&& [_, sch, _] = out_sndr;
>    > return @_`JOIN-ENV`_@(@_`SCHED-ENV`_@(sch), @_`FWD-ENV`_@(env));
>    > ```
>
>    :::
>
>    - [4.2]{.pnum} ```starts_on.transform_sender(@[`set_value,`]{.add}@ out_sndr, env)``` is equivalent to:
>
>    > ```cpp
>    > auto&& [_, sch, sndr] = out_sndr;
>    > return let_value(
>    >   @[schedule(sch),]{.rm}@
>    >   @[`continues_on(just(), sch),`]{.add}@
>    >   [sndr = std::forward_like<OutSndr>(sndr)]() mutable
>    >     noexcept(is_nothrow_move_constructible_v<decay_t<OutSndr>>) {
>    >     return std::move(sndr);
>    >   });
>    > ```

[Remove subsection [exec.continues.on]{.sref}]{.ednote}

[Change stable name [exec.schedule.from]{.sref} to [exec.continues.on], and change the
subsection as follows:]{.ednote}

> **33.9.12.[7]{.rm}[6]{.add} ```execution::@[`schedule_from`]{.rm}[`continues_on`]{.add}@             ```{.cpp} [exec[.schedule.from]{.rm}[.continues.on]{.add}]**
>
>
> 1. [`schedule_from`]{.rm}[`continues_on`]{.add} schedules work dependent on the completion
>    of a sender onto a scheduler's associated execution resource.
>
>    [[_Note 1_:` schedule_from` is not meant to be used in user code; it is used in the
>    implementation of `continues_on`. — end note]]{.rm}
>
> 2. The name [`schedule_from`]{.rm}[`continues_on`]{.add} denotes a customization point
>    object. For some subexpressions `sch` and `sndr`, let `Sch` be `decltype((sch))` and
>    `Sndr` be `decltype((sndr))`. If `Sch` does not satisfy scheduler, or `Sndr` does not
>    satisfy `sender`,
>    [`schedule_from(sch, sndr)`{.cpp}]{.rm}[`continues_on(sndr, sch)`{.cpp}]{.add} is
>    ill-formed.
>
> 3. Otherwise, the expression
>    [`schedule_from(sch, sndr)`{.cpp}]{.rm}[`continues_on(sndr, sch)`{.cpp}]{.add} is
>    expression-equivalent to[:]{.rm}
>    [```@_`make-sender`_@(continues_on, sch, schedule_from(sndr))```{.cpp}]{.add}
>
>    ::: rm
>
>    > ```cpp
>    > transform_sender(
>    >    @_`query-with-default`_@(get_domain, sch, default_domain()),
>    >    @_`make-sender`_@(schedule_from, sch, sndr))
>    > ```
>
>    except that sch is evaluated only once.
>
>    :::
>
> 4. The exposition-only class template _`impls-for`_ ([exec.snd.general]{.sref}) is
>    specialized for [`schedule_from_t`]{.rm}[`continues_on_t`]{.add} as follows:
>
>    > ```cpp
>    > namespace std::execution {
>    >    template<>
>    >    struct @_`impls-for`_@<@[`schedule_from_t`]{.rm}[`continues_on_t`]{.add}@> : @_`default-impls`_@ {
>    >       @@[```static constexpr auto @_`get-attrs`_@ = @_`see below`_@;```]{.rm}@@
>    >       static constexpr auto @_`get-state`_@ = @_`see below`_@;
>    >       static constexpr auto @_`complete`_@ = @_`see below`_@;
>    >
>    >       template<class Sndr, class... Env>
>    >         static consteval void @_`check-types`_@();
>    >    };
>    > }
>    > ```
>
> ::: rm
>
> 5. The member ```@_`impls-for`_@<schedule_from_t>​::@_`​get-attrs`_@```{.cpp}
>    is initialized with a callable object equivalent to the following lambda:
>
>    > ```cpp
>    > [](const auto& data, const auto& child) noexcept -> decltype(auto) {
>    >   return @_`JOIN-ENV`_@(@_`SCHED-ATTRS`_@(data), @_`FWD-ENV`_@(get_env(child)));
>    > }
>    > ```
>
> :::
>
> 6. The member ```@_`impls-for`_@<@[`schedule_from_t`]{.rm}[`continues_on_t`]{.add}@>​::@_`​get-state`_@```{.cpp}
>    is initialized with a callable object equivalent to the following lambda:
>
>    [&hellip; as before &hellip;]{.blue}
>
> [&hellip; as before &hellip;]{.blue}
>
> 12. The member ```@_`impls-for`_@<@[`schedule_from_t`]{.rm}[`continues_on_t`]{.add}@>​::@_`complete`_@```{.cpp}
>     is initialized with a callable object equivalent to the following lambda:
>
>     [&hellip; as before &hellip;]{.blue}
>
> 13. Let `out_sndr` be a subexpression denoting a sender returned from
>     [`schedule_from(sch, sndr)`]{.rm}[`continues_on(sndr, sch)`]{.add} or one equal to
>     such, and let `OutSndr` be the type `decltype((out_sndr))`. Let `out_rcvr` be
>     [&hellip; as before &hellip;]{.blue}


[After [exec.continues.on]{.sref}, add a new subsection with stable name
[exec.schedule.from] as follows:]{.ednote}

> ::: add
>
> ### ```execution::schedule_from                         ```{.cpp} [exec.schedule.from]
>
> 1. `schedule_from` offers scheduler authors a way to customize how to transition off of
>    their schedulers' associated execution contexts.
>
>    [` schedule_from` is not meant to be used in user code; it is used in the
>    implementation of `continues_on`.]{.note}
>
> 2. The name `schedule_from` denotes a customization point object. For some subexpression
>    `sndr`, if `decltype(sndr)` does not satisfy `sender`, `schedule_from(sndr)` is
>    ill-formed.
>
> 3. Otherwise, the expression `schedule_from(sndr)` is expression-equivalent to
>    ```@_`make-sender`_@(schedule_from, {}, sndr)```.
>
> :::

[Change [exec.on]{.sref} as follows:]{.ednote}


> ### ```execution::on             ```{.cpp} [exec.on]
>
> 1. The `on` sender adaptor has two forms [&hellip; as before &hellip;]{.blue}
>
> 2. The name `on` denotes a [&hellip; as before &hellip;]{.blue}
>
> 3. Otherwise, if `decltype((sndr))` satisfies `sender`, the expression `on(sch, sndr)` is expression-equivalent to:
>
>
>    ```cpp
>    @[`transform_sender(`]{.rm}@
>      @@[```@_`query-with-default`_@(get_domain, sch, default_domain()),```]{.rm}@@
>      make-sender(on, sch, sndr)@[`)`]{.rm}@
>    ```
>
>    [except that `sch` is evaluated only once.]{.rm}
>
> 4. For subexpressions `sndr`, `sch`, and `closure`, if
>
>    - [4.1]{.pnum} `decltype((sch))` does not satisfy `scheduler`, or
>    - [4.2]{.pnum} `decltype((sndr))` does not satisfy `sender`, or
>    - [4.3]{.pnum} `closure` is not a pipeable sender adaptor closure object ([exec.adapt.obj]{.sref}),
>
>    the expression `on(sndr, sch, closure)` is ill-formed; otherwise, it is expression-equivalent to:
>
>    ```cpp
>    @[`transform_sender(`]{.rm}@
>      @@[```@_`get-domain-early`_@(sndr),```]{.rm}@@
>      make-sender(on, @_`product-type`_@{sch, closure}, sndr)@[`)`]{.rm}@
>    ```
>
>    [except that `sndr` is evaluated only once.]{.rm}
>
> 5. Let `out_sndr` and `env` be subexpressions, let `OutSndr` be `decltype((out_sndr))`,
>    and let `Env` be `decltype((env))`. If ```@_`sender-for`_@<OutSndr, on_t>``` is
>    `false`, then the expression[s `on.transform_env(out_sndr, env)` and]{.rm}
>    ```on.transform_sender(@[`set_value, `]{.add}@out_sndr, env)``` [are]{.rm}[is]{.add} ill-formed.
>
> ::: rm
>
> 6. Otherwise: Let _`not-a-scheduler`_ be an unspecified empty class type.
>
> 7. The expression `on.transform_env(out_sndr, env)` has effects equivalent to:
>
>    > ```cpp
>    > auto&& [_, data, _] = out_sndr;
>    > if constexpr (scheduler<decltype(data)>) {
>    >   return @_`JOIN-ENV`_@(@_`SCHED-ENV`_@(std::forward_like<OutSndr>(data)), @_`FWD-ENV`_@(std::forward<Env>(env)));
>    > } else {
>    >   return std::forward<Env>(env);
>    > }
>    > ```
>
> :::
>
> 8. [Otherwise, ]{.add} [T]{.rm}[t]{.add}he expression
>    ```on.transform_sender(@[set_value, ]{.add}@out_sndr, env)``` has effects equivalent to:
>
>    > ```cpp
>    > auto&& [_, data, child] = out_sndr;
>    > if constexpr (scheduler<decltype(data)>) {
>    >   auto orig_sch =
>    >     @[_`query`_]{.rm}[_`call`_]{.add}_`-with-default`_@(get_scheduler @[`, env`]{.rm}@, @_`not-a-scheduler`_@()@[`, env`]{.add}@);
>    >
>    >   @@[```if constexpr (same_as<decltype(orig_sch), @_`not-a-scheduler`_@>) {```]{.rm}@@
>    >     @@[```return @_`not-a-sender`_@{};```]{.rm}@@
>    >   @@[```} else {```]{.rm}@@
>    >     return continues_on(
>    >       starts_on(std::forward_like<OutSndr>(data), std::forward_like<OutSndr>(child)),
>    >       std::move(orig_sch));
>    >   @[`}`]{.rm}@
>    > } else {
>    >   auto& [sch, closure] = data;
>    >   auto orig_sch = @[_`query`_]{.rm}[_`call`_]{.add}_`-with-default`_@(
>    >     get_completion_scheduler<set_value_t>, @@[```@_`not-a-scheduler`_@(), get_env(child), env);```]{.add}@@
>    >     @@[```get_env(child),```]{.rm}@@
>    >     @@[```@_`query-with-default`_@(get_scheduler, env, @_`not-a-scheduler`_@()));```]{.rm}@@
>    >
>    >   @@[```if constexpr (same_as<decltype(orig_sch), @_`not-a-scheduler`_@>) {```]{.rm}@@
>    >     @@[```return @_`not-a-sender`_@{};```]{.rm}@@
>    >   @@[```} else {```]{.rm}@@
>    >     return @[`write_env`]{.rm}` `[`continues_on`]{.add}@(
>    >       @[`continues_on`]{.rm}` `[`write_env`]{.add}@(
>    >         std::forward_like<OutSndr>(closure)(
>    >           continues_on(
>    >             write_env(std::forward_like<OutSndr>(child), @_`SCHED-ENV`_@(orig_sch)),
>    >             sch)),
>    >         @@[`orig_sch`]{.rm}` `[```@_`SCHED-ENV`_@(sch)```]{.add}@@),
>    >       @@[```@_`SCHED-ENV`_@(sch)```]{.rm}` `[`orig_sch`]{.add}@@);
>    >   @[`}`]{.rm}@
>    > }
>    > ```


[Change [exec.then]{.sref} paragraphs 3 as follows:]{.ednote}

> 3. Otherwise, the expression ```@_`then-cpo`_@(sndr, f)``` is expression-equivalent to:
>
>    > ```cpp
>    > @@```@[transform_sender(_`get-domain-early`_(sndr),]{.rm}@ @_`make-sender`_@(@_`then-cpo`_@, f, sndr)@[`)`]{.rm}@```@@
>    > ```
>
>    [except that `sndr` is evaluated only once.]{.rm}


[Change [exec.let]{.sref} as follows:]{.ednote}

> 1. `let_value`, `let_error`, and `let_stopped` [&hellip; as before &hellip;]{.blue}
>
> 2. For `let_value`, `let_error`, and `let_stopped`, let _`set-cpo`_ be `set_value`,
>    `set_error`, and `set_stopped`, respectively. Let the expression _`let-cpo`_ be one
>    of `let_value`, `let_error`, or `let_stopped`. For [a]{.rm} subexpression[s]{.add}
>    `sndr` [and `env`]{.add}, let ```@_`let-env`_@(sndr@[`, env`]{.add}@)``` be
>    expression-equivalent to the first well-formed expression below:
>
>    - [2.1]{.pnum} ```@_`SCHED-ENV`_@(get_completion_scheduler<@_`decayed-typeof`_@<@_`set-cpo`_@>>(get_env(sndr)@[`,`]{.add}@ @[_`FWD-ENV`_]{.add}[`(env)`]{.add}@))```
>
>    ::: rm
>
>    - [2.2]{.pnum} ```@_`MAKE-ENV`_@(get_domain, get_domain(get_env(sndr)))```
>
>    :::
>
>    ::: add
>
>    - [2.2]{.pnum} ```@_`MAKE-ENV`_@(get_domain, get_completion_domain<@_`decayed-typeof`_@<@_`set-cpo`_@>>(get_env(sndr), @_`FWD-ENV`_@(env)))```
>
>    :::
>
>    - [2.3]{.pnum} ```(void(sndr), env<>{})```
>
> 3. The names `let_value`, `let_error`, and `let_stopped` denote [&hellip; as before &hellip;]{.blue}
>
> 4. Otherwise, the expression ```@_`let-cpo`_@(sndr, f)``` is expression-equivalent to:
>
>    > ```cpp
>    > @@[```transform_sender(@_`get-domain-early`_@(sndr),```]{.rm}@@ @_`make-sender`_@(@_`let-cpo`_@, f, sndr)@[`)`]{.rm}@
>    > ```
>
>    [except that `sndr` is evaluated only once.]{.rm}
>
> 5. The exposition-only class [&hellip; as before &hellip;]{.blue}
>
> 6. Let _`receiver2`_ denote the following exposition-only class template:
>
>    > ```cpp
>    > namespace std::execution {
>    >   template<class Rcvr, class Env>
>    >   struct @_`receiver2`_@ {
>    >     @[&hellip; _as before_ &hellip;]{.blue}@
>    >   };
>    > }
>    > ```
>
>    Invocation of the function ```@_`receiver2​`_@::​get_env``` returns an object e such that
>
>    - [6.1]{.pnum} `decltype(e)` models _`queryable`_ and
>
>    - [6.2]{.pnum} given a query object `q` [and pack of subexpressions `as`]{.add}, the
>      expression ```e.query(q@[`, as...`]{.add}@)``` is expression-equivalent to
>      ```env.query(q@[`, as...`]{.add}@)``` if that expression is valid; otherwise, if
>      the type of `q` satisfies _`forwarding-query`_, ```e.query(q@[`, as...`]{.add}@)```
>      is expression-equivalent to ```get_env(rcvr).query(q@[`, as...`]{.add}@)```;
>      otherwise, ```e.query(q@[`, as...`]{.add}@)``` is ill-formed.
>
> 7. _Effects:_ Equivalent to:
>
>    [&hellip; as before &hellip;]{.blue}
>
>    where _`env-t`_ is the pack
>    [```decltype(@_`let-cpo`_@.transform_env(declval<Sndr>(), declval<Env>()))```]{.rm}
>    [```decltype(@_`JOIN-ENV`_@(@_`let-env`_@(declval<@_`child-type`_@<Sndr>>(), declval<Env>()), @_`FWD-ENV`_@(declval<Env>())))```]{.add}.
>
> 8. ```@_`impls-for`_@<@_`decayed-typeof`_@<@_`let-cpo`_@>>::@_`get-state`_@``` is
>    initialized with a callable object equivalent to the following:
>
>    > ```cpp
>    > []<class Sndr, class Rcvr>(Sndr&& sndr, Rcvr& rcvr) requires @_`see below`_@ {
>    >   auto& [_, fn, child] = sndr;
>    >   using fn_t = decay_t<decltype(fn)>;
>    >   using env_t = decltype(@_`let-env`_@(child@[`, get_env(rcvr)`]{.add}@));
>    >   using args_variant_t = @_`see below`_@;
>    >   using ops2_variant_t = @_`see below`_@;
>    >
>    >   struct @_`state-type`_@ {
>    >     fn_t fn;                    // exposition only
>    >     env_t env;                  // exposition only
>    >     args_variant_t args;        // exposition only
>    >     ops2_variant_t ops2;        // exposition only
>    >   };
>    >   return @_`state-type`_@{@_`allocator-aware-forward`_@(std::forward_like<Sndr>(fn), rcvr),
>    >                     @_`let-env`_@(child@[`, get_env(rcvr)`]{.add}@), {}, {}};
>    > }
>    > ```
>
> [leave paragraphs 9-13 unchanged]{.ednote}
>
> ::: rm
>
> 14. Let `sndr` and `env` be subexpressions, and let `Sndr` be `decltype((sndr))`. If
>     ```@_`sender-for`_@<Sndr, @_`decayed-typeof`_@<@_`let-cpo`_@>>``` is `false`, then
>     the expression ```@_`let-cpo`_@.transform_env(sndr, env)``` is ill-formed.
>     Otherwise, it is equal to:
>
>     > ```cpp
>     > auto& [_, _, child] = sndr;
>     > return @_`JOIN-ENV`_@(@_`let-env`_@(child), @_`FWD-ENV`_@(env));
>     > ```
>
> :::
>
> 15. Let the subexpression `out_sndr` denote [&hellip; as before &hellip;]{.blue}

[Change [exec.bulk]{.sref} paragraph 3 and 4 as follows:]{.ednote}

> 3. Otherwise, the expression ```@_`bulk-algo`_@(sndr, policy, shape, f)``` is
>    expression-equivalent to:
>
>    > ```c++
>    > @@[```transform_sender(@_`get-domain-early`_@(sndr),```]{.rm}@@ @_`make-sender`_@(
>    >    @_`bulk-algo`_@, @_`product-type`_@<@_`see below`_@, Shape, Func>{policy, shape, f}, sndr)@[`)`]{.rm}@
>    > ```
>
>    [except that `sndr` is evaluated only once.]{.rm}
>
>    The first template argument of _`product-type`_ is `Policy` if `Policy` models
>    `copy_constructible`, and `const Policy&` otherwise.
>
> 4. Let `sndr` and `env` be subexpressions such that `Sndr` is `decltype((sndr))`. If
>    ```@_`sender-for`_@<Sndr, bulk_t>``` is `false`, then the expression
>    ```bulk.transform_sender(@[`set_value,`]{.add}@ sndr, env)```
>    is ill-formed; otherwise, it is equivalent to:
>
>    ```cpp
>    auto [_, data, child] = sndr;
>    auto& [policy, shape, f] = data;
>    auto new_f = [func = std::move(f)](Shape begin, Shape end, auto&&... vs)
>        noexcept(noexcept(f(begin, vs...))) {
>      while (begin != end) func(begin++, vs...);
>    }
>    return bulk_chunked(std::move(child), policy, shape, std::move(new_f));
>    ```
>
>    [This causes the `bulk(sndr, policy, shape, f)` sender to be expressed in terms of
>    `bulk_chunked(sndr, policy, shape, f)` when it is connected to a receiver whose
>    execution domain does not customize `bulk`.]{.note}


[Change [exec.when.all]{.sref} paragraphs 2 and 3 as follows:]{.ednote}

> 2. The names `when_all` and `when_all_with_variant` denote customization point objects.
>    Let `sndrs` be a pack of subexpressions[,]{.rm} [and]{.add} let `Sndrs` be a pack of
>    the types `decltype((sndrs))...` [, and let `CD` be the type
>    ```common_type_t<decltype(@_`get-domain-early`_@(sndrs))...>```. Let `CD2` be `CD` if
>    `CD` is well-formed, and `default_domain` otherwise]{.rm}. The expressions
>    `when_all(sndrs...)` and `when_all_with_variant(sndrs...)` are ill-formed if any of
>    the following is `true`:
>
>    - [2.1]{.pnum} `sizeof...(sndrs)` is `0`, or
>
>    - [2.2]{.pnum} `(sender<Sndrs> && ...)` is `false`.
>
> 3. The expression `when_all(sndrs...)` is expression-equivalent to:
>
>    > ```cpp
>    > @[`transform_sender(CD2(),`]{.rm}@ @_`make-sender`_@(when_all, {}, sndrs...)@[`)`]{.rm}@
>    > ```
>
> 4. The exposition-only class template impls-for ([exec.snd.expos]) is specialized for when_all_t as follows:
> 
>    > ```cpp
>    > namespace std::execution {
>    >   template<>
>    >   struct @_`impls-for`_@<when_all_t> : @_`default-impls`_@ {
>    >     @@[```static constexpr auto @_`get-attrs`_@ = @_`see below`_@;```]{.rm}@@
>    >     static constexpr auto @_`get-env`_@ = @_`see below`_@;
>    >     static constexpr auto @_`get-state`_@ = @_`see below`_@;
>    >     static constexpr auto @_`start`_@ = @_`see below`_@;
>    >     static constexpr auto @_`complete`_@ = @_`see below`_@;
>    > 
>    >     template<class Sndr, class... Env>
>    >       static consteval void @_`check-types`_@();
>    >   };
>    > }
>    > ```

[Remove [exec.when.all]{.sref} paragraphs 10-11 as follows:]{.ednote}

> ```cpp
> template<class Sndr, class... Env>
>   static consteval void @_`check-types`_@();
> ```
>
> 8. Let `Is` be the pack of integral template arguments of the `integer_sequence`
>    specialization denoted by ```@_`indices-for`_@<Sndr>```.
>
> 9. _Effects_: Equivalent to: [&hellip; as before &hellip;]{.blue}
>
> ::: rm
>
> 10. _Throws_: Any exception thrown as a result of evaluating the _Effects_, or an exception
>     of an unspecified type derived from `exception` when `CD` is ill-formed.
>
> 11. The member ```@_`impls-for`_@<when_all_t>​::@_`​get-attrs`_@``` is initialized with a
>     callable object equivalent to the following lambda expression:
>
>     > ```c++
>     > [](auto&&, auto&&... child) noexcept {
>     >   if constexpr (same_as<CD, default_domain>) {
>     >     return env<>()
>     >   } else {
>     >     return @_`MAKE-ENV`_@(get_domain, CD())
>     >   }
>     >   return @_`see below`_@;
>     > }
>     > ```
>
> :::


[Change [exec.when.all]{.sref} paragraphs 20 and 21 as follows:]{.ednote}

> 20. The expression `when_all_with_variant(sndrs...)` is expression-equivalent to:
>
>     > ```cpp
>     > @[`transform_sender(CD2(),`]{.rm}@ @_`make-sender`_@(when_all_with_variant, {}, sndrs...)@[`);`]{.rm}@
>     > ```
>
> 21. Given subexpressions `sndr` and `env`, if
>     ```@_`sender-for`_@<decltype((sndr)), when_all_with_variant_t>``` is `false`, then the
>     expression ```when_all_with_variant.transform_sender(@[`set_value,`]{.add}@ sndr, env)```
>     is ill-formed; otherwise, it is equivalent to:
>
>     > ```cpp
>     > auto&& [_, _, ...child] = sndr;
>     > return when_all(into_variant(std::forward_like<decltype((sndr))>(child))...);
>     > ```
>
>     [This causes the `when_all_with_variant(sndrs...)` sender to become
>     `when_all(into_variant(sndrs)...)` when it is connected with a receiver whose
>     execution domain does not customize `when_all_with_variant`.]{.note}


[Change [exec.into.variant]{.sref} paragraph 3 as follows:]{.ednote}

> 3. Otherwise, the expression `into_variant(sndr)` is expression-equivalent to:
>
>    > ```cpp
>    > @@[```transform_sender(@_`get-domain-early`_@(sndr), ```]{.rm}@@
>    >                  @_`make-sender`_@(into_variant, {}, sndr)@[`);`]{.rm}@
>    > ```


[Change [exec.stopped.opt]{.sref} paragrpah 2-4 as follows:]{.ednote}

> 2. The name `stopped_as_optional` denotes a pipeable sender adaptor object.
>    For a subexpression `sndr`, let `Sndr` be `decltype((sndr))`.
>    The expression `stopped_as_optional(sndr)` is expression-equivalent to:
>
>    > ```cpp
>    > @@[```transform_sender(@_`get-domain-early`_@(sndr),```]{.rm}@@
>    >                  @_`make-sender`_@(stopped_as_optional, {}, sndr)@[`)`]{.rm}@
>    > ```
>
>    [except that `sndr` is only evaluated once.]{.rm}
>
> 3. The exposition-only class template [&hellip; as before &hellip;]{.blue}
>
> 4. Let `sndr` and `env` be subexpressions such that `Sndr` is `decltype((sndr))` and `Env`
>    is `decltype((env))`. If ```@_`sender-for`_@<Sndr, stopped_as_error_t>``` is `false`,
>    then the expression
>    ```stopped_as_error.transform_sender(@[`set_value,`]{.add}@ sndr, env)``` is ill-formed;
>    otherwise, it is equivalent to: [&hellip; as before &hellip;]{.blue}

[Change [exec.stopped.err]{.sref} paragrpah 1-3 as follows:]{.ednote}

> 1. `stopped_as_error` maps an input sender's stopped completion operation into an error
>    completion operation as a custom error type. The result is a sender that never
>    completes with stopped, reporting cancellation by completing with an error.
>
> 2. The name `stopped_as_error` denotes a pipeable sender adaptor object. For some
>    subexpressions `sndr` and `err`, let `Sndr` be `decltype((sndr))` and let `Err` be
>    `decltype((err))`. If the type `Sndr` does not satisfy sender or if the type `Err`
>    does not satisfy _`movable-value`_, `stopped_as_error(sndr, err)` is ill-formed.
>    Otherwise, the expression `stopped_as_error(sndr, err)` is expression-equivalent to:
>
>    > ```cpp
>    > @@[```transform_sender(@_`get-domain-early`_@(sndr),```]{.rm}@@ @_`make-sender`_@(stopped_as_error, err, sndr)@[`)`]{.rm}@
>    > ```
>
>    except that `sndr` is only evaluated once.
>
> 3. Let `sndr` and `env` be subexpressions such that `Sndr` is `decltype((sndr))` and
>    `Env` is `decltype((env))`. If ```@_`sender-for`_@<Sndr, stopped_as_error_t>``` is
>    `false`, then the expression
>    ```stopped_as_error.transform_sender(@[`set_value,`]{.add}@ sndr, env)``` is
>    ill-formed; otherwise, it is equivalent to: [&hellip; as before &hellip;]{.blue}

[Change [exec.associate]{.sref} paragraph 9 as follows:]{.ednote}

> 9. The name `associate` denotes a pipeable sender adaptor object. For subexpressions
>    `sndr` and `token`:
>
>    - [9.1]{.pnum} If `decltype((sndr))` does not satisfy `sender`, or
>      `remove_cvref_t<decltype((token))>` does not satisfy `scope_token`, then
>      `associate(sndr, token)` is ill-formed.
>
>    - [9.2]{.pnum} Otherwise, the expression `associate(sndr, token)` is
>      expression-equivalent to:
>
>      > ```cpp
>      > @@[```transform_sender(@_`get-domain-early`_@(sndr),```]{.rm}@@
>      >                  @_`make-sender`_@(associate, @_`associate-data`_@(token, sndr))@[`)`]{.rm}@
>      > ```
>
>      [except that `sndr` is evaluated only once.]{.rm}


[Change [exec.sync.wait]{.sref} paragraphs 4 as follows:]{.ednote}

> 4. The name `this_thread​::​sync_wait` denotes a customization point object. For a
>    subexpression `sndr`, let `Sndr` be `decltype((sndr))`. The expression
>    `this_thread​::​sync_wait(sndr)` is expression-equivalent to the following,
>    [except that `sndr` is evaluated only once]{.rm}:
>
>    > ```cpp
>    > apply_sender(@@[```@_`get-domain-early`_@(sndr)```]{.rm}[`Domain()`]{.add}@@, sync_wait, sndr)
>    > ```
>
>    [where `Domain` is the type of
>    ```get_completion_domain<set_value_t>(get_env(sndr), @_`sync-wait-env`_@{})```.]{.add}
>
>    _Mandates_:
>
>    - [4.1]{.pnum} ```sender_in<Sndr, @_`sync-wait-env`_@>``` is `true`.
>
>    - [4.2]{.pnum} The type ```@_`sync-wait-result-type`_@<Sndr>``` is well-formed.
>
>    - [4.3]{.pnum} ```same_as<decltype(@_`e`_@), @_`sync-wait-result-type`_@<Sndr>>``` is
>      `true`, where _`e`_ is the `apply_sender` expression above.



[Change [exec.sync.wait.var]{.sref} paragraph 1 as follows:]{.ednote}

> 1. The name `this_thread​::​sync_wait_with_variant` denotes a customization point
>    object. For a subexpression `sndr`, let `Sndr` be `decltype(into_variant(sndr))`. The
>    expression `this_thread​::​sync_wait_with_variant(sndr)` is
>    [expression-]{.rm}equivalent to the following, except `sndr` is evaluated only once:
>
>    > ```cpp
>    > apply_sender(@@[```@_`get-domain-early`_@(sndr)```]{.rm}[`Domain()`]{.add}@@, sync_wait_with_variant, sndr)
>    > ```
>
>    [where `Domain` is the type of
>    ```get_completion_domain<set_value_t>(get_env(sndr), @_`sync-wait-env`_@{})```.]{.add}
>
>    _Mandates_:
>
>    - [1.1]{.pnum} ```sender_in<Sndr, @_`sync-wait-env`_@>``` is `true`.
>
>    - [1.2]{.pnum} The type ```@_`sync-wait-with-variant-result-type`_@<Sndr>``` is
>      well-formed.
>
>    - [1.3]{.pnum} ```same_as<decltype(@_`e`_@), @_`sync-wait-with-variant-result-type`_@<Sndr>>``` is `true`,
>      where _`e`_ is the `apply_sender` expression above.


[Change [exec.prop]{.sref} as follows:]{.ednote}

> ```cpp
> namespace std::execution {
>   template<class QueryTag, class ValueType>
>   struct prop {
>     QueryTag query_;            // exposition only
>     ValueType value_;           // exposition only
>
>     constexpr const ValueType& query(QueryTag@[`, auto&&...`]{.add}@) const noexcept {
>       return value_;
>     }
>   };
>
>   template<class QueryTag, class ValueType>
>     prop(QueryTag, ValueType) -> prop<QueryTag, unwrap_reference_t<ValueType>>;
> }
> ```
>
> [&hellip; as before &hellip;]{.blue}



[Change [exec.env]{.sref} as follows:]{.ednote}

> > ```cpp
> > namespace std::execution {
> >   template<@_`queryable`_@... Envs>
> >   struct env {
> >     @Envs~0~ envs~0~@;               // exposition only
> >     @Envs~1~ envs~1~@;               // exposition only
> >       ⋮
> >     @Envs~*n*-1~ envs~*n*-1~@;            // exposition only
> >
> >     template<class QueryTag@[`, class... Args`]{.add}@>
> >       constexpr decltype(auto) query(QueryTag q@[`, Args&&... args`]{.add}@) const noexcept(@_`see below`_@);
> >   };
> >
> >   template<class... Envs>
> >     env(Envs...) -> env<unwrap_reference_t<Envs>...>;
> > }
> > ```
>
> 1. The class template `env` is used to construct a queryable object from several
>    queryable objects. Query invocations on the resulting object are resolved by
>    attempting to query each subobject in lexical order.
>
> > [&hellip; as before &hellip;]{.blue}
>
> > ```cpp
> > template<class QueryTag@[`, class... Args`]{.add}@>
> > constexpr decltype(auto) query(QueryTag q@[`, Args&&... args`]{.add}@) const noexcept(@_`see below`_@);
> > ```
>
> 5. Let _`has-query`_ be the following exposition-only concept:
>
>    > ```cpp
>    > template<class Env, class QueryTag@[`, class... Args`]{.add}@>
>    >   concept @_`has-query`_@ =                   // exposition only
>    >     requires (const Env& env@[`, Args&&... args`]{.add}@) {
>    >       env.query(QueryTag()@[`, std::forward<Args>(args)...`]{.add}@);
>    >     };
>    > ```
>
> 6. Let _`fe`_ be the first element of ```@_envs_~0~@, @_envs_~1~@, @&hellip;@ @_envs_~_n_-1~@```{.cpp}
>    such that the expression ```@_`fe`_@.query(q@[`, std::forward<Args>(args)...`]{.add}@)```{.cpp}
>    is well-formed.
>
> 7. _Constraints_: ```(@_`has-query`_@<Envs, QueryTag@[`, Args...`]{.add}@> || ...)```{.cpp} is `true`{.cpp}.
>
> 8. _Effects_: Equivalent to: ```return @_`fe`_@.query(q@[`, std::forward<Args>(args)...`]{.add}@);```{.cpp}
>
> 9. _Remarks_: The expression in the `noexcept`{.cpp} clause is equivalent to
>    ```noexcept(@_`fe`_@.query(q@[`, std::forward<Args>(args)...`]{.add}@))```{.cpp}.


[In [exec.run.loop.types]{.sref}, add a new paragraph after paragraph 4 as follows:]{.ednote}

> 4. Let _`sch`_ be an expression of type _`run-loop-scheduler`_. The expression
>    `schedule(sch)`{.cpp} has type _`run-loop-sender`_ and is not potentially-throwing if
>    _`sch`_ is not potentially-throwing.
>
> ::: add
>
> 5. For type _`set-tag`_ other than `set_error_t`, the expression
>    ```get_completion_scheduler<@_`set-tag`_@>(get_env(schedule(@_`sch`_@))) == @_`sch`_@```{.cpp}
>    evaluates to `true`.
>
> :::


[Change [exec.affine.on]{.sref} paragraphs 3 and 4 as follows:]{.ednote}

> 3. Otherwise, the expression `affine_on(sndr, sch)`{.cpp} is expression-equivalent
>    to[:]{.rm} [```@_`make-sender`_@(affine_on, sch, sndr)```{.cpp}.]{.add}
>
>    ::: rm
>
>    > ```cpp
>    > transform_sender(@_`get-domain-early`_@(sndr), @_`make-sender`_@(affine_on, sch, sndr))
>    > ```
>
>    except that `sndr` is evaluated only once.
>
>    :::
>
> ::: rm
>
> 4. The exposition-only class template _`impls-for`_ ([exec.snd.expos]{.sref}) is
>    specialized for `affine_on_t` as follows:
>
>    > ```cpp
>    > namespace std::execution {
>    >   template<>
>    >   struct @_`impls-for`_@<affine_on_t> : @_`default-impls`_@ {
>    >     static constexpr auto @_`get-attrs`_@ =
>    >       [](const auto& data, const auto& child) noexcept -> decltype(auto) {
>    >         return @_`JOIN-ENV`_@(@_`SCHED-ATTRS`_@(data), @_`FWD-ENV`_@(get_env(child)));
>    >       };
>    >   };
>    > }
>    > ```
>
> :::

[Change [exec.inline.scheduler]{.sref} paragraphs 1-3 as follows:]{.ednote}


> 1. `inline_scheduler` is a class that models `scheduler` ([exec.sched]{.sref}). All
>    objects of type `inline_scheduler` are equal. [For a subexpression `sch` of type
>    `inline_scheduler`, a query object `q`, and a pack of subexpressions `as`, the
>    expression `sch.query(q, as...)` is expression-equivalent to
>    ```@_`inline-attrs`_@<set_value_t>().query(q, as...)```.]{.add}
>
> 2. _`inline-sender`_ is an exposition-only type that satisfies `sender`. The type
>    ```completion_signatures_of_t<@_`inline-sender`_@>``` is
>    `completion_signatures<set_value_t()>`.
>
> 3. Let `sndr` be an expression of type _`inline-sender`_, let `rcvr` be an expression such that
>    `receiver_of<decltype((rcvr)), CS>` is `true` where `CS` is
>    `completion_signatures<set_value_t()>`, then:
>
>    - [3.1]{.pnum} the expression `connect(sndr, rcvr)` has type
>      ```@_`inline-state`_@<remove_cvref_t<decltype((rcvr))>>``` and is potentially-throwing if and only
>      if `((void)sndr, auto(rcvr))` is potentially-throwing, and
>
>    ::: rm
>
>    - [3.2]{.pnum} the expression
>      ```get_completion_scheduler<set_value_t>(get_env(sndr))``` has
>      type​ `inline_scheduler` and
>      is potentially-throwing if and only if `get_env(sndr)` is
>      potentially-throwing.
>
>    :::
>
>    [For reference:
>    [cplusplus/sender-receiver#349](https://github.com/cplusplus/sender-receiver/issues/349)]{.ednote}


# Appendix A: Listing for updated `transform_sender`

The proposal requires some changes to how `transform_sender` operates. This new
`transform_sender` still accepts a sender and an environment like the current one, but it
no longer accepts a domain. It computes the two domains, starting and completing, and
applies the two transforms, recursing if a transform changes the type of the sender.

The implementation of `transform_sender` might look something like this:

> ```cpp
> template<class A, class B>
> concept @_`same-decayed`_@ = std::same_as<std::decay_t<A>, std::decay_t<B>>;
>
> template<class Domain, class Tag>
> struct @_`transform-sender-recurse`_@
> {
>   template<class Sndr, class Env>
>   using @_`result-t`_@ =
>     decltype(Domain().transform_sender(Tag(), declval<Sndr>(), declval<const Env&>()));
>
>   constexpr @_`transform-sender-recurse`_@(Domain, Tag) noexcept {}
>
>   template<class Sndr, class Env>
>   decltype(auto) operator()(this auto self, Sndr&& sndr, const Env& env)
>   {
>     if constexpr (!requires { typename @_`result-t`_@<Sndr, Env>; })
>     {
>       // Domain does not have a transform_sender for this sndr so use default_domain instead.
>       return @_`transform-sender-recurse`_@<default_domain, Tag>()(forward<Sndr>(sndr), env);
>     }
>     else if constexpr (@_`same-decayed`_@<Sndr, @_`result-t`_@<Sndr, Env>>)
>     {
>       // Domain can transform the sender but its type does not change. End recursion.
>       return Domain().transform_sender(Tag(), std::forward<Sndr>(sndr), env);
>     }
>     else if constexpr (same_as<Tag, start_t>)
>     {
>       // The starting domain cannot change, so recurse on Domain
>       return self(Domain().transform_sender(start, std::forward<Sndr>(sndr), env), env);
>     }
>     else
>     {
>       // The type of sndr changed after being transformed, so the type of the completion
>       // domain could change too. Recurse on the (possibly) new domain:
>       using attrs_t  = env_of_t<@_`result-t`_@<Sndr, Env>>;
>       using domain_t = decltype(get_completion_domain<>(declval<attrs_t>(), env));
>
>       return @_`transform-sender-recurse`_@<domain_t, Tag>()(
>         Domain().transform_sender(set_value, std::forward<Sndr>(sndr), env), env);
>     }
>   }
> };
>
> template<class Sndr, class Env>
> auto transform_sender(Sndr&& sndr, const Env& env)
> {
>   auto starting_domain    = get_domain(env);
>   auto complete_domain    = get_completion_domain<>(get_env(sndr), env);
>
>   auto starting_transform = @_`transform-sender-recurse`_@(starting_domain, start);
>   auto complete_transform = @_`transform-sender-recurse`_@(complete_domain, set_value);
>
>   return starting_transform(complete_transform(std::forward<Sndr>(sndr), env), env);
> }
> ```

With this definition of `transform_sender`, `connect(sndr, rcvr)` is equivalent to
`transform_sender(sndr, get_env(rcvr)).connect(rcvr)`, except that `rcvr` is evaluated
only once.




<!-- -->
