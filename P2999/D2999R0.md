---
title: "Sender Algorithm Customization"
subtitle: "Draft Proposal"
document: D2999R0
date: today
audience:
  - "LEWG Library Evolution"
author:
  - name: Eric Niebler
    email: <eric.niebler@gmail.com>
toc: true
---

Introduction
============

This paper proposes some design changes to P2300 to address some shortcomings in
how algorithm customizations are found.

The Issues
==========

Completion schedulers are unreliable
------------------------------------

In [@P2300R7], the sender algorithms (`then`, `let_value`, etc) are
customization point objects that internally dispatch via `tag_invoke` to the
correct algorithm implementation. Each algorithm has a default implementation
that is used if no custom implementation is found.

Custom implementations of sender algorithms are found by asking the input sender
for its completion scheduler and using the scheduler as a tag for the purpose of
tag dispatching. A _completion scheduler_ is a scheduler that refers to the
execution context on which that sender will complete.

A typical sender algorithm like `then` might be implemented as follows:

```cpp
/// @brief A helper concept for testing whether an algorithm customization
///   exists
template <class AlgoTag, class SetTag, class Sender, class... Args>
concept @_has-customization_@ =
  requires (Sender sndr, Args... args) {
    tag_invoke(AlgoTag(),
               get_completion_scheduler<SetTag>(get_env(sndr)),
               std::forward<Sender>(sndr),
               std::forward<Args>(args)...);
  };

/// @brief The tag type and the customization point object type for the
///   `then` sender algorithm
struct then_t {
  template <sender Sender, class Fun>
    requires /* requirements here */
  auto operator()(Sender&& sndr, Fun fun) const
  {
    // If the input sender has a completion scheduler, and if we can use
    // the completion scheduler to find a custom implementation for the
    // `then` algorithm, dispatch to that. Otherwise, dispatch to the
    // default `then` implementation.
    if constexpr (@_has-customization_@<then_t, set_value_t, Sender, Fun>)
    {
      auto&& env = get_env(sndr);
      return tag_invoke(*this,
                        get_completion_scheduler<set_value_t>(env),
                        std::forward<Sender>(sndr),
                        std::move(fun));
    }
    else
    {
      return @_default-then-implementation_@(std::forward<Sender>(sndr), std::move(fun));
    }
  }
};

inline constexpr then_t then {};
```

This scheme has a number of shortcomings:

1. A simple sender like `just(42)` does not know its completion scheduler. It
   completes on the execution context on which it is started. That is not known
   at the time the sender is constructed, which is when we are looking for
   customizations.

2. For a sender like `on( sched, then(just(), fun) )`, the `then` sender is
   constructed independent of the scheduler passed to `on`. But the `then`
   sender will be executing on that scheduler's (`sched`'s) execution context,
   so it should dispatch to `sched`'s customization of `then`. But how?

3. A composite sender like `when_all(sndr1, sndr2)` cannot know its completion
   scheduler in the general case. Even if `sndr1` and `sndr2` both know their
   completion schedulers -- say, `sched1` and `sched2` respectively -- the
   `when_all` sender can complete on _either_ `sched1` _or_ `sched2` depending
   on which of `sndr1` and `sndr2` completes last. That is a dynamic property of
   the program's execution, not suitable for finding an algorithm customization.

In cases (1) and (2), the issue is that the information necessary to find the
correct algorithm implementation is not available at the time we look for
customizations. In case (3), the issue is that the algorithm semantics make it
impossible to know statically to what algorithm customization scheme to dispatch.


> *Note:* On the need for async algorithms customization
>
> It is worth asking why async algorithms need customization at all. After all,
> the classic STL algorithms need no customization; they dispatch using a fixed
> concept hierarchy to a closed set of possible implementations.
>
> The reason is because of the open and continually evolving nature of execution
> contexts. There is little hope of capturing every salient attribute of every
> interesting execution model -- CPUs, GPUs, FPGAs, etc., past, present, and
> future -- in a fixed ontology around which we can build named concepts and
> immutable basis operations. Instead we do the best we can and then hedge
> against the future by making the algorithms customizable.

Execution context transitions are not scoped
--------------------------------------------

blah blah

Proposed Design
===============

Description
-------

This section describes at a high level the salient features of the proposed
design for sender algorithm customization.

### Dispatching via domain tags

As described above, the `when_all` sender doesn't know its completion scheduler,
so we cannot use the completion scheduler to find the `when_all` customization.
Instead, we can use an abstract tag type -- a so-called _domain_ -- to dispatch
to the correct customizations. As long as `when_all`'s child senders all share a
domain, we can know what set of algorithm customizations to use.

This paper proposes the addition of a forwarding `get_domain` query, and that
the domain is used together with the algorithm tag to dispatch to the correct
algorithm implementation.

Additionally, we proposed that the `when_all` algorithm only accepts a set of
senders when they all share a common domain.

### Late (sender/receiver connection-time) customization

As described above, the sender algorithm customization points don't have all the
information they need to dispatch to the correct algorithm implementation in all
cases. The solution is to look again for a customization when all the information
is available. That happens when the sender is `connect`-ed to a receiver.

This paper proposes the addition of a `transform_sender` customization point
that is called by the `connect` customization point to transform a sender prior
to connecting it with the receiver. _In this sense, it is precisely analagous to
the [`await_transform`](https://eel.is/c++draft/expr.await#3.2) customization
used by coroutines to transform an expression prior to `co_await`-ing it._

### Early (sender construction-time) customization

We can use `transform_sender` for early customization as well as late. The
benefit of doing this is that only one set of customizations needs be written
for each domain, rather than two (early and late).

This paper proposes that each algorithm constructs a default sender that
implements the default behavior for that algorithm and then passes that sender
to `transform_sender` along with the sender's domain. The result of
`transform_sender` is what the algorithm returns.

### Decomposable senders

For the `transform_sender` customization point to be useful, we need a way to
access the constituent pieces of a sender and re-assemble it from (possibly
transformed) pieces. Senders, like coroutines, generally begin in a "suspended"
state; they merely curry their algorithm's arguments into a subsequent call to
`connect`. These "suspended" senders are colloquially known as _lazy_ senders.

Each lazy sender has an associated algorithm tag, a (possibly empty) set of
auxiliary data and a (possibly empty) set of child senders; _e.g._, the sender
returned from `then(snd, fun)` has `then_t` as its tag, the set `[fun]` as its
auxiliary data, and `[snd]` as its set of child senders, while `just(42, 3.14)`
has `just_t` as its tag, `[42, 3.14]` as its data set and `[]` as its child set.

This paper proposes to use structured bindings as the API for decomposing a lazy
sender into its tag, data, and child senders:

```cpp
auto&& [tag, data, ...children] = sndr;
```

[@P1061R5], currently in Core wording review for C++26, permits the declaration
of variadic structured bindings like above, making this syntax very appealing.

Not all senders are required to be decomposable, although all the "standard"
lazy senders shall be. There needs to be a syntactic way to distinguish between
decomposable and non-decomposable senders (decomposable senders subsuming the
`sender` concept).

There is currently no trait for determining whether a type can be the
initializer of a structured binding. However, EWG has already approved
[@P2141R1] for C++26, and with it such a trait could be built, giving us a
simple way to distinguish between decomposable and non-decomposable senders.

If P2141 is not adopted for C++26, we will need some other syntactic way to
opt-in. One possibility is to require that the sender type's nested `is_sender`
type shall have some known, standard tag type as a base class to signify that
that sender type can be decomposed.

### Re-composable senders

After decomposing a sender, it is often desirable to re-compose them from
modified subcomponents.

TODO...


Implementation Experience
=========================

_Has it been implented?_ YES. The design changes herein proposed are implemented
in the main branch of [@stdexecgithub], the reference implementation. The bulk
of the changes including `get_domain`, `transform_sender`, and `make_sender`
have been shipping since [this
commit](https://github.com/NVIDIA/stdexec/commit/0693876c6144479ab5d9bec671751bd32d14e23a)
on August 3, 2023 which changed the `static_thread_pool` scheduler to use
`transform_sender` to parallelize the `bulk` algorithm.

Proposed Wording
================

TODO



---
references:
  - id: stdexecgithub
    citation-label: stdexecgithub
    title: "stdexec"
    url: https://github.com/NVIDIA/stdexec
  - id: P2300R7
    citation-label: P2300R7
    type: paper
    title: "`std::execution`"
    author:
      - given: Micha≈Ç 
        family: Dominiak
        email:  griwes@griwes.info
      - given: Georgy 
        family: Evtushenko
        email:  evtushenko.georgy@gmail.com
      - given: Lewis 
        family: Baker
        email:  lewissbaker@gmail.com
      - given: Lucian Radu
        family: Teodorescu
        email: lucteo@lucteo.ro
      - given: Lee 
        family: Howes
        email:  xrikcus@gmail.com
      - given: Kirk 
        family: Shoop
        email:  kirk.shoop@gmail.com
      - given: Michael 
        family: Garland
        email:  mgarland@nvidia.com
      - given: Eric 
        family: Niebler
        email:  eric.niebler@gmail.com
      - given: Bryce Adelstein
        family: Lelbach
        email: brycelelbach@gmail.com
    url: https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2300r7.html
---
