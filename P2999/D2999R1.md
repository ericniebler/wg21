---
title: "Sender Algorithm Customization"
subtitle: "Draft Proposal"
document: D2999R1
date: today
audience:
  - "LEWG Library Evolution"
author:
  - name: Eric Niebler
    email: <eric.niebler@gmail.com>
toc: true
---

Introduction
============

This paper proposes some design changes to P2300 to address some shortcomings in
how algorithm customizations are found.

The Issue
=========

The essence of the issue is this:

:  _Many senders do not know on what execution context they will complete, so
   using solely that information to find customizations (as P2300R7 does) is
   unsatisfactory._

In [@P2300R7], the sender algorithms (`then`, `let_value`, etc) are
customization point objects that internally dispatch via `tag_invoke` to the
correct algorithm implementation. Each algorithm has a default implementation
that is used if no custom implementation is found.

Custom implementations of sender algorithms are found by asking the predecessor
sender for its completion scheduler and using the scheduler as a tag for the
purpose of tag dispatching. A _completion scheduler_ is a scheduler that refers
to the execution context on which that sender will complete.

A typical sender algorithm like `then` might be implemented as follows:

```cpp
/// @brief A helper concept for testing whether an algorithm customization
///   exists
template <class AlgoTag, class SetTag, class Sender, class... Args>
concept @_has-customization_@ =
  requires (Sender sndr, Args... args) {
    tag_invoke(AlgoTag(),
               get_completion_scheduler<SetTag>(get_env(sndr)),
               std::forward<Sender>(sndr),
               std::forward<Args>(args)...);
  };

/// @brief The tag type and the customization point object type for the
///   `then` sender algorithm
struct then_t {
  template <sender Sender, class Fun>
    requires /* requirements here */
  auto operator()(Sender&& sndr, Fun fun) const
  {
    // If the predecessor sender has a completion scheduler, and if we can use
    // the completion scheduler to find a custom implementation for the `then`
    // algorithm, dispatch to that. Otherwise, dispatch to the default `then`
    // implementation.
    if constexpr (@_has-customization_@<then_t, set_value_t, Sender, Fun>)
    {
      auto&& env = get_env(sndr);
      return tag_invoke(*this,
                        get_completion_scheduler<set_value_t>(env),
                        std::forward<Sender>(sndr),
                        std::move(fun));
    }
    else
    {
      return @_then-sender_@<Sender, Fun>(std::forward<Sender>(sndr), std::move(fun));
    }
  }
};

inline constexpr then_t then {};
```

This scheme has a number of shortcomings:

1. A simple sender like `just(42)` does not know its completion scheduler. It
   completes on the execution context on which it is started. That is not known
   at the time the sender is constructed, which is when we are looking for
   customizations.

2. For a sender like `on( sched, then(just(), fun) )`, the nested `then` sender is
   constructed before we have specified the scheduler, but we need the scheduler
   to dispatch to the correct customization of `then`. How?

3. A composite sender like `when_all(sndr1, sndr2)` cannot know its completion
   scheduler in the general case. Even if `sndr1` and `sndr2` both know their
   completion schedulers -- say, `sched1` and `sched2` respectively -- the
   `when_all` sender can complete on _either_ `sched1` _or_ `sched2` depending
   on which of `sndr1` and `sndr2` completes last. That is a dynamic property of
   the program's execution, not suitable for finding an algorithm customization.

In cases (1) and (2), the issue is that the information necessary to find the
correct algorithm implementation is not available at the time we look for
customizations. In case (3), the issue is that the algorithm semantics make it
impossible to know statically to what algorithm customization scheme to dispatch.

The issue described in (2) above is particularly pernicious. Consider these two
programs (where `ex::` is a namespace alias for `std::execution`); the
differences are highlighted:

::: cmptable

### Good
```cpp
my::thread_pool_scheduler sch = /*...*/;

// Describe some bulk work on a thread pool
auto work =
  @<mark>ex::transfer_just(sch, data)</mark>@
| ex::bulk(data.size(),
           [](int i, auto& data) {
             ++data[i];
           });

// Execute the work
std::this_thread::sync_wait(@<mark>std::move(work)</mark>@);
```

### Bad
```cpp
my::thread_pool_scheduler sch = /*...*/;

// Describe some bulk work
auto work =
  @<mark>ex::just(data)</mark>@
| ex::bulk(data.size(),
           [](int i, auto& data) {
             ++data[i];
           });

// Execute the bulk work on a thread pool
std::this_thread::sync_wait(@<mark>ex::on(sch, std::move(work))</mark>@);
```

:::

These two programs _should_ be equivalent, but they are not. The author
of the `thread_pool_scheduler` gave it a custom `bulk` implementation
by defining:

```cpp
namespace my {
  // customization of the bulk algorithm for the thread_pool_scheduler:
  template <ex::sender Sender, std::integral Shape, class Function>
  auto tag_invoke(ex::bulk_t,
                  thread_pool_scheduler sched,
                  Sender&& sndr,
                  Shape shape,
                  Function fun) {
    /*
     * Do bulk work in parallel
     * ...
     */
  }
}
```

This overload is found only when the `bulk` sender's predecessor completes on a
`thread_pool_scheduler`, which is the case for the code on the left.

In the code to the right, however, the predecessor of the `bulk` operation is
`just(data)`, a sender that does not know where it will complete. As a result,
the above customization of the `bulk` algorithm will not be found, and the bulk
operation will execute serially on a single thread in the thread pool. That's
almost certainly _not_ what the programmer intended.

This is clearly broken and badly in need of fixing.

> *Note:* On the need for async algorithms customization
>
> It is worth asking why async algorithms need customization at all. After all,
> the classic STL algorithms need no customization; they dispatch using a fixed
> concept hierarchy to a closed set of possible implementations.
>
> The reason is because of the open and continually evolving nature of execution
> contexts. There is little hope of capturing every salient attribute of every
> interesting execution model -- CPUs, GPUs, FPGAs, etc., past, present, and
> future -- in a fixed ontology around which we can build named concepts and
> immutable basis operations. Instead we do the best we can and then hedge
> against the future by making the algorithms customizable.

Proposed Design
===============

Features and rationale
-------

This section describes at a high level the salient features of the proposed
design for sender algorithm customization, and their rationale.

### Dispatching via domain tags

As described above, the `when_all` sender doesn't know its completion scheduler,
so we cannot use the completion scheduler to find the `when_all` customization.
Instead, we can use an abstract tag type -- a so-called _domain_ -- to dispatch
to the correct customizations. As long as `when_all`'s child senders all share a
domain, we can know what set of algorithm customizations to use.

This paper proposes the addition of a forwarding `get_domain` query, and that
the domain is used together with the algorithm tag to dispatch to the correct
algorithm implementation.

Additionally, we proposed that the `when_all` algorithm only accepts a set of
senders when they all share a common domain. Likewise for `let_value` and
`let_error`, we require that there is only one possible domain on which their
senders may complete.

### Late (sender/receiver connection-time) customization

As described above, the sender algorithm customization points don't have all the
information they need to dispatch to the correct algorithm implementation in all
cases. The solution is to look again for a customization when all the information
is available. That happens when the sender is `connect`-ed to a receiver.

This paper proposes the addition of a `transform_sender` customization point
that is called by the `connect` customization point to transform a sender prior
to connecting it with the receiver. The correct sender transformation is found
using a property read from the receiver's environment.

_The use of `transform_sender` in `connect` it is precisely analagous to the use
of [`await_transform`](https://eel.is/c++draft/expr.await#3.2) in `co_await`_,
and the addition of `transform_sender` closes a functionality gap between
senders and awaitables.

### Early (sender construction-time) customization

We can use `transform_sender` for early customization as well as late. The
benefit of doing this is that only one set of customizations needs be written
for each domain, rather than two (early and late).

This paper proposes that each algorithm constructs a default sender that
implements the default behavior for that algorithm. It then passes that sender
to `transform_sender` along with the sender's domain. The result of
`transform_sender` is what the algorithm returns.

Some algorithms are required to do work eagerly in their default implementation
(_e.g._, `split`, `ensure_started`). These algorithms must first create a dummy
sender to pass to `transform_sender`. The "default" domain, which is used when
no other domain has been specified, can transform these dummy senders and do
their eager work in the process. The same mechanism is also useful to implement
customizable sender algorithms whose default implementation merely lowers to a
more primitive expression (_e.g._ `transfer(s,sch)` becomes
`schedule_from(sch,s)`, and `transfer_just(sch, ts...)` becomes `just(ts...) |
transfer(sch)`).

To permit third parties to author customizable sender algorithms that do eager
work in their default implementations, the mechanism by which the default domain
finds the default sender transformations shall be specified.

### Decomposable senders

For the `transform_sender` customization point to be useful, we need a way to
access the constituent pieces of a sender and re-assemble it from (possibly
transformed) pieces. Senders, like coroutines, generally begin in a "suspended"
state; they merely curry their algorithm's arguments into a subsequent call to
`connect`. These "suspended" senders are colloquially known as _lazy_ senders.

Each lazy sender has an associated algorithm tag, a (possibly empty) set of
auxiliary data and a (possibly empty) set of child senders; _e.g._, the sender
returned from `then(snd, fun)` has `then_t` as its tag, the set `[fun]` as its
auxiliary data, and `[snd]` as its set of child senders, while `just(42, 3.14)`
has `just_t` as its tag, `[42, 3.14]` as its data set and `[]` as its child set.

This paper proposes to use structured bindings as the API for decomposing a lazy
sender into its tag, data, and child senders:

```cpp
auto&& [tag, data, ...children] = sndr;
```

[@P1061R5], currently in Core wording review for C++26, permits the declaration
of variadic structured bindings like above, making this syntax very appealing.

Not all senders are required to be decomposable, although all the "standard"
lazy senders shall be. There needs to be a syntactic way to distinguish between
decomposable and non-decomposable senders (decomposable senders subsuming the
`sender` concept).

There is currently no trait for determining whether a type can be the
initializer of a structured binding. However, EWG has already approved
[@P2141R1] for C++26, and with it such a trait could be built, giving us a
simple way to distinguish between decomposable and non-decomposable senders.

If P2141 is not adopted for C++26, we will need some other syntactic way to
opt-in. One possibility is to require that the sender type's nested `is_sender`
type shall have some known, standard tag type as a base class to signify that
that sender type can be decomposed.

> *Note:* After decomposing a sender, it is often desirable to re-compose it
> from its modified constituents. No separate API for reconstituting senders is
> necessary though. It is enough to construct a decomposable sender of some
> arbitrary type and then pass it to `transform_sender` with the appropriate
> domain tag.


Summary of proposed changes
---------------------------

In condensed form, here are the changes this paper is proposing:

#. Add a `default_domain` type for use when no other domain is determinable.

#. Add a new `get_domain(@_env_@) -> @_domain-tag_@` forwarding query.

#. Add a new, non-customizable
   `transform_sender(@_domain_@, @_sender_@ [, @_env_@]) -> @_sender_@` API. It
   will be used for both early customization (at sender construction-time) and
   late customization (at sender/receiver connection-time).

   *Early customization:*
      - called from within each sender algorithm's customization point object
      - replaces the current mechanism of tag-dispatching to
        a sender factory function using the completion scheduler as a tag
      - called without an environment argument
      - `@_domain_@` is derived from the sender by trying the following in order:
        1. `get_domain(get_env(@_sender_@))`
        2. `get_domain(get_completion_scheduler<@_completion-tag_@>(get_env(@_sender_@)))`,
           where `@_completion-tag_@` is one of `set_value_t`, `set_error_t`,
           or `set_stopped_t` depending on the algorithm
        3. `default_domain()`

    *Late customization:*
      - called from the `connect` customization point object before
        tag-dispatching with `connect_t` to `tag_invoke`
      - called with the receiver's environment
      - `@_domain_@` is derived from the receiver by trying the following in order:
        1. `get_domain(get_env(@_receiver_@))`
        2. `get_domain(get_scheduler(get_env(@_receiver_@)))`
        3. `default_domain()`

   `transform_sender(@_domain_@, @_sender_@ [, @_env_@])` returns the first of
   these that is well-formed:

    * `@_domain_@.transform_sender(@_sender_@ [, @_env_@])`
    * `default_domain().transform_sender(@_sender_@ [, @_env_@])`
    * `@_sender_@`

#. The standard, "lazy" sender types (i.e., those returned from sender factory
   and adaptor functions) return sender types that are decomposable using
   structured bindings into its [_tag_, _data_, ..._children_] components.

#. A call to the `when_all` algorithm should be ill-formed unless all of the
   sender arguments have the same domain type (as determined for senders above).
   The resulting `when_all` sender should publish that domain via the sender's
   environment.

#. The `on(sch, sndr)` algorithm should be specified in terms of `transfer` so
   as to pick up any late customization of the `transfer` algorithm. (This
   amounts to changing `schedule(sch)` to `transfer_just(sch)` in
   [exec.on]/3.2.2.). Additionally, it should replace the domain in the
   receiver's environment with the domain of `sch`.

#. The sender factories `just`, `just_error`, and `just_stopped` need their tag
   types to be specified. Name them `just_t`, `just_error_t`, and
   `just_stopped_t`.

#. In the algorithm `let_value(sndr, fun)`, if the predecessor sender `sndr` has
   a completion scheduler for `set_value`, then the receiver connected to the
   secondary sender (the one returned from `fun` when called with `sndr`'s
   results) shall expose that scheduler as the current scheduler of the
   receiver's environment.

   In other words, if the predecessor sender `sndr` completes with values
   `vs...`, then the result of `fun(vs...)` will be connected to a receiver `r`
   such that `get_scheduler(get_env(r))` is equal to
   `get_completion_scheduler<set_value_t>(get_env(sndr))`.

   The same is true also of the domain query: `get_domain(get_env(r))` is equal
   to the domain of the predecessor sender as computed by the steps in (2)
   above.

   So for `let_value`, likewise also for `let_error`, using `set_error_t` when
   querying for the predecessor sender's completion scheduler. (`let_stopped`
   needs no modification because the nullary function passed to `let_stopped`
   can only have a single return type; hence there is only one secondary sender
   type and one domain to consider.)

#. The `schedule_from(sched, sndr)` algorithm should return a sender `s` such
   that `get_domain(get_env(s))` is equal to `get_domain(sched)`.

#. The following customizable algorithms, whose default implementations must do
   work before returning the result sender, will have their work performed in
   overloads of `default_domain::transform_sender`:

    - `split`
    - `ensure_started`

#. The following customizable algorithms, whose default implementations are
   trivially expressed in terms of other more primitive operations, will be
   lowered into their primitive forms by overloads of
   `default_domain::transform_sender`:

    - `transfer`
    - `transfer_just`
    - `transfer_when_all`
    - `transfer_when_all_with_variant`
    - `when_all_with_variant`

#. In the algorithm `let_value(snd, fun)`, all of the sender types that the
   input function `fun` might return must all have the same domain; otherwise,
   the call to `let_value` is ill-formed. The resulting `let_value` sender will
   report that as its domain. Likewise for `let_error` and `let_stopped`.

#. Sender consuming algorithms `start_detached` and `sync_wait` will continue
   to dispatch to `tag_invoke` customizations using the algorithm tag and the
   input sender's domain as tags for the purpose of tag dispatching.

Implementation Experience
=========================

_Has it been implented?_ YES. The design changes herein proposed are implemented
in the main branch of [@stdexecgithub], the reference implementation. The bulk
of the changes including `get_domain`, `transform_sender`, and the changes to
`connect` have been shipping since [this
commit](https://github.com/NVIDIA/stdexec/commit/0693876c6144479ab5d9bec671751bd32d14e23a)
on August 3, 2023 which changed the `static_thread_pool` scheduler to use
`transform_sender` to parallelize the `bulk` algorithm.

Proposed Wording
================

The following proposed changes are relative to [@P2300R7].

[Change __§11.4 [exec.syn]__ as follows:]{.ednote}

```diff
  @_// [exec.queries], queries_@
  enum class forward_progress_guarantee;
  namespace @_queries_@ { @_// exposition only_@
    @[struct\ get_domain_t;]{.add}@
    struct get_scheduler_t;
    struct get_delegatee_scheduler_t;
    struct get_forward_progress_guarantee_t;
    template<class CPO>
      struct get_completion_scheduler_t;
  }

  @@[using @_queries_@::get_domain_t;]{.add}@@
  using @_queries_@::get_scheduler_t;
  using @_queries_@::get_delegatee_scheduler_t;
  using @_queries_@::get_forward_progress_guarantee_t;
  using @_queries_@::get_completion_scheduler_t;
  @[inline\ constexpr\ get_domain_t\ get_domain{};]{.add}@
  inline constexpr get_scheduler_t get_scheduler{};
  inline constexpr get_delegatee_scheduler_t get_delegatee_scheduler{};
  inline constexpr get_forward_progress_guarantee_t get_forward_progress_guarantee{};
  template<class CPO>
    inline constexpr get_completion_scheduler_t<CPO> get_completion_scheduler{};

  @@[@_//\ [exec.domain.default],\ domains_@]{.add}@@
  @[struct\ default_domain;]{.add}@
```

[... and ...]{.ednote}

```diff
  template<class S, class E = empty_env>
      requires sender_in<S, E>
    inline constexpr bool sends_stopped = @_see below_@;

  @[template\ <sender\ Sender>]{.add}@
    @@[using\ tag_of_t\ =\ @_see below_@;]{.add}@@

  @@[@_//\ [exec.transform_sender],\ sender\ transformations_@]{.add}@@
  @[template\ <class\ Domain,\ sender\ Sender,\ class\...\ Env>]{.add}@
      @[requires\ (sizeof\...(Env)\ <=\ 1)]{.add}@
    @[constexpr\ sender\ decltype(auto)\ transform_sender(Domain\ dom,\ Sender&&\ sndr,\ const\ Env&\...\ env);]{.add}@

  @_// [exec.connect], the connect sender algorithm_@
  namespace senders-connect { // exposition only
    struct connect_t;
  }
  using senders-connect::connect_t;
  inline constexpr connect_t connect{};
```

[... and ...]{.ednote}

```diff
  @_// [exec.factories], sender factories_@
  namespace @_senders-factories_@ { @_// exposition only_@
    @[struct\ just_t;]{.add}@
    @[struct\ just_error_t;]{.add}@
    @[struct\ just_stopped_t;]{.add}@
    struct schedule_t;
    struct transfer_just_t;
  }
  @@[using @_sender-factories_@::just_t;]{.add}@@
  @@[using @_sender-factories_@::just_error_t;]{.add}@@
  @@[using @_sender-factories_@::just_stopped_t;]{.add}@@
  @@inline constexpr [@_unspecified_@]{.rm}[just_t]{.add}\ just{};@@
  @@inline constexpr [@_unspecified_@]{.rm}[just_error_t]{.add}\ just_error{};@@
  @@inline constexpr [@_unspecified_@]{.rm}[just_stopped_t]{.add}\ just_stopped{};@@
```

[After __§11.5.4 [exec.get.stop.token]__, add the following new subsection:]{.ednote}

:::add
__§11.5.? `execution::get_domain` [exec.get.domain]__

1. `get_domain` asks an object for an associated domain tag.

2. The name `get_domain` denotes a query object. For some subexpression `r`,
   `get_domain(r)` is expression-equivalent to
   <code><i>mandate-nothrow-call</i>(tag_invoke,\ get_domain,\ as_const(r))</code>,
   if this expression is well-formed.

3. `std::forwarding_query(execution::get_domain)` is `true`.

4. `get_domain()` (with no arguments) is expression-equivalent to
    `execution::read(get_domain)` ([exec.read]).

:::

[To section __§11.9.1 [exec.snd.concepts]__, after paragraph 4, add two new
paragraphs as follows:]{.ednote}

:::add
5. Let `s` be an expression such that `decltype((s))` is `S`. The type
   `tag_of_t<S>` is as follows:

      - If the declaration `auto&& [tag, data, ...children] = s;` would be
        well-formed, `tag_of_t<S>` is an alias for `decltype(auto(tag))`.

      - Otherwise, `tag_of_t<S>` is ill-formed.

    [There is no way in standard C++ to determine whether the above declaration
    is well-formed without causing a hard error, so this presumes compiler
    magic. However, the author anticipates the adoption of [@P2141R1], which
    makes it possible to implement this purely in the library. P2141 has already
    been approved by EWG for C++26.]{.ednote}

6. Let `@_sender-for_@` be an exposition-only concept defined as follows:

   > ```
   > template <class Sender, class Tag>
   > concept @_sender-for_@ =
   >   sender<Sender> &&
   >   same_as<tag_of_t<Sender>, Tag>;
   > ```
:::


[After __§11.9.2 [exec.awaitables]__, add the following new subsections:]{.ednote}

:::add

__§11.9.? `execution::default_domain` [exec.domain.default]__

```
struct default_domain {
  template <sender Sender, class... Env>
      requires (sizeof...(Env) <= 1)
    static constexpr sender decltype(auto) transform_sender(Sender&& sndr, const Env&... env);
};
```

__§11.9.?.1 Static members [exec.domain.default.statics]__

```
template <sender Sender, class... Env>
    requires (sizeof...(Env) <= 1)
  constexpr sender decltype(auto) default_domain::transform_sender(Sender&& sndr, const Env&... env);
```

_Returns:_ `tag_of_t<Sender>().transform_sender(std::forward<Sender>(sndr), env...)`
      if that expression is well-formed; otherwise, `std::forward<Sender>(sndr)`.

__§11.9.? `execution::transform_sender` [exec.snd.transform]__

```
template <class Domain, sender Sender, class... Env>
    requires (sizeof...(Env) <= 1)
  constexpr sender decltype(auto) transform_sender(Domain dom, Sender&& sndr, const Env&... env);
```

_Returns:_ `dom.transform_sender(std::forward<Sender>(sndr), env...)` if that
      expression is well-formed; otherwise,
      `default_domain().transform_sender(std::forward<Sender>(sndr), env...)`.
:::


[Add a paragraph to __§11.9 [exec.snd]__]{.ednote}

:::add

1. This section makes use of the following exposition-only entities.

    1.  ```
        template <class Tag, class Env, class Default>
        constexpr decltype(auto) @_query-with-default_@(Tag, const Env& env, Default&& value) noexcept(@_see below_@);

        ```

        _Effects:_ Equivalent to:

          --- `return Tag()(env);` if that expression is well-formed,

          --- `return static_cast<Default>(std::forward<Default>(value));` otherwise.

        _Remarks:_ The expression in the `noexcept` clause is:

          > ```
          > is_invocable_v<Tag, const Env&> ? is_nothrow_invocable_v<Tag, const Env&>
          >                                 : is_nothrow_constructible_v<Default, Default>
          > ```

    2.  ```
        template <class Env, class Tag = get_scheduler_t>
        constexpr auto @_get-env-domain_@(const Env& env, Tag tag = {}) noexcept;

        ```

        _Effects:_ Equivalent to:

          --- `return get_domain(env);` if that expression is well-formed,

          --- otherwise, `return get_domain(tag(env));` if that expression is
            well-formed,

          --- otherwise, `return default_domain();`.

    3.  ```
        template <class Sender, class Tag = set_value_t>
        constexpr auto @_get-sender-domain_@(const Sender& sndr, Tag = {}) noexcept;

        ```

        _Effects:_ Equivalent to: `return @_get-env-domain_@(get_env(sndr), get_completion_scheduler<Tag>);`.

    4.  ```
        template <class... T>
        struct @_tuple-like_@ {
          T@<sub>0</sub>@ @_t_<sub>0</sub>@;      // exposition only
          T@<sub>1</sub>@ @_t_<sub>1</sub>@;      // exposition only
            ...
          T@<sub>n-1</sub>@ @_t_<sub>n-1</sub>@;   // exposition only
        };

        ```

        --- [An expression of type `@_tuple-like_@` is usable as the initializer
            of a structured binding declaration [dcl.struct.bind].]{.note}

    5.  ```
        template <semiregular Tag, @_movable-value_@ Data, sender... Child>
        constexpr auto @_make-sender_@(Tag, Data&& data, Child&&... child);

        ```

        _Returns:_ A prvalue of type `@_basic-sender_@<Tag, decay_t<Data>, decay_t<Child>...>`
            where the _`tag`_ member has been default-initialized and the
            _`data`_ and `@_child_<sub>n</sub>@...` members have
            been direct initialized from their respective forwarded arguments, where
            _`basic-sender`_ is the following exposition-only class template
            except as noted below:

        > ```
        > template <class Tag, class Data, class... Child> // arguments are not associated entities ([lib.tmpl-heads])
        > struct @_basic-sender_@ : @_unspecified_@ {
        >   using is_sender = @_unspecified_@;
        >
        >   [[no_unique_address]] Tag @_tag_@;  // exposition only
        >   Data @_data_@;          // exposition only
        >   Child@<sub>0</sub>@ @_child_<sub>0</sub>@;      // exposition only
        >   Child@<sub>1</sub>@ @_child_<sub>1</sub>@;      // exposition only
        >     ...
        >   Child@<sub>n-1</sub>@ @_child_<sub>n-1</sub>@;   // exposition only
        > };
        >
        > ```

        --- It is unspecified whether instances of _`basic-sender`_ can be
            aggregate initialized.

        --- [An expression of type `@_basic-sender_@` is usable as the
            initializer of a structured binding declaration
            [dcl.struct.bind].]{.note}

:::


[To __§11.9.5.2 [exec.just]__, add a paragraph 6 as follows:]{.ednote}

:::add
6. When used as the initializer of a structured binding declaration,
    expressions of type `@_just-sender_@<Tag, Ts...>` behave as do
    expressions of type `@_basic-sender_@<Tag, @_tuple-like_@<Ts...>>`.

:::


[Change __§11.9.5.3 [exec.transfer.just]__ as follows
(some identifiers in this section have had their names changed for the sake of
clarity; the name changes have not been marked up):]{.ednote}

2. The name `transfer_just` denotes a customization point object. For some
    subexpression `sch` and pack of subexpressions `vs`, let `Sch` be
    `decltype((sch))` and let `Vs` be the template parameter pack
    `decltype((vs))...`. If `Sch` does not satisfy `scheduler`, or any type `V` in
    `Vs` does not satisfy _`movable-value`_,
    `transfer_just(sch, vs...)` is ill-formed. Otherwise, `transfer_just(sch, vs...)`
    is expression-equivalent to:

    > <div class="add" style="color: #006e28">
    > ```
    > transform_sender(
    >   @_query-or-default_@(get_domain, sch, default_domain()),
    >   @_make-sender_@(transfer_just, @_tuple-like_@{sch, vs...}));
    > ```
    > </div>

    1. [`tag_invoke(transfer_just, sch, vs...)`, if that expression is valid.]{.rm}

3. Let `as` be a pack of rvalue subexpressions of types `decay_t<Vs>...`
    refering to objects direct-initilized from `vs`. If [the function
    selected by `tag_invoke`]{.rm}[a sender `S` returned from `transfer_just(sch, vs...)`
    is connected with a receiver `R` with environment `E` such that
    `transform_sender(@_get-env-domain_@(E), S, E)`]{.add}
    does not return a sender whose asynchronous
    operations execute value completion operations on an execution agent
    belonging to the execution resource associated with `sch`, with value result
    datums `as`, the behavior of calling [`transfer_just(sch, vs...)`]{.rm}
    [`connect(S, R)`]{.add} is undefined.

    * _Mandates:_ `sender_of<@[R]{.rm}[S]{.add}@, set_value_t(decay_t<Vs>...), E>`,
        where `@[R]{.rm}[S]{.add}@` is the type of [the `tag_invoke` expression above]{.rm}
        [`transfer_just(sch, vs...)`]{.add}, and `E` is the type of an environment.

:::rm
  > 2. Otherwise, `transfer(just(vs...), sch)`.
:::

:::add
4. For some subexpression `sch` and pack of subexpressions `vs`, let `s` be a
    subexpression refering to an object returned from `transform_just(sch, vs...)`
    or a copy of such. Then
    `get_completion_scheduler<set_value_t>(get_env(s)) == sch` is `true`,
    `get_completion_scheduler<set_stopped_t>(get_env(s)) == sch` is `true`, and
    `get_domain(get_env(s))` is expression-equivalent to `get_domain(sch)`.

5. Let `s` and `e` be subexpressions such that `S` is `decltype((s))`. If
    `@_sender-for_@<S, transfer_just_t>` is `false`, then the expression
    `transfer_just_t().transform_sender(s, e)` is ill-formed; otherwise, it
    is equal to:

    > ```
    > const auto& env = e;
    > auto domain = @_get-env-domain_@(env);
    > auto [tag, data] = s;
    > auto& [sched, ...vs] = data;
    > auto tmp = execution::transform_sender(domain, just(std::move(vs)...), env);
    > return execution::transform_sender(domain, transfer(std::move(tmp), std::move(sched)), env);
    > ```

    [This causes the `transform_just(sch, vs...)` sender to become
    `transform(just(vs...), sch)` when it is connected with a receiver whose
    domain does not customize `transform_just`.]{.note}

:::

[Update __§11.9.6.3 [exec.on]__ as follows:]{.ednote}


1. `on` adapts an input sender into a sender that will start on an execution
    agent belonging to a particular scheduler's associated execution resource.

2. Let `@_replace-scheduler_@(e, sch)` be an expression denoting an object `e'`
    such that `get_scheduler(e@[\']{.add}@)` returns a copy of `sch`,
    [`get_domain(e')` is expression-equivalent to `get_domain(sch)`,]{.add} and
    `tag_invoke(tag, e', args...)` is expression-equivalent to `tag(e, args...)`
    for all arguments `args...` and for all `tag` whose type satisfies
    `@_forwarding-query_@` and is not `get_scheduler_t` [or
    `get_domain_t`]{.add}.

3. The name `on` denotes a customization point object. For some subexpressions
    `sch` and `s`, let `Sch` be `decltype((sch))` and `S` be `decltype((s))`. If
    `Sch` does not satisfy `scheduler`, or `S` does not satisfy `sender`,
    `on@[(sch, s)]{.add}@` is ill-formed. Otherwise, the expression `on(sch, s)`
    is expression-equivalent to:

    > <div class="add" style="color: #006e28">
    > ```
    > transform_sender(
    >   @_query-or-default_@(get_domain, sch, default_domain()),
    >   @_make-sender_@(on, sch, s));
    > ```
    > </div>

    1. [`tag_invoke(on, sch, s)`, if that expression is valid. If the function
        selected above]{.rm}[If a sender `S` returned from `on(sch, s)` is
        connected with a receiver `R` with environment `E` such that
        `transform_sender(@_get-env-domain_@(E), S, E)`]{.add} does not return a
        sender which starts `s` on an execution agent of the associated
        execution resource of `sch` when started, the behavior of calling
        [`on(sch, s)`]{.rm}[`connect(S, R)`]{.add} is undefined.

        * [_Mandates:_ The type of the `tag_invoke` expression above satisfies
            `sender`.]{.rm}

5. [Let `s` and `e` be subexpressions such that `S` is `decltype((s))`. If
    `@_sender-for_@<S, on_t>` is `false`, then the expression
    `on_t().transform_sender(s, e)` is ill-formed; otherwise, it returns]{.add}
    [Otherwise, constructs]{.rm} a sender `s1` [. When]{.rm}[such that
    when]{.add} `s1` is connected with some receiver `out_r`, it:

    1. Constructs a receiver `r` such that:

        1. When `set_value(r)` is called, it calls `connect(s, r2)`, where `r2`
           is as specified below, which results in `op_state3`. It calls
           `start(op_state3)`. If any of these throws an exception, it calls
           `set_error` on `out_r`, passing `current_exception()` as the second
           argument.

        2. `set_error(r, e)` is expression-equivalent to `set_error(out_r, e)`.

        3. `set_stopped(r)` is expression-equivalent to `set_stopped(out_r)`.

        4. `get_env(r)` is expression-equivalent to `get_env(out_r)`.

    2. Calls [`schedule(sch)`]{.rm}[`transfer_just(sch)`]{.add}, which
        results in `s2`. It then calls `connect(s2, r)`, resulting in
        `op_state2`.

    3. `op_state2` is wrapped by a new operation state, `op_state1`, that is
       returned to the caller.

    4. `r2` is a receiver that wraps a reference to `out_r` and forwards all
        completion operations to it. In addition, `get_env(r2)` returns
        <code>_replace-scheduler_(e, sch)</code>.

    5. When `start` is called on `op_state1`, it calls `start` on `op_state2`.

    6. The lifetime of `op_state2`, once constructed, lasts until either
       `op_state3` is constructed or `op_state1` is destroyed, whichever comes
       first. The lifetime of `op_state3`, once constructed, lasts until
       `op_state1` is destroyed.

6. Given subexpressions `s1` and `e`, where `s1` is a sender returned from `on`
    or a copy of such, let `S1` be `decltype((s1))`. Let [`E'`]{.rm}[`E2`]{.add} be
    `decltype((@_replace-scheduler_@(e, sch)))`. Then the type of
    `tag_invoke(get_completion_signatures, s1, e)` shall be:

    > ```
    > make_completion_signatures<
    >   copy_cvref_t<S1, S>,
    >   @[E']{.rm}[E2]{.add}@,
    >   make_completion_signatures<
    >     schedule_result_t<Sch>,
    >     E,
    >     completion_signatures<set_error_t(exception_ptr)>,
    >     @_no-value-completions_@>>;
    > ```

    where `@_no-value-completions_@<As...>` names the type `completion_signatures<>`
    for any set of types `As...`.



[Update __§11.9.6.4 [exec.transfer]__ as follows:]{.ednote}

1. `transfer` adapts a sender into a sender with a different associated
   `set_value` completion scheduler. [<i>Note</i>: it results in a transition
   between different execution resources when executed. --<i>end note</i>]

2. The name `transfer` denotes a customization point object. For some
    subexpressions `sch` and `s`, let `Sch` be `decltype((sch))` and `S` be
    `decltype((s))`. If `Sch` does not satisfy `scheduler`, or `S` does not
    satisfy `sender`, `transfer@[(s, sch)]{.add}@` is ill-formed. Otherwise, the
    expression `transfer(s, sch)` is expression-equivalent to:

    > <div class="add" style="color: #006e28">
    > ```
    > transform_sender(
    >   @_get-sender-domain_@(s),
    >   @_make-sender_@(transfer, sch, s));
    > ```
    > </div>

    <div class="rm" style="color: #bf0303">
    1. `tag_invoke(transfer, get_completion_scheduler<set_value_t>(get_env(s)), s, sch)`,
        if that expression is valid.

        * _Mandates:_ The type of the `tag_invoke` expression above satisfies `sender`.

    2. Otherwise, `tag_invoke(transfer, s, sch)`, if that expression is valid.

        * _Mandates:_ The type of the `tag_invoke` expression above
          satisfies `sender`.

    3. Otherwise, `schedule_from(sch, s)`.
    </div>

    > [If the function selected above]{.rm}[If a sender `S` returned from
    > `transfer(s, sch)` is connected with a receiver `R` with environment `E` such
    > that `transform_sender(@_get-env-domain_@(E), S, E)`]{.add} does not return
    > a sender [which]{.rm}[that]{.add} is a result of a call to
    > `@[transform_sender(_get-env-domain_(E), ]{.add}@schedule_from(sch, s2)@[, E)]{.add}@`,
    > where `s2` is a sender [which]{.rm}[that]{.add} sends values
    > [equivalent]{.rm}[equal]{.add} to
    > those sent by `s`, the behavior of calling [`transfer(s, sch)`]{.rm}
    > [`connect(S, R)`]{.add} is undefined.

<!-- this comment is needed here to un-confundle the markdown processor -->

3. For a sender `t` returned from `transfer(s, sch)`, `get_env(t)` shall return
    a queryable object `q` such that [`get_domain(q)` is expression-equivalent
    to `get_domain(sch)` and]{.add} `get_completion_scheduler<@_CPO_@>(q)` returns
    a copy of `sch`, where _`CPO`_ is either `set_value_t` or `set_stopped_t`. The
    `get_completion_scheduler<set_error_t>` query is not implemented, as the
    scheduler cannot be guaranteed in case an error is thrown while trying to
    schedule work on the given scheduler object. For all other query objects
    _`Q`_ whose type satisfies _`forwarding-query`_, the expression
    `@_Q_@(q, args...)` shall be equivalent to `@_Q_@(get_env(s), args...)`.

:::add

4. Let `s` and `e` be subexpressions such that `S` is `decltype((s))`. If
    `@_sender-for_@<S, transfer_t>` is `false`, then the expression
    `transfer_t().transform_sender(s, e)` is ill-formed; otherwise, it
    is equal to:

    > ```
    > const auto& env = e;
    > auto domain = @_get-env-domain_@(env);
    > auto [tag, data, child] = s;
    > return execution::transform_sender(domain, schedule_from(std::move(data), std::move(child)), env);
    > ```

    [This causes the `transfer(s, sch)` sender to become
    `schedule_from(sch, s)` when it is connected with a receiver whose
    domain does not customize `transfer`.]{.note}

:::


[Update __§11.9.6.5 [exec.schedule.from]__ as follows:]{.ednote}

1. `schedule_from` schedules work dependent on the completion of a sender onto a
    scheduler's associated execution resource. [<i>Note</i>: `schedule_from` is
    not meant to be used in user code; it is used in the implementation of
    `transfer`. -<i>end note</i>]

3. The name `schedule_from` denotes a customization point object. For some
    subexpressions `sch` and `s`, let `Sch` be `decltype((sch))` and `S` be
    `decltype((s))`. If `Sch` does not satisfy `scheduler`, or `S` does not
    satisfy `sender`, `schedule_from@[(sch, s)]{.add}@` is ill-formed.
    Otherwise, the expression `schedule_from(sch, s)` is expression-equivalent
    to:

    > <div class="add" style="color: #006e28">
    > ```
    > transform_sender(
    >   @_query-or-default_@(get_domain, sch, default_domain()),
    >   @_make-schedule-from-sender_@(sch, s));
    > ```
    > </div>

    <div class="add" style="color: #006e28">
    where `@_make-schedule-from-sender_@(sch, s)` is expression-equivalent to
    `@_make-sender_@(schedule_from, sch, s)`, and the returned sender object
    `s2` behaves as follows:
    </div>

    1. <div class="rm" style="color: #bf0303">
        `tag_invoke(schedule_from, sch, s)`, if that expression is valid. If the
        function selected by `tag_invoke` does not return a sender that
        completes on an execution agent belonging to the associated execution
        resource of `sch` and completing with the same async result
        ([async.ops]) as `s`, the behavior of calling `schedule_from(sch, s)` is
        undefined.

        * _Mandates:_ The type of the `tag_invoke` expression above
          satisfies `sender`.
    </div>

    <!-- -->

    1. [Otherwise, constructs a sender `s2`.]{.rm} When `s2` is connected with some
       receiver `out_r`, it:

        1. Constructs a receiver `r` such that when a receiver completion
           operation `@_Tag_@(r, args...)` is called, it
           decay-copies `args...` into `op_state` (see below) as `@[args\']{.rm}[args2]{.add}@...` and
           constructs a receiver `r2` such that:

            1. When `set_value(r2)` is called, it calls
               `@_Tag_@(out_r, std::move(@[args\']{.rm}[args2]{.add}@)...)`.

            2. `set_error(r2, e)` is expression-equivalent to `set_error(out_r, e)`.

            3. `set_stopped(r2)` is expression-equivalent to `set_stopped(out_r)`.

            It then calls `schedule(sch)`, resulting in a sender `s3`. It then
            calls `connect(s3, r2)`, resulting in an operation state
            `op_state3`. It then calls `start(op_state3)`. If any of these
            throws an exception, it catches it and calls
            `set_error(out_r, current_exception())`. If any of these expressions
            would be ill-formed, then `@_Tag_@(r, args...)` is
            ill-formed.

        2. Calls `connect(s, r)` resulting in an operation state `op_state2`. If
           this expression would be ill-formed, `connect(s2, out_r)` is
           ill-formed.

        3. Returns an operation state `op_state` that contains `op_state2`. When
           `start(op_state)` is called, calls `start(op_state2)`. The lifetime
           of `op_state3` ends when `op_state` is destroyed.

    2. [This para is taken from the removed para (1) above.]{.ednote} [If the
        function selected by `tag_invoke`]{.rm}[If a sender `S` returned from
        `schedule_from(sch, s)` is connected with a receiver `R` with environmment
        `E` such that `transform_sender(@_get-env-domain_@(E), S, E)`]{.add}
        does not return a sender that completes on an execution agent belonging
        to the associated execution resource of `sch` and [completing]{.rm} with
        the same async result ([async.ops]) as `s`, the behavior of calling
        [`schedule_from(sch, s)`]{.rm} [`connect(S, R)`]{.add} is undefined.

    3. Given subexpressions `s2` and `e`, where `s2` is a sender returned from
        `schedule_from` or a copy of such, let `S2` be `decltype((s2))` and let
        `E` be `decltype((e))`. Then the type of
        `tag_invoke(get_completion_signatures, s2, e)` shall be:

        > ```
        > make_completion_signatures<
        >   copy_cvref_t<S2, S>,
        >   E,
        >   make_completion_signatures<
        >     schedule_result_t<Sch>,
        >     E,
        >     @_potentially-throwing-completions_@,
        >     @_no-completions_@>,
        >   @_value-completions_@,
        >   @_error-completions_@>;
        > ```

        where _`potentially-throwing-completions`_, _`no-completions`_,
        _`value-completions`_, and _`error-completions`_ are defined as follows:

        > ```
        > template <class... Ts>
        > using @_all-nothrow-decay-copyable_@ =
        >   @[`boolean_constant<(is_nothrow_constructible_v<decay_t<Ts>, Ts> && ...)>`]{.rm}@
        >   @[`conjunction<is_nothrow_constructible<decay_t<Ts>, Ts>...>`]{.add};@
        >
        > @[`template <class... Ts>`]{.rm}@
        > @@[`using @_conjunction_@ = boolean_constant<(Ts::value &&...)>;`]{.rm}@@
        >
        > using @_potentially-throwing-completions_@ =
        >   conditional_t<
        >     error_types_of_t<copy_cvref_t<S2, S>, E, @_all-nothrow-decay-copyable_@>::value &&
        >       value_types_of_t<copy_cvref_t<S2, S>, E, @_all-nothrow-decay-copyable_@, @[_conjunction_]{.rm}[conjunction]{.add}@>::value,
        >     completion_signatures<>,
        >     completion_signatures<set_error_t(exception_ptr)>;
        >
        > template <class...>
        > using @_no-completions_@ = completion_signatures<>;
        >
        > template <class... Ts>
        > using @_value-completions_@ = completion_signatures<set_value_t(decay_t<Ts>&&...)>;
        >
        > template <class T>
        > using @_error-completions_@ = completion_signatures<set_error_t(decay_t<T>&&)>;
        > ```

<!-- -->

3. For a sender `t` returned from `schedule_from(sch, s)`, `get_env(t)` shall
    return a queryable object `q` such that [`get_domain(q)` is
    expression-equivalent to `get_domain(sch)` and]{.add}
    `get_completion_scheduler<@_CPO_@>(q)` returns a copy of `sch`, where
    _`CPO`_ is either `set_value_t` or `set_stopped_t`. The
    `get_completion_scheduler<set_error_t>` query is not implemented, as the
    scheduler cannot be guaranteed in case an error is thrown while trying to
    schedule work on the given scheduler object. For all other query objects
    _`Q`_ whose type satisfies _`forwarding-query`_, the expression
    `@_Q_@(q, args...)` shall be equivalent to `@_Q_@(get_env(s), args...)`.


[Update __§11.9.6.6 [exec.then]__ as follows:]{.ednote}

1. `then` attaches an invocable as a continuation for an input sender's value
    completion operation.

2. The name `then` denotes a customization point object. For some subexpressions
    `s` and `f`, let `S` be `decltype((s))`, let `F` be the decayed type of `f`,
    and let `@[f']{.rm}[f2]{.add}@` be an xvalue refering to an object
    decay-copied from `f`. If `S` does not satisfy `sender`, or `F` does not
    model _`movable-value`_, `then@[(s, f)]{.add}@` is ill-formed. Otherwise,
    the expression `then(s, f)` is expression-equivalent to:

    > <div class="add" style="color: #006e28">
    > ```
    > transform_sender(
    >   @_get-sender-domain_@(s),
    >   @_make-then-sender_@(f, s));
    > ```
    > </div>

    <div class="add" style="color: #006e28">
    where `@_make-then-sender_@(f, s)` is expression-equivalent to
    `@_make-sender_@(then, f, s)`, and the returned sender object
    `s2` behaves as follows:
    </div>

    1. <div class="rm" style="color: #bf0303">
       `tag_invoke(then, get_completion_scheduler<set_value_t>(get_env(s)), s, f)`,
       if that expression is valid.

        * _Mandates:_ The type of the `tag_invoke` expression above satisfies `sender`.
       </div>

    2. <div class="rm" style="color: #bf0303">
       Otherwise, `tag_invoke(then, s, f)`, if that expression is valid.

        * _Mandates:_ The type of the `tag_invoke` expression above satisfies `sender`.
       </div>

    <!-- -->

    1. [Otherwise, constructs a sender `s2`.]{.rm} When `s2` is connected with some
       receiver `out_r`, it:

        1. Constructs a receiver `r` such that:

            1. When `set_value(r, args...)` is called, let `v` be the
                expression `invoke(@[f']{.rm}[f2]{.add}@, args...)`. If `decltype(v)` is `void`,
                calls `set_value(out_r)`; otherwise, it calls
                `set_value(out_r, v)`. If any of these throw an
                exception, it catches it and calls
                `set_error(out_r, current_exception())`. If any of these
                expressions would be ill-formed, the expression
                `set_value(r, args...)` is ill-formed.

            2. `set_error(r, e)` is expression-equivalent to `set_error(out_r, e)`.

            3. `set_stopped(r)` is expression-equivalent to `set_stopped(out_r)`.

        2. Returns an expression-equivalent to `connect(s, r)`.

        3. Let `@_compl-sig-t_@<Tag, Args...>` name the type
            `Tag()` if `Args...` is a template paramter pack containing the
            single type `void`; otherwise, `Tag(Args...)`. Given
            subexpressions `s2` and `e` where `s2` is a sender returned from
            `then` or a copy of such, let `S2` be `decltype((s2))` and let
            `E` be `decltype((e))`. The type of
            `tag_invoke(get_completion_signatures, s2, e)` shall be [equivalent
            to]{.rm}:

            > ```
            > make_completion_signatures<>
            >   copy_cvref_t<S2, S>, E, @_set-error-signature_@,
            >     @_set-value-completions_@> @[`;`]{.rm}@
            > ```

            where _`set-value-completions`_ is [an alias for]{.rm}[the alias template]{.add}:

            > ```
            > template<class... As>
            >   @_set-value-completions_@ =
            >     completion_signatures<@_compl-sig-t_@<set_value_t, invoke_result_t<F, As...>>>
            > ```

            and _`set-error-signature`_ is an alias for
            `completion_signatures<set_error_t(exception_ptr)>` if any of the types
            in the _`type-list`_ named by
            `value_types_of_t<copy_cvref_t<S2, S>, E, @_potentially-throwing_@, @_type-list_@>`
            are `true_type`; otherwise, `completion_signatures<>`, where
            _`potentially-throwing`_ is the [template alias]{.rm}[alias template]{.add}:

            > ```
            > template<class... As>
            >   using @_potentially-throwing_@ =
            >     @[`bool_constant<!is_nothrow_invocable_v<F, As...>>`]{.rm}@
            >     @[`negation<is_nothrow_invocable<F, As...>>`]{.add}@;
            > ```

    2. [If the function selected above]{.rm} [Let `S` be the result of calling
      `then(s, f)` or a copy of thus. If `S` is connected with a recevier `R`
      with environment `E` such that
      `transform_sender(@_get-env-domain_@(E), S, E)`]{.add} does not return a
      sender that[:]{.add} [reformated as a list for comprehensibility:]{.ednote}
      
        --- invokes `f` with the value result datums of `s`,

        --- [using]{.rm}[uses]{.add} `f`'s return value as [the sender's]{.rm}
            [`S`'s]{.add} value completion, and

        --- forwards the non-value completion operations [to `R`]{.add}
            unchanged,
            
        then the behavior of calling [`then(s, f)`]{.rm}[`connect(S, R)`]{.add}
        is undefined.

[Make analogous changes to __§11.9.6.7 [exec.upon.error]__ and
__§11.9.6.8 [exec.upon.stopped]__.]{.ednote}


---
references:
  - id: stdexecgithub
    citation-label: stdexecgithub
    title: "stdexec"
    url: https://github.com/NVIDIA/stdexec
  - id: P2300R7
    citation-label: P2300R7
    type: paper
    title: "`std::execution`"
    author:
      - given: Michał
        family: Dominiak
        email:  griwes@griwes.info
      - given: Georgy
        family: Evtushenko
        email:  evtushenko.georgy@gmail.com
      - given: Lewis
        family: Baker
        email:  lewissbaker@gmail.com
      - given: Lucian Radu
        family: Teodorescu
        email: lucteo@lucteo.ro
      - given: Lee
        family: Howes
        email:  xrikcus@gmail.com
      - given: Kirk
        family: Shoop
        email:  kirk.shoop@gmail.com
      - given: Michael
        family: Garland
        email:  mgarland@nvidia.com
      - given: Eric
        family: Niebler
        email:  eric.niebler@gmail.com
      - given: Bryce Adelstein
        family: Lelbach
        email: brycelelbach@gmail.com
    url: https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2300r7.html
---
