---
title: "Sender Algorithm Customization"
subtitle: "Draft Proposal"
document: D2999R1
date: today
audience:
  - "LEWG Library Evolution"
author:
  - name: Eric Niebler
    email: <eric.niebler@gmail.com>
toc: true
---

Introduction
============

This paper proposes some design changes to P2300 to address some shortcomings in
how algorithm customizations are found.

The Issue
=========

The essence of the issue is this:

:  _Many senders do not know on what execution context they will complete, so
   using solely that information to find customizations (as P2300R7 does) is
   unsatisfactory._

In [@P2300R7], the sender algorithms (`then`, `let_value`, etc) are
customization point objects that internally dispatch via `tag_invoke` to the
correct algorithm implementation. Each algorithm has a default implementation
that is used if no custom implementation is found.

Custom implementations of sender algorithms are found by asking the predecessor
sender for its completion scheduler and using the scheduler as a tag for the
purpose of tag dispatching. A _completion scheduler_ is a scheduler that refers
to the execution context on which that sender will complete.

A typical sender algorithm like `then` might be implemented as follows:

```cpp
/// @brief A helper concept for testing whether an algorithm customization
///   exists
template <class AlgoTag, class SetTag, class Sender, class... Args>
concept @_has-customization_@ =
  requires (Sender sndr, Args... args) {
    tag_invoke(AlgoTag(),
               get_completion_scheduler<SetTag>(get_env(sndr)),
               std::forward<Sender>(sndr),
               std::forward<Args>(args)...);
  };

/// @brief The tag type and the customization point object type for the
///   `then` sender algorithm
struct then_t {
  template <sender Sender, class Fun>
    requires /* requirements here */
  auto operator()(Sender&& sndr, Fun fun) const
  {
    // If the predecessor sender has a completion scheduler, and if we can use
    // the completion scheduler to find a custom implementation for the `then`
    // algorithm, dispatch to that. Otherwise, dispatch to the default `then`
    // implementation.
    if constexpr (@_has-customization_@<then_t, set_value_t, Sender, Fun>)
    {
      auto&& env = get_env(sndr);
      return tag_invoke(*this,
                        get_completion_scheduler<set_value_t>(env),
                        std::forward<Sender>(sndr),
                        std::move(fun));
    }
    else
    {
      return @_then-sender_@<Sender, Fun>(std::forward<Sender>(sndr), std::move(fun));
    }
  }
};

inline constexpr then_t then {};
```

This scheme has a number of shortcomings:

1. A simple sender like `just(42)` does not know its completion scheduler. It
   completes on the execution context on which it is started. That is not known
   at the time the sender is constructed, which is when we are looking for
   customizations.

2. For a sender like `on( sched, then(just(), fun) )`, the nested `then` sender is
   constructed before we have specified the scheduler, but we need the scheduler
   to dispatch to the correct customization of `then`. How?

3. A composite sender like `when_all(sndr1, sndr2)` cannot know its completion
   scheduler in the general case. Even if `sndr1` and `sndr2` both know their
   completion schedulers -- say, `sched1` and `sched2` respectively -- the
   `when_all` sender can complete on _either_ `sched1` _or_ `sched2` depending
   on which of `sndr1` and `sndr2` completes last. That is a dynamic property of
   the program's execution, not suitable for finding an algorithm customization.

In cases (1) and (2), the issue is that the information necessary to find the
correct algorithm implementation is not available at the time we look for
customizations. In case (3), the issue is that the algorithm semantics make it
impossible to know statically to what algorithm customization scheme to dispatch.

The issue described in (2) above is particularly pernicious. Consider these two
programs (where `ex::` is a namespace alias for `std::execution`); the
differences are highlighted:

::: cmptable

> Table 1: Algorithms customizations are found or not depending on subtle differences

### Good
```cpp
my::thread_pool_scheduler sch = /*...*/;

// Describe some bulk work on a thread pool
auto work =
  @<mark>ex::transfer_just(sch, data)</mark>@
| ex::bulk(data.size(),
           [](int i, auto& data) {
             ++data[i];
           });

// Execute the work
std::this_thread::sync_wait(@<mark>std::move(work)</mark>@);
```

### Bad
```cpp
my::thread_pool_scheduler sch = /*...*/;

// Describe some bulk work
auto work =
  @<mark>ex::just(data)</mark>@
| ex::bulk(data.size(),
           [](int i, auto& data) {
             ++data[i];
           });

// Execute the bulk work on a thread pool
std::this_thread::sync_wait(@<mark>ex::on(sch, std::move(work))</mark>@);
```

:::

These two programs _should_ be equivalent, but they are not. The author
of the `thread_pool_scheduler` gave it a custom `bulk` implementation
by defining:

```cpp
namespace my {
  // customization of the bulk algorithm for the thread_pool_scheduler:
  template <ex::sender Sender, std::integral Shape, class Function>
  auto tag_invoke(ex::bulk_t,
                  thread_pool_scheduler sched,
                  Sender&& sndr,
                  Shape shape,
                  Function fun) {
    /*
     * Do bulk work in parallel
     * ...
     */
  }
}
```

This overload is found only when the `bulk` sender's predecessor completes on a
`thread_pool_scheduler`, which is the case for the code on the left.

In the code to the right, however, the predecessor of the `bulk` operation is
`just(data)`, a sender that does not know where it will complete. As a result,
the above customization of the `bulk` algorithm will not be found, and the bulk
operation will execute serially on a single thread in the thread pool. That's
almost certainly _not_ what the programmer intended.

This is clearly broken and badly in need of fixing.

> *Note:* On the need for async algorithms customization
>
> It is worth asking why async algorithms need customization at all. After all,
> the classic STL algorithms need no customization; they dispatch using a fixed
> concept hierarchy to a closed set of possible implementations.
>
> The reason is because of the open and continually evolving nature of execution
> contexts. There is little hope of capturing every salient attribute of every
> interesting execution model -- CPUs, GPUs, FPGAs, etc., past, present, and
> future -- in a fixed ontology around which we can build named concepts and
> immutable basis operations. Instead we do the best we can and then hedge
> against the future by making the algorithms customizable. For example, say we
> add an algorithm `std::par_algo`, but we allow that there may be an accelerator
> "out there" that may do `par_algo` more efficiently than the standard one,
> so we make `par_algo` customizable.

Proposed Design
===============

Features and rationale
-------

This section describes at a high level the salient features of the proposed
design for sender algorithm customization, and their rationale. But in a
nutshell, the basic idea is as follows:

> For every invocation of a sender algorithm, the implementation looks for
> a customization _twice_: once immediately while the algorithm is constructing
> a sender to return, and once later _when the resulting sender is `connect`-ed
> with a receiver_.

It is the second look-up that is new. By looking for a customization at
`connect` time, the dispatching logic is informed both by information from
the predecessor sender(s) as well as from the receiver. It is the receiver
that has information about the environment of the currently executing
asynchronous operation, information that is key to picking the right
customization in the cases we looked at above.

### Dispatching via execution domain tags

As described above, the `when_all` sender doesn't know its completion scheduler,
so we cannot use the completion scheduler to find the `when_all` customization.
Even if all its child senders advertise completion schedulers with the same type
-- say, `static_thread_pool` -- `when_all` itself can't advertise a completion
scheduler because it doesn't know that they are all the _same_
`static_thread_pool`.

In the case just described, consider that we can know the completion scheduler's
_type_ but not its value. So at the very least, we need to add a query about the
type of the scheduler apart from its value, for times when we know one but not
the other.

Once we have done that, further generalizing the query from a scheduler type to
an abstract tag type is a short hop. We call this abstract tag type an
_execution domain_. Several different scheduler types may all want to use the
same set of algorithm implementations; those schedulers can all use the same
execution domain type for the purpose of dispatching.

If `when_all`'s child senders all share an execution domain, we know the execution domain of the
`when_all` sender itself even if we don't know which scheduler it will complete
on. But that no longer prevents us from dispatching to the correct
implementation.

This paper proposes the addition of a forwarding `get_domain` query in the
`std::execution` namespace, and that the domain is used together with the
algorithm tag to dispatch to the correct algorithm implementation.

Additionally, we proposed that the `when_all` algorithm only accepts a set of
senders when they all share a common domain. Likewise for `let_value` and
`let_error`, we require that there is only one possible domain on which their
senders may complete.

### Late (sender/receiver connection-time) customization

As described above, the sender algorithm customization points don't have all the
information they need to dispatch to the correct algorithm implementation in all
cases. The solution is to look again for a customization when all the information
is available. That happens when the sender is `connect`-ed to a receiver.

This paper proposes the addition of a `transform_sender` function that is called
by the `connect` customization point to transform a sender prior to connecting
it with the receiver. The correct sender transformation is found using a
property read from the receiver's environment.

The following comparison table shows how we propose to change the `connect` customization
point (changes highlighted):

<table style="caption-side: top;">
<caption>Table 2: The addition of `transform_sender` to `connect`</caption>
<thead>
<tr class="header">
<th style="text-align: center;"> __Before__ </th>
<th style="text-align: center;"> __After__ </th>
</tr>
</thead>
<tbody>
<tr>
<td>
```c++
struct connect_t {
  template <receiver Receiver, sender_in<env_of_t<Receiver>> Sender>
    requires /* ... */
  auto operator()(Sender&& sndr, Receiver&& rcvr) const {






    // First, look for a customization of tag_invoke:
    if constexpr (tag_invocable<connect_t, Sender, Receiver>) {
      return tag_invoke(*this,
                        std::forward<Sender>(sndr),
                        std::forward<Receiver>(rcvr));
    }
    // Next, see if the sender is co_await-able:
    else if constexpr (@_is-await-connectable_@<Sender, Receiver>) {
      /* ... */
    }
  }
};
```
</td>
<td>
```c++
struct connect_t {
  template <receiver Receiver, sender_in<env_of_t<Receiver>> Sender>
    requires /* ... */
  auto operator()(Sender&& sndr, Receiver&& rcvr) const {
    @@<mark>`// Apply any sender tranformations using the receiver's domain:`</mark>@@
    @@<mark>`auto&& sndr2 = transform_sender(@_get-env-domain_@(get_env(rcvr)),`</mark>@@
                                    @@<mark>`std::forward<Sender>(sndr),`</mark>@@
                                    @@<mark>`get_env(rcvr));`</mark>@@
    @@<mark>`using Sender2 = decltype(sndr2);`</mark>@@

    // First, look for a customization of tag_invoke:
    if constexpr (tag_invocable<connect_t, @<mark>Sender2</mark>@, Receiver>) {
      return tag_invoke(*this,
                        std::forward<@<mark>Sender2</mark>@>(@<mark>sndr2</mark>@),
                        std::forward<Receiver>(rcvr));
    }
    // Next, see if the sender is co_await-able:
    else if constexpr (@_is-await-connectable_@<@<mark>Sender2</mark>@, Receiver>) {
      /* ... */
    }
  }
};
```
</td>
</tr>
</tbody>
</table>




#### Parity with coroutines

The use of `transform_sender` in `connect` it is analagous to the use of
[`await_transform`](https://eel.is/c++draft/expr.await#3.2) in `co_await`.
Glossing over some details, in a coroutine the expression `co_await @_expr_@` is
"lowered" to
`operator co_await(@_p_@.await_transform(@_expr_@)).await_suspend(@_handle-to-p_@)`,
where _`p`_ is a reference to coroutine's promise. This gives the coroutine
task type some say in how `co_await` expressions are evaluated.

The addition of `transform_sender` to P2300 satisfies the same need to
customize the launch behavior of child async tasks. An expression like
`connect(@_sndr_@, @_detached-receiver_@)` is "lowered" to
`connect(transform_sender(@_domain_@, @_sndr_@, get_env(@_detached-receiver_@)), @_detached-receiver_@)`,
where _`domain`_ is a property of the receiver's environment. This gives
the receiver some say in how `connect` expressions are evaluated.

#### Recursive transformations

The author anticipates the need to sometimes apply a transformation recursively
to all of a sender's child senders. Such a generic recursive transformation
might look something like this:

    ```c++
    // my_domain applies a transformation recursively
    auto my_domain::transform_sender(Sender&& sndr, const Env& env) const {
      auto [tag, data, child...] = sndr;

      // Create a temporary sender with transformed children
      auto tmp = @_make-sender_@(
        tag,
        data,
        ex::transform_sender(*this, child, env)...);

      // Use the transformed children to compute a domain
      // (they all must share a domain or it's an error)
      auto&& [x, y, child2...] = tmp;
      auto domain2 = @_common-domain-of_@(child2...);

      // Use the predecessor domain to transform the temporary sender:
      return ex::transform_sender(domain2, move(tmp), env);
    }
    ```

This works well until we apply this function to a sender that modifies the
environment it passes to its child operations. Take the case of
`on(sched, sndr)`: when it is connected to a receiver, it connects its child
sender `sndr` with a receiver whose environment has been modified to show that
the current scheduler is `sched` (because `on` will start `sndr` there).

But the implementation of `my_domain::tranform_sender` above does not update the
environment when it is recursively transforming an `on` sender's child. That
means the child will be transformed with incorrect information about where it
will be executing, which can change the meaning of the transformation. That's
not good. Something is missing.

We need a way to ask a sender to apply its transformation to an environment.
That is, in addition to `transform_sender` we need `transform_env` that can
be used to fix the code above as follows (differences highlighted):

    ```c++
    // my_domain applies a transformation recursively
    auto my_domain::transform_sender(Sender&& sndr, const Env& env) const {
      auto [tag, data, child...] = sndr;

      // Apply any necessary transformations to the environment
      @<mark>`auto&& env2 = ex::transform_env(*this, sndr, env);`</mark>@

      // Create a temporary sender with transformed children,
      // using the transformed environment from the line above
      auto tmp = @_make-sender_@(
        tag,
        data,
        ex::transform_sender(*this, child, @<mark>`env2`</mark>@)...);

      // Use the transformed children to compute a domain
      // (they all must share a domain or it's an error)
      auto&& [x, y, child2...] = tmp;
      auto domain2 = @_common-domain-of_@(child2...);

      // Use the predecessor domain to transform the temporary sender:
      return ex::transform_sender(domain2, move(tmp), env);
    }
    ```

Now expressions can generically be transformed recursively.


### Early (sender construction-time) customization

We can use `transform_sender` for early customization as well as late. The
benefit of doing this is that only one set of customizations needs be written
for each domain, rather than two (early and late).

This paper proposes that each algorithm constructs a default sender that
implements the default behavior for that algorithm. It then passes that sender
to `transform_sender` along with the sender's domain. The result of
`transform_sender` is what the algorithm returns.


The following comparison table shows how we propose to change the `connect` customization
point (changes highlighted):

<table style="caption-side: top;">
<caption>Table 3: The proposed changes to the `then` customization point</caption>
<thead>
<tr class="header">
<th style="text-align: center;"> __Before__ </th>
<th style="text-align: center;"> __After__ </th>
</tr>
</thead>
<tbody>
<tr>
<td>
```c++
struct then_t {
  template <sender Sender, class Fun>
    requires /* ... */
  auto operator()(Sender&& sndr, Fun fun) const {
    // First, use the completion scheduler to look for a tag_invoke 
    if constexpr (@_has-customization_@<then_t, set_value_t, Sender, Fun>) {
      auto&& env = get_env(sndr);
      return tag_invoke(*this,
                        get_completion_scheduler<set_value_t>(env),
                        std::forward<Sender>(sndr),
                        std::move(fun));
    }
    // Otherwise, use the default implementation:
    else {
      return then-sender<Sender, Fun>(std::forward<Sender>(sndr),
                                      std::move(fun));
    }
  }
};
```
</td>
<td>
```c++
struct then_t {
  template <sender Sender, class Fun>
    requires /* ... */
  auto operator()(Sender&& sndr, Fun fun) const {
    // Get the domain from the predecessor sender:
    auto domain = @_get-sender-domain_@(sndr);

    // Create a `then` sender and ask the predecessor to
    // transform it if desired
    return transform_sender(
      domain,
      @_then-sender_@<Sender, Fun>(std::forward<Sender>(sndr),
                               std::move(fun)));
  }
};
```
</td>
</tr>
</tbody>
</table>


Some algorithms are required to do some work eagerly in their default
implementation (_e.g._, `split`, `ensure_started`). These algorithms must first
create a dummy sender to pass to `transform_sender`. The "default" domain, which
is used when no other domain has been specified, can transform these dummy
senders and do their eager work in the process. The same mechanism is also
useful to implement customizable sender algorithms whose default implementation
merely lowers to a more primitive expression (_e.g._ `transfer(s,sch)` becomes
`schedule_from(sch,s)`, and `transfer_just(sch, ts...)` becomes
`just(ts...) | transfer(sch)`).

For example, here is how the `transfer_just` customization point might look
after the change:

<table style="caption-side: top;">
<caption>Table 4: The proposed changes to the `then` customization point</caption>
<thead>
<tr class="header">
<th style="text-align: center;"> __Before__ </th>
<th style="text-align: center;"> __After__ </th>
</tr>
</thead>
<tbody>
<tr>
<td>
```c++
struct transfer_just_t {
  template <scheduler Scheduler, class... Ts>
    requires /* ... */
  auto operator()(Scheduler sched, Ts&&... ts) const {
    // First, use the completion scheduler to look for a tag_invoke 
    if constexpr (
      @_has-customization_@<
        transfer_just_t, set_value_t, Scheduler, Ts...>) {
      auto&& env = get_env(sndr);
      return tag_invoke(*this,
                        get_completion_scheduler<set_value_t>(env),
                        std::move(sched),
                        std::forward<Ts>(ts)...);
    }
    // Otherwise, use the default implementation:
    else {
      return just(std::forward<Ts>(ts)...)
           | transfer(std::move(sched));
    }
  }
};
```
</td>
<td>
```c++
struct transfer_just_t {
  template <scheduler Scheduler, class... Ts>
    requires /* ... */
  auto operator()(Scheduler sched, Ts&&... ts) const {
    // Get the predecessor's domain
    auto domain = @_get-sender-domain_@(sndr);

    // Construct a transfer_just sender and transform it
    return transform_sender(
      domain,
      @_make-sender_@(*this, tuple{std::move(sched),
                               std::forward<Ts>(ts)...}));
  }

  // default_domain::transform_sender dispatches here:
  template <class Sender, class Env>
  auto transform_sender(Sender&& sndr, const Env& env) const {
    auto [tag, data] = std::forward<Sender>(sndr);
    auto [sched, ts...] = std::move(data);
    return just(std::move(ts)...)
         | transfer(std::move(sched));
  }
};
```
</td>
</tr>
</tbody>
</table>

Some algorithms are entirely eager with no lazy component, like `sync_wait` and
`start_detached`. For these, "transforming" a sender isn't what you want; you
want to dispatch to an eager algorithm that will actually _consume_ the sender.
We can use domains to dispatch to the correct implementation for those as well.
This paper proposes the addition of an `apply_sender` function.

The following table describes the differences between `transform_sender` and
`apply_sender`:

<table style="caption-side: top;">
  <caption>Table 5: The differences between `transform_sender` and `apply_sender`</caption>
  <thead>
    <tr class="header">
      <th style="text-align: center;"> __`transform_sender`__ </th>
      <th style="text-align: center;"> __`apply_sender`__ </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <ul>
          <li>always called with either a sender or a sender+env</li>
          <li>always returns a sender</li>
          <li>has a sensible default implementation: identity</li>
          <li>useful for lazy or partly lazy algorithms (e.g., `then`,
              `ensure_started`)</li>
        </ul>
      </td>
      <td>
        <ul>
          <li>called with a sender and an arbitrary set of additional
              arguments</li>
          <li>can return anything</li>
          <li>has no sensible default implementation</li>
          <li>useful for fully eager algorithms (e.g., `start_detached`,
              `sync_wait`)</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


To permit third parties to author customizable sender algorithms with partly or
fully eager behavior, the mechanism by which the default domain finds the
default `transform_sender` and `apply_sender` implementations shall be
specified: they both dispatch to similarly named functions on the tag type of
the input sender; i.e., `default_domain().transform_sender(sndr, env)` is
equal to `tag_of_t<decltype(sndr)>().transform_sender(sndr, env)`.

### Decomposable senders

For the `transform_sender` customization point to be useful, we need a way to
access the constituent pieces of a sender and re-assemble it from (possibly
transformed) pieces. Senders, like coroutines, generally begin in a "suspended"
state; they merely curry their algorithm's arguments into a subsequent call to
`connect`. These "suspended" senders are colloquially known as _lazy_ senders.

Each lazy sender has an associated algorithm tag, a (possibly empty) set of
auxiliary data and a (possibly empty) set of child senders; _e.g._, the sender
returned from `then(snd, fun)` has `then_t` as its tag, the set `[fun]` as its
auxiliary data, and `[snd]` as its set of child senders, while `just(42, 3.14)`
has `just_t` as its tag, `[42, 3.14]` as its data set and `[]` as its child set.

This paper proposes to use structured bindings as the API for decomposing a lazy
sender into its tag, data, and child senders:

```cpp
auto&& [tag, data, ...children] = sndr;
```

[@P1061R5], currently in Core wording review for C++26, permits the declaration
of variadic structured bindings like above, making this syntax very appealing.

Not all senders are required to be decomposable, although all the "standard"
lazy senders shall be. There needs to be a syntactic way to distinguish between
decomposable and ordinary,non-decomposable senders (decomposable senders
subsuming the `sender` concept).

There is currently no trait for determining whether a type can be the
initializer of a structured binding. However, EWG has already approved
[@P2141R1] for C++26, and with it such a trait could be built, giving us a
simple way to distinguish between decomposable and non-decomposable senders.

If P2141 is not adopted for C++26, we will need some other syntactic way to
opt-in. One possibility is to require that the sender type's nested `is_sender`
type shall have some known, standard tag type as a base class to signify that
that sender type can be decomposed.

#### Recomposing senders

After decomposing a sender, it is often desirable to re-compose it from its
modified constituents. No separate API for reconstituting senders is necessary
though. It is enough to construct a decomposable sender of some arbitrary type
and then pass it to `transform_sender` with an execution domain to place it in its final
form.

Consider the case where `my_domain::transform_sender()` is passed
`your_sender<Children...>`. It unpacks it into its tag/data/children
constituents and munges the children somehow. It then wants to reconstruct
a `your_sender` from the munged children. Instead, it constructs
`@_arbitrary-sender_@{tag, data, munged_children}` and passes it
to `execution::transform_sender()` along with `your_domain`, the
domain associated with `your_sender`. That presumably will transform
the _`arbitrary-sender`_ back into a `your_sender`.


Summary of proposed changes
---------------------------

In condensed form, here are the changes this paper is proposing:

#. Add a `default_domain` type for use when no other domain is determinable.

#. Add a new `get_domain(@_env_@) -> @_domain-tag_@` forwarding query.

#. Add a new
   `transform_sender(@_domain_@, @_sender_@ [, @_env_@]) -> @_sender_@` API.
   This function is not itself customizable, but it will be
   used for both early customization (at sender construction-time) and late
   customization (at sender/receiver connection-time).

   *Early customization:*
      - called from within each sender algorithm's customization point object
      - replaces the current mechanism of tag-dispatching to
        a sender factory function using the completion scheduler as a tag
      - called without an environment argument
      - `@_domain_@` is derived from the sender by trying the following in order:
        1. `get_domain(get_env(@_sender_@))`
        2. `get_domain(get_completion_scheduler<@_completion-tag_@>(get_env(@_sender_@)))`,
           where `@_completion-tag_@` is one of `set_value_t`, `set_error_t`,
           or `set_stopped_t` depending on the algorithm
        3. `default_domain()`

    *Late customization:*
      - called from the `connect` customization point object before
        tag-dispatching with `connect_t` to `tag_invoke`
      - called with the receiver's environment
      - `@_domain_@` is derived from the receiver by trying the following in order:
        1. `get_domain(get_env(@_receiver_@))`
        2. `get_domain(get_scheduler(get_env(@_receiver_@)))`
        3. `default_domain()`

   `transform_sender(@_domain_@, @_sender_@ [, @_env_@])` returns the first of
   these that is well-formed:

    * `@_domain_@.transform_sender(@_sender_@ [, @_env_@])`
    * `default_domain().transform_sender(@_sender_@ [, @_env_@])`
    * `@_sender_@`

#. Add a `transform_env(@_domain_@, @_sender_@, @_env_@) -> @_env'_@` API in
   support of generic recursive sender transformations. The `@_domain_@`
   argument is determined from _`env`_ as for `transform_sender`

   `transform_env(@_domain_@, @_sender_@, @_env_@)` returns the first of
   these that is well-formed:

   * `@_domain_@.transform_env(@_sender_@, @_env_@)`
   * `default_domain().transform_env(@_sender_@, @_env_@)`

#. The standard, "lazy" sender types (i.e., those returned from sender factory
   and adaptor functions) return sender types that are decomposable using
   structured bindings into its [_tag_, _data_, ..._children_] components.

#. A call to the `when_all` algorithm should be ill-formed unless all of the
   sender arguments have the same domain type (as determined for senders above).
   The resulting `when_all` sender should publish that domain via the sender's
   environment.

#. The `on(sch, sndr)` algorithm should be specified in terms of `transfer` so
   as to pick up any late customization of the `transfer` algorithm. (This
   amounts to changing `schedule(sch)` to `transfer_just(sch)` in
   [exec.on]/3.2.2.). Additionally, it should replace the domain in the
   receiver's environment with the domain of `sch`.

#. The sender factories `just`, `just_error`, and `just_stopped` need their tag
   types to be specified. Name them `just_t`, `just_error_t`, and
   `just_stopped_t`.

#. In the algorithm `let_value(sndr, fun)`, if the predecessor sender `sndr` has
   a completion scheduler for `set_value`, then the receiver connected to the
   secondary sender (the one returned from `fun` when called with `sndr`'s
   results) shall expose that scheduler as the current scheduler of the
   receiver's environment.

   In other words, if the predecessor sender `sndr` completes with values
   `vs...`, then the result of `fun(vs...)` will be connected to a receiver `r`
   such that `get_scheduler(get_env(r))` is equal to
   `get_completion_scheduler<set_value_t>(get_env(sndr))`.

   The same is true also of the domain query: `get_domain(get_env(r))` is equal
   to the domain of the predecessor sender as computed by the steps in (2)
   above.

   So for `let_value`, likewise also for `let_error` and `let_stopped`, using
   `set_error_t` and `set_stopped` respectively when querying for the
   predecessor sender's completion scheduler and domain.

#. The `schedule_from(sched, sndr)` algorithm should return a sender `s` such
   that `get_domain(get_env(s))` is equal to `get_domain(sched)`.

#. The following customizable algorithms, whose default implementations must do
   work before returning the result sender, will have their work performed in
   overloads of `default_domain::transform_sender`:

    - `split`
    - `ensure_started`

#. The following customizable algorithms, whose default implementations are
   trivially expressed in terms of other more primitive operations, will be
   lowered into their primitive forms by overloads of
   `default_domain::transform_sender`:

    - `transfer`
    - `transfer_just`
    - `transfer_when_all`
    - `transfer_when_all_with_variant`
    - `when_all_with_variant`

#. In the algorithm `let_value(snd, fun)`, all of the sender types that the
    input function `fun` might return -- the set of potential result senders
    -- must all have the same domain; otherwise, the call to `let_value` is
    ill-formed.
    
    Ideally, the `let_value` sender would report the result senders' domain
    as its domain, however we don't know the set of completions until the
    `let_value` sender is connected to a receiver; hence, we also don't
    know the set of potential result senders or their domains. Instead, we
    require that all the result senders share an execution domain with the predecessor
    sender. If they differ, `connect` is ill-formed.

    For example, consider the following sender:

    > ```c++
    > auto snd =
    >     read(get_scheduler)
    >   | transfer(schA)
    >   | let_value([](auto schB){ return schedule(schB); })
    > ```

    This reads the current scheduler from the receiver, transfers
    execution to `schA`, and then (indirectly, through `let_value`)
    transitions onto the scheduler read from the receiver (`schB`).
    This sender can be `connect`-ed only to receivers `R` for which
    the scheduler `get_scheduler(get_env(R))` has the same execution domain
    as that of `schA`.

    Likewise for `let_error` and `let_stopped`.

    This solution is not ideal. I am currently working on a more flexible
    solution, but I'm not yet sufficiently confident in it to propose it here.

#. Add a new
   `apply_sender(@_domain_@, @_tag_@, @_sender_@, @_args_@...) -> @_result_@` API.
   Like `transform_sender`, this function is not itself customizable, but it
   will be used to customize sender consuming algorithms such as `start_detached`
   and `sync_wait`.

   - called from within each consuming sender algorithm's customization point
     object
   - replaces the current mechanism of tag-dispatching to a custom implementation
     using the completion scheduler as a tag
   - called the sender's execution domain, the algorithm's tag, the sender, and any
     additional algorithm arguments
   - `@_domain_@` is determined as for `transform_sender`

   `apply_sender(@_domain_@, @_tag_@, @_sender_@, @_args_@...)` returns the first of
   these that is well-formed:

   * `@_domain_@.apply_sender(@_tag_@, @_sender_@, @_args_@...)`
   * `default_domain().apply_sender(@_tag_@, @_sender_@, @_args_@...)`

#. The following customizable sender-consuming algorithms will have their
   default implementations in overloads of `default_domain::apply_sender`:

   - `start_detached`
   - `sync_wait`


Implementation Experience
=========================

_Has it been implented?_ YES. The design changes herein proposed are implemented
in the main branch of [@stdexecgithub], the reference implementation. The bulk
of the changes including `get_domain`, `transform_sender`, and the changes to
`connect` have been shipping since [this
commit](https://github.com/NVIDIA/stdexec/commit/0693876c6144479ab5d9bec671751bd32d14e23a)
on August 3, 2023 which changed the `static_thread_pool` scheduler to use
`transform_sender` to parallelize the `bulk` algorithm.

Proposed Wording
================

The following proposed changes are relative to [@P2300R7].

[Change __§11.4 [exec.syn]__ as follows:]{.ednote}

```diff
  @_// [exec.queries], queries_@
  enum class forward_progress_guarantee;
  namespace @_queries_@ { @_// exposition only_@
    @[struct\ get_domain_t;]{.add}@
    struct get_scheduler_t;
    struct get_delegatee_scheduler_t;
    struct get_forward_progress_guarantee_t;
    template<class CPO>
      struct get_completion_scheduler_t;
  }

  @@[using @_queries_@::get_domain_t;]{.add}@@
  using @_queries_@::get_scheduler_t;
  using @_queries_@::get_delegatee_scheduler_t;
  using @_queries_@::get_forward_progress_guarantee_t;
  using @_queries_@::get_completion_scheduler_t;
  @[inline\ constexpr\ get_domain_t\ get_domain{};]{.add}@
  inline constexpr get_scheduler_t get_scheduler{};
  inline constexpr get_delegatee_scheduler_t get_delegatee_scheduler{};
  inline constexpr get_forward_progress_guarantee_t get_forward_progress_guarantee{};
  template<class CPO>
    inline constexpr get_completion_scheduler_t<CPO> get_completion_scheduler{};

  @@[@_//\ [exec.domain.default],\ domains_@]{.add}@@
  @[struct\ default_domain;]{.add}@
```

[... and ...]{.ednote}

```diff
  template<class S, class E = empty_env>
      requires sender_in<S, E>
    inline constexpr bool sends_stopped = @_see below_@;

  @[`template <sender Sender>`]{.add}@
    @@[`using tag_of_t = @_see below_@;`]{.add}@@

  @@[`@_// [exec.snd.transform], sender transformations_@`]{.add}@@
  @[`template <class Domain, sender Sender, class... Env>`]{.add}@
      @[`requires (sizeof...(Env) <= 1)`]{.add}@
    @@[`constexpr sender decltype(auto) transform_sender(Domain dom, Sender&& sndr, const Env&... env) noexcept(@_see below_@);`]{.add}@@

  @[`template <class Domain, sender Sender, class Env>`]{.add}@
    @[`constexpr decltype(auto) transform_env(Domain dom, Sender&& sndr, Env&& env) noexcept;`]{.add}@

  @@[`@_// [exec.snd.apply], sender algorithm application_@`]{.add}@@
  @[`template <class Domain, class Tag, sender Sender, class... Args>`]{.add}@
    @@[`constexpr decltype(auto) apply_sender(Domain dom, Tag, Sender&& sndr, Args&&... args) noexcept(@_see below_@);`]{.add}@@

  @_// [exec.connect], the connect sender algorithm_@
  namespace senders-connect { // exposition only
    struct connect_t;
  }
  using senders-connect::connect_t;
  inline constexpr connect_t connect{};
```

[... and ...]{.ednote}

```diff
  @_// [exec.factories], sender factories_@
  namespace @_senders-factories_@ { @_// exposition only_@
    @[`struct just_t;`]{.add}@
    @[`struct just_error_t;`]{.add}@
    @[`struct just_stopped_t;`]{.add}@
    struct schedule_t;
    struct transfer_just_t;
  }
  @@[using @_sender-factories_@::just_t;]{.add}@@
  @@[using @_sender-factories_@::just_error_t;]{.add}@@
  @@[using @_sender-factories_@::just_stopped_t;]{.add}@@
  @@inline constexpr [@_unspecified_@]{.rm}[just_t]{.add}\ just{};@@
  @@inline constexpr [@_unspecified_@]{.rm}[just_error_t]{.add}\ just_error{};@@
  @@inline constexpr [@_unspecified_@]{.rm}[just_stopped_t]{.add}\ just_stopped{};@@
```

[After __§11.5.4 [exec.get.stop.token]__, add the following new subsection:]{.ednote}

:::add
__§11.5.? `execution::get_domain` [exec.get.domain]__

1. `get_domain` asks an object for an associated execution domain tag.

2. The name `get_domain` denotes a query object. For some subexpression `r`,
   `get_domain(r)` is expression-equivalent to
   `@_mandate-nothrow-call_@(tag_invoke, get_domain, as_const(r))`,
   if this expression is well-formed.

3. `std::forwarding_query(execution::get_domain)` is `true`.

4. `get_domain()` (with no arguments) is expression-equivalent to
    `execution::read(get_domain)` ([exec.read]).

:::


[To section __§11.6 [exec.sched]__, insert a new paragraph between 6 and 7
as follows:]{.ednote}

:::add
7. For a given scheduler expression `s`, if the expression `get_domain(s)`
    is well-formed, then the expression `get_domain(get_env(schedule(s)))`
    is also well-formed and has the same type.

:::


[To section __§11.9.1 [exec.snd.concepts]__, after paragraph 4, add two new
paragraphs as follows:]{.ednote}

:::add
5. Let `s` be an expression such that `decltype((s))` is `S`. The type
   `tag_of_t<S>` is as follows:

      - If the declaration `auto&& [tag, data, ...children] = s;` would be
        well-formed, `tag_of_t<S>` is an alias for `decltype(auto(tag))`.

      - Otherwise, `tag_of_t<S>` is ill-formed.

    [There is no way in standard C++ to determine whether the above declaration
    is well-formed without causing a hard error, so this presumes compiler
    magic. However, the author anticipates the adoption of [@P2141R1], which
    makes it possible to implement this purely in the library. P2141 has already
    been approved by EWG for C++26.]{.ednote}

6. Let `@_sender-for_@` be an exposition-only concept defined as follows:

   > ```
   > template <class Sender, class Tag>
   > concept @_sender-for_@ =
   >   sender<Sender> &&
   >   same_as<tag_of_t<Sender>, Tag>;
   > ```
:::


[After __§11.9.2 [exec.awaitables]__, add the following new subsections:]{.ednote}

:::add

__§11.9.? `execution::default_domain` [exec.domain.default]__

```
struct default_domain {
  template <sender Sender, class... Env>
      requires (sizeof...(Env) <= 1)
    static constexpr sender decltype(auto) transform_sender(Sender&& sndr, const Env&... env) noexcept(@_see below_@);

  template <sender Sender, class Env>
    static constexpr decltype(auto) transform_env(Sender&& sndr, Env&& env) noexcept;

  template <class Tag, sender Sender, class... Args>
    static constexpr decltype(auto) apply_sender(Tag, Sender&& sndr, Args&&... args) noexcept(@_see below_@);
};
```

__§11.9.?.1 Static members [exec.domain.default.statics]__

```
template <sender Sender, class... Env>
    requires (sizeof...(Env) <= 1)
  constexpr sender decltype(auto) default_domain::transform_sender(Sender&& sndr, const Env&... env) noexcept(@_see below_@);
```

_Returns:_ `tag_of_t<Sender>().transform_sender(std::forward<Sender>(sndr), env...)`
  if that expression is well-formed; otherwise, `std::forward<Sender>(sndr)`.

_Remarks:_ The exception specification is equivalent to:

  > ```
  > noexcept(tag_of_t<Sender>().transform_sender(std::forward<Sender>(sndr), env...))
  > ```

  if that expression is well-formed; otherwise, `true`;

```
template <sender Sender, class Env>
  constexpr decltype(auto) default_domain::transform_env(Sender&& sndr, Env&& env) noexcept;
```

_Returns:_ `tag_of_t<Sender>().transform_env(std::forward<Sender>(sndr), std::forward<Env>(env))`
  if that expression is well-formed; otherwise, `static_cast<Env>(std::forward<Env>(env))`.

_Mandates:_ The selected expression in _Returns:_ is not potentially throwing.


```
template <class Tag, sender Sender, class... Args>
  static constexpr decltype(auto) default_domain::apply_sender(Tag, Sender&& sndr, Args&&... args) noexcept(@_see below_@);
```

_Returns:_ `Tag().apply_sender(std::forward<Sender>(sndr), std::forward<Args>(args)...)`
  if that expression is well-formed; otherwise, this function shall not participate
  in overload resolution.

_Remarks:_ The exception specification is equivalent to:

  > ```
  > noexcept(Tag().apply_sender(std::forward<Sender>(sndr), std::forward<Args>(args)...))
  > ```

__§11.9.? `execution::transform_sender` [exec.snd.transform]__

```
template <class Domain, sender Sender, class... Env>
    requires (sizeof...(Env) <= 1)
  constexpr sender decltype(auto) transform_sender(Domain dom, Sender&& sndr, const Env&... env) noexcept(@_see below_@);
```

_Returns:_ `dom.transform_sender(std::forward<Sender>(sndr), env...)` if that
      expression is well-formed; otherwise,
      `default_domain().transform_sender(std::forward<Sender>(sndr), env...)`.


_Remarks:_ The exception specification is equivalent to:

  > ```
  > noexcept(dom.transform_sender(std::forward<Sender>(sndr), env...))
  > ```

  if that expression is well-formed; otherwise,

  > ```
  > noexcept(default_domain().transform_sender(std::forward<Sender>(sndr), env...))
  > ```

```
template <class Domain, sender Sender, class Env>
  constexpr decltype(auto) transform_env(Domain dom, Sender&& sndr, Env&& env) noexcept;
```

_Returns:_ `dom.transform_sender(std::forward<Sender>(sndr), std::forward<Env>(env))` if that
      expression is well-formed; otherwise,
      `default_domain().transform_sender(std::forward<Sender>(sndr), std::forward<Env>(env))`.

__§11.9.? `execution::apply_sender` [exec.snd.apply]__

```
template <class Domain, class Tag, sender Sender, class... Args>
  constexpr decltype(auto) apply_sender(Domain dom, Tag, Sender&& sndr, Args&&... args) noexcept(@_see below_@);
```

_Returns:_ `dom.apply_sender(Tag(), std::forward<Sender>(sndr), std::forward<Args>(args)...)` if that
      expression is well-formed; otherwise,
      `default_domain().apply_sender(Tag(), std::forward<Sender>(sndr), std::forward<Args>(args)...)`
      if that expression is well-formed; otherwise, this function shall not participate in
      overload resolution.

_Remarks:_ The exception specification is equivalent to:

  > ```
  > noexcept(dom.apply_sender(Tag(), std::forward<Sender>(sndr), std::forward<Args>(args)...))
  > ```

  if that expression is well-formed; otherwise,

  > ```
  > noexcept(default_domain().apply_sender(Tag(), std::forward<Sender>(sndr), std::forward<Args>(args)...))
  > ```

:::


[Add a paragraph to __§11.9 [exec.snd]__]{.ednote}

:::add

1. This section makes use of the following exposition-only entities.

    1.  ```
        template <class Tag, class Env, class Default>
        constexpr decltype(auto) @_query-with-default_@(Tag, const Env& env, Default&& value) noexcept(@_see below_@);

        ```

        _Effects:_ Equivalent to:

          --- `return Tag()(env);` if that expression is well-formed,

          --- `return static_cast<Default>(std::forward<Default>(value));` otherwise.

        _Remarks:_ The expression in the `noexcept` clause is:

          > ```
          > is_invocable_v<Tag, const Env&> ? is_nothrow_invocable_v<Tag, const Env&>
          >                                 : is_nothrow_constructible_v<Default, Default>
          > ```

    2.  ```
        template <class Env, class Tag = get_scheduler_t>
        constexpr auto @_get-env-domain_@(const Env& env, Tag tag = {}) noexcept;

        ```

        _Effects:_ Equivalent to:

          --- `return get_domain(env);` if that expression is well-formed,

          --- otherwise, `return get_domain(tag(env));` if that expression is
            well-formed,

          --- otherwise, `return default_domain();`.

    3.  ```
        template <class Sender, class Tag = set_value_t>
        constexpr auto @_get-sender-domain_@(const Sender& sndr, Tag = {}) noexcept;

        ```

        _Effects:_ Equivalent to: `return @_get-env-domain_@(get_env(sndr), get_completion_scheduler<Tag>);`.

    4.  ```
        template <class... T>
        struct @_tuple-like_@ {
          T@<sub>_0_</sub>@ @_t_<sub>_0_</sub>@;      // exposition only
          T@<sub>_1_</sub>@ @_t_<sub>_1_</sub>@;      // exposition only
            ...
          T@<sub>_n-1_</sub>@ @_t_<sub>_n-1_</sub>@;   // exposition only
        };

        ```

        --- [An expression of type `@_tuple-like_@` is usable as the initializer
            of a structured binding declaration [dcl.struct.bind].]{.note}

    5.  ```
        template <semiregular Tag, @_movable-value_@ Data, sender... Child>
        constexpr auto @_make-sender_@(Tag, Data&& data, Child&&... child);

        ```

        _Returns:_ A prvalue of type `@_basic-sender_@<Tag, decay_t<Data>, decay_t<Child>...>`
            where the _`tag`_ member has been default-initialized and the
            _`data`_ and `@_child_<sub>_n_</sub>@...` members have
            been direct initialized from their respective forwarded arguments, where
            _`basic-sender`_ is the following exposition-only class template
            except as noted below:

        > ```
        > template <class Tag, class Data, class... Child> // arguments are not associated entities ([lib.tmpl-heads])
        > struct @_basic-sender_@ : @_unspecified_@ {
        >   using is_sender = @_unspecified_@;
        >
        >   [[no_unique_address]] Tag @_tag_@;  // exposition only
        >   Data @_data_@;          // exposition only
        >   Child@<sub>_0_</sub>@ @_child_<sub>_0_</sub>@;      // exposition only
        >   Child@<sub>_1_</sub>@ @_child_<sub>_1_</sub>@;      // exposition only
        >     ...
        >   Child@<sub>_n-1_</sub>@ @_child_<sub>_n-1_</sub>@;   // exposition only
        > };
        >
        > ```

        --- It is unspecified whether instances of _`basic-sender`_ can be
            aggregate initialized.

        --- The unspecified base type has no non-static data members. It may
            define member functions or hidden friend functions ([hidden.friends]).

        --- [An expression of type `@_basic-sender_@` is usable as the
            initializer of a structured binding declaration
            [dcl.struct.bind].]{.note}

    6.  ```
        template <class Domain, class... Env>
        auto @_make-transformer-fn_@(Domain, const Env&... env) {
          return [&]<class Tag>(Tag) {
            return [&]<class... Args>(Args&&... args) -> decltype(auto) {
              return transform_sender(Domain(), Tag()(std::forward<Args>(args)...), env...);
            };
          };
        }

        ```

:::


[To __§11.9.5.2 [exec.just]__, add a paragraph 6 as follows:]{.ednote}

:::add
6. When used as the initializer of a structured binding declaration,
    expressions of type `@_just-sender_@<Tag, Ts...>` behave as do
    expressions of type `@_basic-sender_@<Tag, @_tuple-like_@<Ts...>>`.

:::


[Change __§11.9.5.3 [exec.transfer.just]__ as follows
(some identifiers in this section have had their names changed for the sake of
clarity; the name changes have not been marked up):]{.ednote}

2. The name `transfer_just` denotes a customization point object. For some
    subexpression `sch` and pack of subexpressions `vs`, let `Sch` be
    `decltype((sch))` and let `Vs` be the template parameter pack
    `decltype((vs))...`. If `Sch` does not satisfy `scheduler`, or any type `V` in
    `Vs` does not satisfy _`movable-value`_,
    `transfer_just(sch, vs...)` is ill-formed. Otherwise, `transfer_just(sch, vs...)`
    is expression-equivalent to:

    > <div class="add" style="color: #006e28">
    > ```
    > transform_sender(
    >   @_query-or-default_@(get_domain, sch, default_domain()),
    >   @_make-sender_@(transfer_just, @_tuple-like_@{sch, vs...}));
    > ```
    > </div>

    1. [`tag_invoke(transfer_just, sch, vs...)`, if that expression is valid.]{.rm}

3. Let `as` be a pack of rvalue subexpressions of types `decay_t<Vs>...`
    refering to objects direct-initilized from `vs`. If [the function
    selected by `tag_invoke`]{.rm}[a sender `S` returned from `transfer_just(sch, vs...)`
    is connected with a receiver `R` with environment `E` such that
    `transform_sender(@_get-env-domain_@(E), S, E)`]{.add}
    does not return a sender whose asynchronous
    operations execute value completion operations on an execution agent
    belonging to the execution resource associated with `sch`, with value result
    datums `as`, the behavior of calling [`transfer_just(sch, vs...)`]{.rm}
    [`connect(S, R)`]{.add} is undefined.

    * _Mandates:_ `sender_of<@[R]{.rm}[S]{.add}@, set_value_t(decay_t<Vs>...), E>`,
        where `@[R]{.rm}[S]{.add}@` is the type of [the `tag_invoke` expression above]{.rm}
        [`transfer_just(sch, vs...)`]{.add}, and `E` is the type of an environment.

:::rm
  > 2. Otherwise, `transfer(just(vs...), sch)`.
:::

:::add
4. For some subexpression `sch` and pack of subexpressions `vs`, let `s` be a
    subexpression refering to an object returned from `transform_just(sch, vs...)`
    or a copy of such. Then
    `get_completion_scheduler<set_value_t>(get_env(s)) == sch` is `true`,
    `get_completion_scheduler<set_stopped_t>(get_env(s)) == sch` is `true`, and
    `get_domain(get_env(s))` is expression-equivalent to `get_domain(sch)`.

5. Let `s` and `e` be subexpressions such that `S` is `decltype((s))`. If
    `@_sender-for_@<S, transfer_just_t>` is `false`, then the expression
    `transfer_just_t().transform_sender(s, e)` is ill-formed; otherwise, it
    is equal to:

    > ```
    > const auto& env = e;
    > auto domain = @_get-env-domain_@(env);
    > auto [tag, data] = s;
    > auto& [sched, ...vs] = data;
    > auto tfx = @_make-transformer-fn_@(domain, env);
    > return tfx(transfer)(tfx(just)(std::move(vs)...), std::move(sched));
    > ```

    [This causes the `transform_just(sch, vs...)` sender to become
    `transform(just(vs...), sch)` when it is connected with a receiver whose
    execution domain does not customize `transform_just`.]{.note}

:::

[Update __§11.9.6.3 [exec.on]__ as follows:]{.ednote}


1. `on` adapts an input sender into a sender that will start on an execution
    agent belonging to a particular scheduler's associated execution resource.

2. Let `@_replace-scheduler_@(e, sch)` be an expression denoting an object `e'`
    such that `get_scheduler(e@[\']{.add}@)` returns a copy of `sch`,
    [`get_domain(e')` is expression-equivalent to `get_domain(sch)`,]{.add} and
    `tag_invoke(tag, e', args...)` is expression-equivalent to `tag(e, args...)`
    for all arguments `args...` and for all `tag` whose type satisfies
    `@_forwarding-query_@` and is not `get_scheduler_t` [or
    `get_domain_t`]{.add}.

3. The name `on` denotes a customization point object. For some subexpressions
    `sch` and `s`, let `Sch` be `decltype((sch))` and `S` be `decltype((s))`. If
    `Sch` does not satisfy `scheduler`, or `S` does not satisfy `sender`,
    `on@[(sch, s)]{.add}@` is ill-formed. Otherwise, the expression `on(sch, s)`
    is expression-equivalent to:

    > <div class="add" style="color: #006e28">
    > ```
    > transform_sender(
    >   @_query-or-default_@(get_domain, sch, default_domain()),
    >   @_make-sender_@(on, sch, s));
    > ```
    > </div>

    1. [`tag_invoke(on, sch, s)`, if that expression is valid. If the function
        selected above]{.rm}[If a sender `S` returned from `on(sch, s)` is
        connected with a receiver `R` with environment `E` such that
        `transform_sender(@_get-env-domain_@(E), S, E)`]{.add} does not return a
        sender which starts `s` on an execution agent of the associated
        execution resource of `sch` when started, the behavior of calling
        [`on(sch, s)`]{.rm}[`connect(S, R)`]{.add} is undefined.

        * [_Mandates:_ The type of the `tag_invoke` expression above satisfies
            `sender`.]{.rm}

5. [Let `s` and `e` be subexpressions such that `S` is `decltype((s))`. If
    `@_sender-for_@<S, on_t>` is `false`, then the expression
    `on_t().transform_sender(s, e)` is ill-formed; otherwise, it returns]{.add}
    [Otherwise, constructs]{.rm} a sender `s1` [. When]{.rm}[such that
    when]{.add} `s1` is connected with some receiver `out_r`, it:

    1. Constructs a receiver `r` such that:

        1. When `set_value(r)` is called, it calls `connect(s, r2)`, where `r2`
           is as specified below, which results in `op_state3`. It calls
           `start(op_state3)`. If any of these throws an exception, it calls
           `set_error` on `out_r`, passing `current_exception()` as the second
           argument.

        2. `set_error(r, e)` is expression-equivalent to `set_error(out_r, e)`.

        3. `set_stopped(r)` is expression-equivalent to `set_stopped(out_r)`.

        4. `get_env(r)` is expression-equivalent to `get_env(out_r)`.

    2. Calls [`schedule(sch)`]{.rm}[`transfer_just(sch)`]{.add}, which
        results in `s2`. It then calls `connect(s2, r)`, resulting in
        `op_state2`.

    3. `op_state2` is wrapped by a new operation state, `op_state1`, that is
       returned to the caller.

    4. `r2` is a receiver that wraps a reference to `out_r` and forwards all
        completion operations to it. In addition, `get_env(r2)` returns
        `@_replace-scheduler_@(e, sch)`.

    5. When `start` is called on `op_state1`, it calls `start` on `op_state2`.

    6. The lifetime of `op_state2`, once constructed, lasts until either
       `op_state3` is constructed or `op_state1` is destroyed, whichever comes
       first. The lifetime of `op_state3`, once constructed, lasts until
       `op_state1` is destroyed.

6. [Let `s` and `e` be subexpressions such that `S` is `decltype((s))`. If
    `@_sender-for_@<S, on_t>` is `false`, then the expression
    `on_t().transform_env(s, e)` is ill-formed; otherwise, let `sch` be the
    scheduler used to construct `s`. `on_t().transform_env(s, e)` is equal
    to `@_replace-scheduler_@(e, sch)`.]{.add}

7. Given subexpressions `s1` and `e`, where `s1` is a sender returned from `on`
    or a copy of such, let `S1` be `decltype((s1))`. Let `E'` be
    `decltype((@_replace-scheduler_@(e, sch)))`. Then the type of
    `tag_invoke(get_completion_signatures, s1, e)` shall be:

    > ```
    > make_completion_signatures<
    >   copy_cvref_t<S1, S>,
    >   E',
    >   make_completion_signatures<
    >     schedule_result_t<Sch>,
    >     E,
    >     completion_signatures<set_error_t(exception_ptr)>,
    >     @_no-value-completions_@>>;
    > ```

    where `@_no-value-completions_@<As...>` names the type `completion_signatures<>`
    for any set of types `As...`.



[Update __§11.9.6.4 [exec.transfer]__ as follows:]{.ednote}

1. `transfer` adapts a sender into a sender with a different associated
   `set_value` completion scheduler. [It results in a transition
   between different execution resources when executed.]{.note}

2. The name `transfer` denotes a customization point object. For some
    subexpressions `sch` and `s`, let `Sch` be `decltype((sch))` and `S` be
    `decltype((s))`. If `Sch` does not satisfy `scheduler`, or `S` does not
    satisfy `sender`, `transfer@[(s, sch)]{.add}@` is ill-formed. Otherwise, the
    expression `transfer(s, sch)` is expression-equivalent to:

    > <div class="add" style="color: #006e28">
    > ```
    > transform_sender(
    >   @_get-sender-domain_@(s),
    >   @_make-sender_@(transfer, sch, s));
    > ```
    > </div>

    <div class="rm" style="color: #bf0303">
    1. `tag_invoke(transfer, get_completion_scheduler<set_value_t>(get_env(s)), s, sch)`,
        if that expression is valid.

        * _Mandates:_ The type of the `tag_invoke` expression above satisfies `sender`.

    2. Otherwise, `tag_invoke(transfer, s, sch)`, if that expression is valid.

        * _Mandates:_ The type of the `tag_invoke` expression above
          satisfies `sender`.

    3. Otherwise, `schedule_from(sch, s)`.
    </div>

    > [If the function selected above]{.rm}[If a sender `S` returned from
    > `transfer(s, sch)` is connected with a receiver `R` with environment `E` such
    > that `transform_sender(@_get-env-domain_@(E), S, E)`]{.add} does not return
    > a sender [which]{.rm}[that]{.add} is a result of a call to
    > `@[transform_sender(_get-env-domain_(E), ]{.add}@schedule_from(sch, s2)@[, E)]{.add}@`,
    > where `s2` is a sender [which]{.rm}[that]{.add} sends values
    > [equivalent]{.rm}[equal]{.add} to
    > those sent by `s`, the behavior of calling [`transfer(s, sch)`]{.rm}
    > [`connect(S, R)`]{.add} is undefined.

<!-- this comment is needed here to un-confundle the markdown processor -->

3. For a sender `t` returned from `transfer(s, sch)`, `get_env(t)` shall return
    a queryable object `q` such that [`get_domain(q)` is expression-equivalent
    to `get_domain(sch)` and]{.add} `get_completion_scheduler<@_CPO_@>(q)` returns
    a copy of `sch`, where _`CPO`_ is either `set_value_t` or `set_stopped_t`. The
    `get_completion_scheduler<set_error_t>` query is not implemented, as the
    scheduler cannot be guaranteed in case an error is thrown while trying to
    schedule work on the given scheduler object. For all other query objects
    _`Q`_ whose type satisfies _`forwarding-query`_, the expression
    `@_Q_@(q, args...)` shall be equivalent to `@_Q_@(get_env(s), args...)`.

:::add

4. Let `s` and `e` be subexpressions such that `S` is `decltype((s))`. If
    `@_sender-for_@<S, transfer_t>` is `false`, then the expression
    `transfer_t().transform_sender(s, e)` is ill-formed; otherwise, it
    is equal to:

    > ```
    > const auto& env = e;
    > auto domain = @_get-env-domain_@(env);
    > auto [tag, data, child] = s;
    > auto tfx = @_make-transformer-fn_@(domain, env);
    > return tfx(schedule_from)(std::move(data), std::move(child));
    > ```

    [This causes the `transfer(s, sch)` sender to become
    `schedule_from(sch, s)` when it is connected with a receiver whose
    execution domain does not customize `transfer`.]{.note}

:::


[Update __§11.9.6.5 [exec.schedule.from]__ as follows:]{.ednote}

1. `schedule_from` schedules work dependent on the completion of a sender onto a
    scheduler's associated execution resource. [`schedule_from` is
    not meant to be used in user code; it is used in the implementation of
    `transfer`.]{.note}

3. The name `schedule_from` denotes a customization point object. For some
    subexpressions `sch` and `s`, let `Sch` be `decltype((sch))` and `S` be
    `decltype((s))`. If `Sch` does not satisfy `scheduler`, or `S` does not
    satisfy `sender`, `schedule_from@[(sch, s)]{.add}@` is ill-formed.
    Otherwise, the expression `schedule_from(sch, s)` is expression-equivalent
    to:

    > <div class="add" style="color: #006e28">
    > ```
    > transform_sender(
    >   @_query-or-default_@(get_domain, sch, default_domain()),
    >   @_make-schedule-from-sender_@(sch, s));
    > ```
    > </div>

    <div class="add" style="color: #006e28">
    where `@_make-schedule-from-sender_@(sch, s)` is expression-equivalent to
    `@_make-sender_@(schedule_from, sch, s)` and returns a sender object
    `s2` that behaves as follows:
    </div>

    1. <div class="rm" style="color: #bf0303">
        `tag_invoke(schedule_from, sch, s)`, if that expression is valid. If the
        function selected by `tag_invoke` does not return a sender that
        completes on an execution agent belonging to the associated execution
        resource of `sch` and completing with the same async result
        ([async.ops]) as `s`, the behavior of calling `schedule_from(sch, s)` is
        undefined.

        * _Mandates:_ The type of the `tag_invoke` expression above
          satisfies `sender`.
    </div>

    <!-- -->

    1. [Otherwise, constructs a sender `s2`.]{.rm} When `s2` is connected with some
       receiver `out_r`, it:

        1. Constructs a receiver `r` such that when a receiver completion
           operation `@_Tag_@(r, args...)` is called, it decay-copies `args...`
           into `op_state` (see below) as `@[args\']{.rm}[args2]{.add}@...` and
           constructs a receiver `r2` such that:

            1. When `set_value(r2)` is called, it calls
               `@_Tag_@(out_r, std::move(@[args\']{.rm}[args2]{.add}@)...)`.

            2. `set_error(r2, e)` is expression-equivalent to `set_error(out_r, e)`.

            3. `set_stopped(r2)` is expression-equivalent to `set_stopped(out_r)`.

            4. [`get_env(r2)` is equal to `get_env(r)`.]{.add}

            It then calls `schedule(sch)`, resulting in a sender `s3`. It then
            calls `connect(s3, r2)`, resulting in an operation state
            `op_state3`. It then calls `start(op_state3)`. If any of these
            throws an exception, it catches it and calls
            `set_error(out_r, current_exception())`. If any of these expressions
            would be ill-formed, then `@_Tag_@(r, args...)` is
            ill-formed.

        2. Calls `connect(s, r)` resulting in an operation state `op_state2`. If
           this expression would be ill-formed, `connect(s2, out_r)` is
           ill-formed.

        3. Returns an operation state `op_state` that contains `op_state2`. When
           `start(op_state)` is called, calls `start(op_state2)`. The lifetime
           of `op_state3` ends when `op_state` is destroyed.

    2. [This para is taken from the removed para (1) above.]{.ednote} [If the
        function selected by `tag_invoke`]{.rm}[If a sender `S` returned from
        `schedule_from(sch, s)` is connected with a receiver `R` with environmment
        `E` such that `transform_sender(@_get-env-domain_@(E), S, E)`]{.add}
        does not return a sender that completes on an execution agent belonging
        to the associated execution resource of `sch` and [completing]{.rm} with
        the same async result ([async.ops]) as `s`, the behavior of calling
        [`schedule_from(sch, s)`]{.rm} [`connect(S, R)`]{.add} is undefined.

    3. Given subexpressions `s2` and `e`, where `s2` is a sender returned from
        `schedule_from` or a copy of such, let `S2` be `decltype((s2))` and let
        `E` be `decltype((e))`. Then the type of
        `tag_invoke(get_completion_signatures, s2, e)` shall be:

        > ```
        > make_completion_signatures<
        >   copy_cvref_t<S2, S>,
        >   E,
        >   make_completion_signatures<
        >     schedule_result_t<Sch>,
        >     E,
        >     @_potentially-throwing-completions_@,
        >     @_no-completions_@>,
        >   @_value-completions_@,
        >   @_error-completions_@>;
        > ```

        where _`potentially-throwing-completions`_, _`no-completions`_,
        _`value-completions`_, and _`error-completions`_ are defined as follows:

        > ```
        > template <class... Ts>
        > using @_all-nothrow-decay-copyable_@ =
        >   @[`boolean_constant<(is_nothrow_constructible_v<decay_t<Ts>, Ts> && ...)>`]{.rm}@
        >   @[`conjunction<is_nothrow_constructible<decay_t<Ts>, Ts>...>`]{.add};@
        >
        > @[`template <class... Ts>`]{.rm}@
        > @@[`using @_conjunction_@ = boolean_constant<(Ts::value &&...)>;`]{.rm}@@
        >
        > using @_potentially-throwing-completions_@ =
        >   conditional_t<
        >     error_types_of_t<copy_cvref_t<S2, S>, E, @_all-nothrow-decay-copyable_@>::value &&
        >       value_types_of_t<copy_cvref_t<S2, S>, E, @_all-nothrow-decay-copyable_@, @[_conjunction_]{.rm}[conjunction]{.add}@>::value,
        >     completion_signatures<>,
        >     completion_signatures<set_error_t(exception_ptr)>;
        >
        > template <class...>
        > using @_no-completions_@ = completion_signatures<>;
        >
        > template <class... Ts>
        > using @_value-completions_@ = completion_signatures<set_value_t(decay_t<Ts>&&...)>;
        >
        > template <class T>
        > using @_error-completions_@ = completion_signatures<set_error_t(decay_t<T>&&)>;
        > ```

<!-- -->

3. For a sender `t` returned from `schedule_from(sch, s)`, `get_env(t)` shall
    return a queryable object `q` such that [`get_domain(q)` is
    expression-equivalent to `get_domain(sch)` and]{.add}
    `get_completion_scheduler<@_CPO_@>(q)` returns a copy of `sch`, where
    _`CPO`_ is either `set_value_t` or `set_stopped_t`. The
    `get_completion_scheduler<set_error_t>` query is not implemented, as the
    scheduler cannot be guaranteed in case an error is thrown while trying to
    schedule work on the given scheduler object. For all other query objects
    _`Q`_ whose type satisfies _`forwarding-query`_, the expression
    `@_Q_@(q, args...)` shall be equivalent to `@_Q_@(get_env(s), args...)`.


[Update __§11.9.6.6 [exec.then]__ (with analogous changes to __§11.9.6.7
[exec.upon.error]__ and __§11.9.6.8 [exec.upon.stopped]__) as follows:]{.ednote}

1. `then` attaches an invocable as a continuation for an input sender's value
    completion operation.

2. The name `then` denotes a customization point object. For some subexpressions
    `s` and `f`, let `S` be `decltype((s))`, let `F` be the decayed type of `f`,
    and let `@[f']{.rm}[f2]{.add}@` be an xvalue refering to an object
    decay-copied from `f`. If `S` does not satisfy `sender`, or `F` does not
    model _`movable-value`_, `then@[(s, f)]{.add}@` is ill-formed. Otherwise,
    the expression `then(s, f)` is expression-equivalent to:

    > <div class="add" style="color: #006e28">
    > ```
    > transform_sender(
    >   @_get-sender-domain_@(s),
    >   @_make-then-sender_@(f, s));
    > ```
    > </div>

    <div class="add" style="color: #006e28">
    where `@_make-then-sender_@(f, s)` is expression-equivalent to
    `@_make-sender_@(then, f, s)` and returns a sender object
    `s2` that behaves as follows:
    </div>

    1. <div class="rm" style="color: #bf0303">
       `tag_invoke(then, get_completion_scheduler<set_value_t>(get_env(s)), s, f)`,
       if that expression is valid.

        * _Mandates:_ The type of the `tag_invoke` expression above satisfies `sender`.
       </div>

    2. <div class="rm" style="color: #bf0303">
       Otherwise, `tag_invoke(then, s, f)`, if that expression is valid.

        * _Mandates:_ The type of the `tag_invoke` expression above satisfies `sender`.
       </div>

    <!-- -->

    1. [Otherwise, constructs a sender `s2`.]{.rm} When `s2` is connected with some
       receiver `out_r`, it:

        1. Constructs a receiver `r` such that:

            1. When `set_value(r, args...)` is called, let `v` be the
                expression `invoke(@[f']{.rm}[f2]{.add}@, args...)`. If `decltype(v)` is `void`,
                calls `set_value(out_r)`; otherwise, it calls
                `set_value(out_r, v)`. If any of these throw an
                exception, it catches it and calls
                `set_error(out_r, current_exception())`. If any of these
                expressions would be ill-formed, the expression
                `set_value(r, args...)` is ill-formed.

            2. `set_error(r, e)` is expression-equivalent to `set_error(out_r, e)`.

            3. `set_stopped(r)` is expression-equivalent to `set_stopped(out_r)`.

        2. Returns an expression-equivalent to `connect(s, r)`.

        3. [Let `@_compl-sig-t_@<Tag, Args...>` name the type
            `Tag()` if `Args...` is a template paramter pack containing the
            single type `void`; otherwise, `Tag(Args...)`.]{.rm} Given
            subexpressions `s2` and `e` where `s2` is a sender returned from
            `then` or a copy of such, let `S2` be `decltype((s2))` and let
            `E` be `decltype((e))`. The type of
            `tag_invoke(get_completion_signatures, s2, e)` shall be [equivalent
            to]{.rm}:

            > ```
            > make_completion_signatures<>
            >   copy_cvref_t<S2, S>, E, @_set-error-signature_@,
            >     @_set-value-completions_@> @[`;`]{.rm}@
            > ```

            where _`set-value-completions`_ is [an alias for]{.rm}[the alias template]{.add}:

            > ```
            > template<class... As>
            >   @_set-value-completions_@ =
            >     @@completion_signatures<[`@_compl-sig-t_@<set_value_t, `]{.rm}[`@_SET-VALUE-SIG_@(invoke_result_t<F, As...>)`]{.add}[`>`]{.rm}>@@
            > ```

            and _`set-error-signature`_ is an alias for
            `completion_signatures<set_error_t(exception_ptr)>` if any of the types
            in the _`type-list`_ named by
            `value_types_of_t<copy_cvref_t<S2, S>, E, @_potentially-throwing_@, @_type-list_@>`
            are `true_type`; otherwise, `completion_signatures<>`, where
            _`potentially-throwing`_ is the [template alias]{.rm}[alias template]{.add}:

            > ```
            > template<class... As>
            >   using @_potentially-throwing_@ =
            >     @[`bool_constant<!is_nothrow_invocable_v<F, As...>>`]{.rm}@
            >     @[`negation<is_nothrow_invocable<F, As...>>`]{.add}@;
            > ```

    2. [If the function selected above]{.rm} [Let `S` be the result of calling
      `then(s, f)` or a copy of such. If `S` is connected with a recevier `R`
      with environment `E` such that
      `transform_sender(@_get-env-domain_@(E), S, E)`]{.add} does not return a
      sender that[:]{.add} [reformated as a list for comprehensibility:]{.ednote}
      
        --- invokes `f` with the value result datums of `s`,

        --- [using]{.rm}[uses]{.add} `f`'s return value as [the sender's]{.rm}
            [`S`'s]{.add} value completion, and

        --- forwards the non-value completion operations [to `R`]{.add}
            unchanged,
            
        then the behavior of calling [`then(s, f)`]{.rm}[`connect(S, R)`]{.add}
        is undefined.



[Change __§11.9.6.9 [exec.let]__ as follows:]{.ednote}

1. `let_value` transforms a sender's value completion into a new child
    asynchronous operation. `let_error` transforms a sender's error completion
    into a new child asynchronous operation. `let_stopped` transforms a sender's
    stopped completion into a new child asynchronous operation.

2. [Copied from below:]{.ednote} Let the expression _`let-cpo`_ be one of `let_value`, `let_error`, or
   `let_stopped` [and let _`set-cpo`_ be the
   completion function that corresponds to _`let-cpo`_ (`set_value` for
   `let_value`, etc.). For subexpressions `se` and `re`, let
   `@_inner-env_@(se, re)` be an environment `e` such that:]{.add}

:::add
> --- `get_domain(e)` is expression-equivalent to the first
>     well-formed expression below:
> 
>   > * `get_domain(se)`
>   > 
>   > * `get_domain(get_completion_scheduler<@_set-cpo-t_@>(se))`, where _`set-cpo-t`_
>   >     is the type of _`set-cpo`_.
>   > 
>   > * `@_get-env-domain_@(re)`
> 
> --- `get_scheduler(e)` is expression-equivalent to the first
>     well-formed expression below:
> 
>   > * `get_completion_scheduler<@_set-cpo-t_@>(se)`
>   > 
>   > * `get_scheduler(re)`
>   >
>   >  or if neither of them are, `get_scheduler(e)` is ill-formed.
> 
> --- For all other query objects _`Q`_ and arguments `args...`,
>   `@_Q_@(E, args...)` is expression-equivalent to `@_Q_@(RE, args...)`.

:::

3. The names `let_value`, `let_error`, and `let_stopped` denote customization
    point objects. [Let the expression _`let-cpo`_ be one of `let_value`,
   `let_error`, or `let_stopped`.]{.rm} For subexpressions `s` and `f`, let `S`
    be `decltype((s))`, let `F` be the decayed type of `f`, and let `f'` be an
    xvalue that refers to an object decay-copied from `f`. If `S` does not
    satisfy `sender`, the expression `@_let-cpo_@(s, f)` is ill-formed. If `F`
    does not satisfy `invocable`, the expression `let_stopped(s, f)` is
    ill-formed. Otherwise, the expression `@_let-cpo_@(s, f)` is
    expression-equivalent to:

    > :::add
    > ```
    > transform_sender(
    >   @_get-sender-domain_@(s),
    >   @_make-let-sender_@(f, s));
    > ```
    > :::

    <div class="add" style="color: #006e28">
    where `@_make-let-sender_@(f, s)` is expression-equivalent to
    `@_make-sender_@(@_let-cpo_@, f, s)` and returns a sender object
    `s2` that behaves as follows:
    </div>

    1. [When `s2` is connected to some receiver `out_r`, it:]{.add}

    <!-- -->

    1. <div class="rm" style="color: #bf0303">
        `tag_invoke(@_let-cpo_@, get_completion_scheduler<set_value_t>(get_env(s)), s, f)`,
        if that expression is valid.
    
        * _Mandates:_ The type of the `tag_invoke` expression above satisfies `sender`.
    </div>
    
    2. <div class="rm" style="color: #bf0303">
        Otherwise, `tag_invoke(@_let-cpo_@, s, f)`, if that expression is valid.
    
        * _Mandates:_ The type of the `tag_invoke` expression above satisfies `sender`.
    </div>

    3. <div class="rm" style="color: #bf0303">Otherwise, given a receiver
        `out_r` and an lvalue `out_r'` refering to an object decay-copied from
        `out_r`.

        1. For `let_value`, let _`set-cpo`_ be `set_value`.
            For `let_error`, let _`set-cpo`_ be `set_error`.
            For `let_stopped`, let _`set-cpo`_ be `set_stopped`.
            Let _`completion-function`_ be one of `set_value`, `set_error`, or `set_stopped`.
            </div>

        <!-- -->

        > 1. [Decay-copies `out_r` into `op_state2` (see below). `out_r2` is
        >    an xvalue refering to the copy of `out_r`.]{.add}
        >    
        > 1. [Let `r` be an rvalue of a receiver type `R`]{.rm}[Constructs a
        >    receiver `r` such that]{.add} such that:
        > 
        >     1. When `@_set-cpo_@(r, args...)` is called, the receiver `r`
        >         decay-copies `args...` into `op_state2` as
        >         `args'...`, then calls `invoke(f', args'...)` resulting in a
        >         sender `s3`. It then calls
        >         `connect(s3, @[std::move(out_r')]{.rm}[out_r3]{.add}@)`,
        >         resulting in an operation state `op_state3`[, where `out_r3` is
        >         a receiver described below]{.add}.
        >         `op_state3` is
        >         saved as a part of `op_state2`. It then calls
        >         `start(op_state3)`. If any of these throws an exception, it
        >         catches it and calls
        >         `set_error(@[std::move(out_r')]{.rm}[out_r2]{.add}@, current_exception())`. If any of
        >         these expressions would be ill-formed, `@_set-cpo_@(r, args...)`
        >         is ill-formed.
        > 
        >     2. `@_[completion-function]{.rm}[CF]{.add}_@(r, args...)` is
        >         expression-equivalent to
        >         [`@_completion-function_@(std::move(out_r'), args...)`
        >         when _`completion-function`_ is different from _`set-cpo`_]{.rm}
        >         [`@_CF_@(out_r2, args...)`,
        >         where _`CF`_ is a completion function other than _`set-cpo`_]{.add}.
        >
        >     3. <div class="add" style="color: #006e28">
        >         `get_env(r)` is expression-equivalent to `get_env(out_r)`.</div>
        >
        >     4. <div class="add" style="color: #006e28">
        >         `out_r3` is a receiver that forwards its completion operations
        >         to `out_r2` and for which `get_env(out_r3)` returns
        >         `@_inner-env_@(get_env(s), get_env(out_r2))`.</div>
        >
        > 2. [`@_let-cpo_@(s, f)` returns a sender `s2` such that:]{.rm}[Calls
        >     `connect(s, r)` resulting in an operation state `op_state2`.]{.add}
        >     [The formatting is changed here.]{.ednote} If the expression
        >     `connect(s, r)` is ill-formed, `connect(s2, out_r)` is ill-formed.
        >
        > 3. [Otherwise, let `op_state2` be the result of `connect(s, r)`.
        >    `connect(s2, out_r)` returns]{.rm}[Returns]{.add} an operation state
        >    `op_state` that stores `op_state2`. `start(op_state)` is expression-equivalent
        >    to `start(op_state2)`.

<!-- -->

4. Given subexpressions `s2` and `e`, where `s2` is a sender returned
    from `@_let-cpo_@(s, f)` or a copy of such, let `S2` be
    `decltype((s2))`, let `E` be `decltype((e))`, and let `DS` be
    `copy_cvref_t<S2, S>`. Then the type of
    `tag_invoke(get_completion_signatures, s2, e)` is specified as
    follows:

    1. If `sender_in<DS, E>` is `false`, the expression
        `tag_invoke(get_completion_signatures, s2, e)` is ill-formed.

    2. Otherwise, let `Sigs...` be the set of template arguments of the
        `completion_signatures` specialization named by `completion_signatures_of_t<DS, E>`,
        let `Sigs2...` be the set of function types in `Sigs...` whose return type
        is _`set-cpo`_, and let `Rest...` be the set of function types
        in `Sigs...` but not `Sigs2...`.

    3. For each `Sig2@<sub>_i_</sub>@` in `Sigs2...`, let
        `Vs@<sub>_i_</sub>@...` be the set of function arguments in
        `Sig2@<sub>_i_</sub>@` and let `S3@<sub>_i_</sub>@` be
        `invoke_result_t<F, decay_t<Vs@<sub>_i_</sub>@>&...>`. If
        `S3@<sub>_i_</sub>@` is ill-formed, [or if
        `@_get-sender-domain_@(declval<S3@<sub>_i_</sub>@>())` has a different
        type than `@_get-sender-domain_@(s)`,]{.add} or if 
        `sender_in<S3@<sub>_i_</sub>@, @[E]{.rm}[E2]{.add}@>`
        is not satisfied [where `E2` is the type of
        `@_inner-env_@(get_env(s), e)`]{.add}, then the expression
        `tag_invoke(get_completion_signatures, s2, e)` is ill-formed.

    4. Otherwise, let `Sigs3@<sub>_i_</sub>@...` be the
        set of template arguments of the `completion_signatures`
        specialization named by
        `completion_signatures_of_t<S3@<sub>_i_</sub>@, @[E]{.rm}[E2]{.add}@>`. Then the type of
        `tag_invoke(get_completion_signatures, s2, e)` shall be equivalent to
        `completion_signatures<Sigs3@<sub>_0_</sub>@..., Sigs3@<sub>_1_</sub>@...,`
        `... Sigs3@<sub>_n-1_</sub>@..., Rest..., set_error_t(exception_ptr)>`,
        where _`n`_ is `sizeof...(Sigs2)`.

:::add
5. Let `s` and `e` be subexpressions such that `S` is `decltype((s))` and `E` is
    `decltype((e))`. If `@_sender-for_@<S, @_let-cpo-t_@>` is `false` where
    _`let-cpo-t`_ is the type of _`let-cpo`_, then the expression
    `@_let-cpo-t_@().transform_env(s, e)` is ill-formed. Otherwise, it is equal
    to `@_inner-env_@(get_env(s), e)`.

:::

<!-- -->
6. If [a sender `S` returned from]{.add} `@_let-cpo_@(s, f)` [is connected to a
    receiver `R` with environment `E` such that
    `transform_sender(@_get-env-domain_@(E), S, E)`]{.add} does not return a
    sender that [reformated as a list for comprehensibility]{.ednote}:
  
    --- invokes `f` when _`set-cpo`_ is called [with `s`'s result datums]{.add}, [and]{.rm}
    
    --- makes its completion dependent on the completion of a sender returned by
        `f`, and
        
    --- propagates the other completion operations sent by `s`,
    
    the behavior of calling [`@_let-cpo_@(s, f)`]{.rm}[`connect(S, R)`]{.add} is
    undefined.



[Change __§11.9.6.10 [exec.bulk]__ as follows:]{.ednote}

1. `bulk` runs a task repeatedly for every index in an index space.

2. The name `bulk` denotes a customization point object. For some subexpressions
    `s`, `shape`, and `f`, let `S` be `decltype((s))`, `Shape` be
    `decltype((shape))`, and `F` be `decltype((f))`. If `S` does not satisfy
    `sender` or `Shape` does not satisfy `integral`, `bulk` is ill-formed.
    Otherwise, the expression `bulk(s, shape, f)` is expression-equivalent to:

    > :::add
    > ```
    > transform_sender(
    >   @_get-sender-domain_@(s),
    >   @_make-bulk-sender_@(@_tuple-like_@{shape, f}, s));
    > ```
    > :::

    <div class="add" style="color: #006e28">

    where `@_make-bulk-sender_@(t, s)` is expression-equivalent to
    `@_make-sender_@(bulk, t, s)` for a subexpression `t` and returns a sender
    object `s2` that behaves as follows:

    </div>

    1. <div class="rm" style="color: #bf0303">
      `tag_invoke(bulk, get_completion_scheduler<set_value_t>(get_env(s)), s, shape, f)`, if that expression is valid.

        * _Mandates:_ The type of the `tag_invoke` expression above satisfies `sender`.
        </div>

    2. <div class="rm" style="color: #bf0303">
      Otherwise, `tag_invoke(bulk, s, shape, f)`, if that expression is valid.

        * _Mandates:_ The type of the `tag_invoke` expression above satisfies `sender`.
        </div>

    <!-- -->

    1. [Otherwise, constructs a sender `s2`.]{.rm} When `s2` is connected with
       some receiver `out_r`, it:

        1. Constructs a receiver `r`:

            1. When `set_value(r, args...)` is called, calls `f(i, args...)` for
                each `i` of type `Shape` from `0` to `shape`, then calls
                `set_value(out_r, args...)`. If any of these throws an
                exception, it catches it and calls
                `set_error(out_r, current_exception())`. [If any of these
                expressions are ill-formed, `set_value(r, args...)` is
                ill-formed.]{.add}

            2. When `set_error(r, e)` is called, calls `set_error(out_r, e)`.

            3. When `set_stopped(r)` is called, calls `set_stopped(out_r, e)`.

        2. Calls `connect(s, r)`, which results in an operation state `op_state2`.

        3. Returns an operation state `op_state` that contains `op_state2`. When
           `start(op_state)` is called, calls `start(op_state2)`.

        4. Given subexpressions `s2` and `e` where `s2` is a sender returned
            from `bulk` or a copy of such, let `S2` be `decltype((s2))`, let
            `E` be `decltype((e))`, let `DS` be `copy_cvref_t<S2, S>`, let `Shape` be
            `decltype((shape))` and let _`nothrow-callable`_ be the alias template:

            > ```
            > template<class... As>
            >   using @_nothrow-callable_@ =
            >     bool_constant<is_nothrow_invocable_v<decay_t<F>&, Shape, As...>>;
            > ```

            1. If any of the types in the _`type-list`_ named by
                `value_types_of_t<DS, E, @_nothrow-callable_@, @_type-list_@>`
                are `false_type`, then the type of
                `tag_invoke(get_completion_signatures, s2, e)` shall be
                [equivalent to]{.rm}:

                ```
                make_completion_signatures<
                  DS, E, completion_signatures<set_error_t(exception_ptr)>>
                ```

            2. Otherwise, the type of `tag_invoke(get_completion_signatures, s2, e)`
                shall be [equivalent to]{.rm} `completion_signatures_of_t<DS, E>`.

    4. [If the function selected above]{.rm} [Let `S` be the result of calling
        `bulk(s, shape, f)` or a copy of such. If `S` is connected to a receiver
        `R` with environment `E` such that
        `transform_sender(@_get-env-domain_@(E), S, E)`]{.add} does not return a
        sender that invokes `f(i, args...)` for each `i` of type `Shape` from
        `0` to `shape` where `args` is a pack of subexpressions refering to the
        value completion result datums of the input sender, or does not execute
        a value completion operation with said datums, the behavior of calling
        [`bulk(s, shape, f)`]{.rm}[`connect(S, R)`]{.add} is undefined.


[Change __§11.9.6.11 [exec.split]__ as follows:]{.ednote}

1. `split` adapts an arbitrary sender into a sender that can be connected
   multiple times.

2. Let _`split-env`_ be the type of an environment such that, given an instance
    `e`, the expression `get_stop_token(e)` is well-formed and has type
    `stop_token`.

3. The name `split` denotes a customization point object. For some subexpression
    `s`, let `S` be `decltype((s))`. If `sender_in<S, @_split-env_@>` or
    `constructible_from<decay_t<env_of_t<S>>, env_of_t<S>>` is `false`, `split`
    is ill-formed. Otherwise, the expression `split(s)` is expression-equivalent
    to:

    > :::add
    > ```
    > transform_sender(
    >   @_get-sender-domain_@(s),
    >   @_make-sender_@(split, s));
    > ```
    > :::

    1. <div class="rm" style="color: #bf0303">
        `tag_invoke(split, get_completion_scheduler<set_value_t>(get_env(s)), s)`,
        if that expression is valid.

        * _Mandates:_ The type of the `tag_invoke` expression above satisfies
          `sender`.
          </div>

    2. <div class="rm" style="color: #bf0303">
        Otherwise, `tag_invoke(split, s)`, if that expression is valid.

        * _Mandates:_ The type of the `tag_invoke` expression above satisfies
          `sender`.
          </div>

    <!-- -->

    1. [Let `s` be a subexpression such that `S` is `decltype((s))`, and let
        `e...` be a pack of subexpressions such that `sizeof...(e) <= 1` is `true`.
        If `@_sender-for_@<S, split_t>` is `false`, then the expression
        `split_t().transform_sender(s, e...)` is ill-formed; otherwise, it returns]{.add}
        [Otherwise, constructs]{.rm} a sender `s2` [, which]{.rm}[that]{.add}:

        1. Creates an object `sh_state` that [... as before]{.ednote}


[Change __§11.9.6.12 [exec.when.all]__ as follows:]

1. `when_all` and `when_all_with_variant` both adapt multiple input senders into
    a sender that completes when all input senders have completed. `when_all`
    only accepts senders with a single value completion signature and on success
    concatenates all the input senders' value result datums into its own value
    completion operation. `when_all_with_variant(s...)` is semantically
    equivilant to `when_all(into_variant(s)...)`, where `s` is a pack of
    subexpressions of sender types.

2. The name[s]{.add} `when_all` [and `when_all_with_variant`]{.add}
   denote[s]{.rm} [a]{.rm} customization point object[s]{.add}. For some
   subexpressions `s@<sub>_i_</sub>@...`, let `S@<sub>_i_</sub>@...` be
   `decltype((s@<sub>_i_</sub>@))...`. The expression[s]{.add}
   `when_all(s@<sub>_i_</sub>@...)` [is]{.rm} [and
   `when_all_with_variant(s@<sub>_i_</sub>@...)` are]{.add} ill-formed if any of
   the following is true:

    * If the number of subexpressions `s@<sub>_i_</sub>@...` is 0,
      or

    * If any type `S@<sub>_i_</sub>@` does not satisfy `sender`.

    * [If the expression `@_get-sender-domain_@(s@<sub>_i_</sub>@)` has a
      different type for any other value of _`i`_.]{.add}

   [Otherwise, those expressions have the semantics specified below.]{.add}

   [The following paragraph becomes numbered and subsequent paragraphs are
   renumbered.]{.ednote}

3. [Otherwise, the]{.rm}[The]{.add} expression `when_all(s@<sub>_i_</sub>@...)` is
    expression-equivalent to:

    > :::add
    > ```
    > transform_sender(
    >   @_get-sender-domain_@(s@<sub>_0_</sub>@),
    >   @_make-when-all-sender_@(s@<sub>_0_</sub>@, ... s@<sub>_n-1_</sub>@))
    > ```
    > :::

    [where
    `@_make-when-all-sender_@(s@<sub>_i_</sub>@...)` is expression-equivalent to
    `@_make-sender_@(when_all, @_unspecified_@, s@<sub>_i_</sub>@...)`
    and returns a sender object `w` of type `W` that behaves as follows:]{.add}

    1. <div class="rm" style="color: #bf0303">
        `tag_invoke(when_all, s@<sub>_i_</sub>@...)`, if
        that expression is valid. If the function selected by `tag_invoke` does
        not return a sender that sends a concatenation of values sent by
        `s@<sub>_i_</sub>@...` when they all complete with
        `set_value`, the behavior of calling
        `when_all(s@<sub>_i_</sub>@...)` is undefined.

        * _Mandates:_ The type of the `tag_invoke` expression above satisfies `sender`.
        </div>

    2. [Otherwise, constructs a sender `w` of type `W`.]{.rm} When `w` is connected
        with some receiver `out_r` of type `OutR`, it returns an operation state
        `op_state` specified as below:

        1. For each sender `s@<sub>_i_</sub>@`, ... [... as before]{.ednote}

        > ...


4. [The name `when_all_with_variant` denotes a customization point object. For
    some subexpressions `s...`, let `S` be `decltype((s))`. If any type
    `S@<sub>_i_</sub>@` in `S...` does not satisfy `sender`,
    `when_all_with_variant` is ill-formed. Otherwise, the]{.rm} [The]{.add}
    expression `when_all_with_variant(s@[<sub>_i_</sub>]{.add}@...)` is
    expression-equivalent to:

    > :::add
    > ```
    > transform_sender(
    >   @_get-sender-domain_@(s@<sub>_0_</sub>@),
    >   @_make-sender_@(when_all_with_variant, @_unspecified_@, s@<sub>_0_</sub>@, ... s@<sub>_n-1_</sub>@))
    > ```
    > :::

:::rm
> 1. `tag_invoke(when_all_with_variant, s...)`, if that expression
>     is valid. If the function selected by `tag_invoke` does not return a
>     sender that, when connected with a receiver of type `R`, sends the types
>     `@_into-variant-type_@<S, env_of_t<R>>...` when they
>     all complete with `set_value`, the behavior of calling
>     `when_all(s@<sub>_i_</sub>@...)` is undefined.
>
>     * _Mandates:_ The type of the `tag_invoke` expression above satisfies `sender`.
>
> 2. Otherwise, `when_all(into_variant(s)...)`.
:::

:::add
5. Let `s` and `e` be subexpressions such that `S` is `decltype((s))`. If
    `@_sender-for_@<S, when_all_with_variant_t>` is `false`, then the expression
    `when_all_with_variant_t().transform_sender(s, e)` is ill-formed; otherwise, it
    is equal to:

    > ```
    > const auto& env = e;
    > auto domain = @_get-env-domain_@(env);
    > auto [tag, data, ...child] = s;
    > auto tfx = @_make-transformer-fn_@(domain, env);
    > return tfx(when_all)(tfx(into_variant)(std::move(child))...);
    > ```

    [This causes the `when_all_with_variant(s...)` sender to become
    `when_all(into_variant(s)...)` when it is connected with a receiver whose
    execution domain does not customize `when_all_with_variant`.]{.note}
:::

5. [For a sender `s2` returned from `when_all` or `when_all_with_variant`,
    `get_env(s2)` shall return an instance of a class equivalent to
    `empty_env`.]{.rm} [Given a pack of subexpressions `s...`, let `S` be an
    object returned from `when_all(s...)` or `when_all_with_variant(s...)` or a
    copy of such, and let `E` be the environment object returned from
    `get_env(S)`. Given a query object `Q`, `tag_invoke(Q, E)` is expression-equivalent to
    `@_get-sender-domain_@(s@<sub>_0_</sub>@)` when `Q` is `get_domain`; otherwise,
    it is ill-formed.]{.add}


[Change __§11.9.6.13 [exec.transfer.when.all]__ as follows:]{.ednote}

1. `transfer_when_all` and `transfer_when_all_with_variant` both adapt multiple
    input senders into a sender that completes when all input senders have
    completed, ensuring the input senders complete on the specified scheduler.
    `transfer_when_all` only accepts senders with a single value completion
    signature and on success concatenates all the input senders' value result
    datums into its own value completion operation;
    `transfer_when_all(@_scheduler_@, @_input-senders_@...)` is semantically
    equivalent to `transfer(when_all(@_input-senders_@...), @_scheduler_@)`.
    `transfer_when_all_with_variant(@_scheduler_@, @_input-senders_@...)` is
    semantically equivilant to
    `transfer_when_all(@_scheduler_@, into_variant(@_intput-senders_@)...)`.
    [These customizable composite algorithms can allow for more efficient
    customizations in some cases.]{.note}

2. The name `transfer_when_all` denotes a customization point object. For some
    subexpressions `sch` and `s...`, let `Sch` be `decltype(sch)` and `S` be
    `decltype((s))`. If `Sch` does not satisfy `scheduler`, or any type
    `S@<sub>_i_</sub>@` in `S...` does not satisfy `sender`, `transfer_when_all`
    is ill-formed. Otherwise, the expression `transfer_when_all(sch, s...)` is
    expression-equivalent to:

    > :::add
    > ```
    > return transform_sender(
    >   @_query-or-default_@(get_domain, sch, default_domain()),
    >   @_make-sender_@(transfer_when_all, sch, s...));
    > ```
    > :::

:::rm
> 1. `tag_invoke(transfer_when_all, sch, s...)`, if that expression is valid.
>     If the function selected by `tag_invoke` does not return a sender that
>     sends a concatenation of values sent by `s...` when they all complete
>     with `set_value`, or does not send its completion operation, other than
>     ones resulting from a scheduling error, on an execution agent belonging
>     to the associated execution resource of `sch`, the behavior of calling
>     `transfer_when_all(sch, s...)` is undefined.
> 
>     * _Mandates:_ The type of the `tag_invoke` expression above satisfies
>       `sender`.
> 
> 2. Otherwise, `transfer(when_all(s...), sch)`.
:::

:::add
3. Let `s` and `e` be subexpressions such that `S` is `decltype((s))`. If
    `@_sender-for_@<S, transfer_when_all_t>` is `false`, then the expression
    `transfer_when_all_t().transform_sender(s, e)` is ill-formed; otherwise, it
    is equal to:

    > ```
    > const auto& env = e;
    > auto domain = @_get-env-domain_@(env);
    > auto [tag, data, ...child] = s;
    > auto tfx = @_make-transformer-fn_@(domain, env);
    > return tfx(transfer)(tfx(when_all)(std::move(child)...), std::move(data));
    > ```

    [This causes the `transfer_when_all(sch, s...)` sender to become
    `transfer(when_all(s...), sch)` when it is connected with a receiver whose
    execution domain does not customize `transfer_when_all`.]{.note}
:::

3. The name `transfer_when_all_with_variant` denotes a customization point
    object. For some subexpressions `sch` and `s...`, let `Sch` be
    `decltype((sch))` and let `S` be `decltype((s))`. If any type
    `S@<sub>_i_</sub>@` in `S...` does not satisfy `sender`,
    `transfer_when_all_with_variant` is ill-formed. Otherwise, the expression
    `transfer_when_all_with_variant(sch, s...)` is expression-equivalent to:

    > :::add
    > ```
    > return transform_sender(
    >   @_query-or-default_@(get_domain, sch, default_domain()),
    >   @_make-sender_@(transfer_when_all_with_variant, sch, s...));
    > ```
    > :::

:::rm
> 1. `tag_invoke(transfer_when_all_with_variant, s...)`, if that expression is
>     valid. If the function selected by `tag_invoke` does not return a sender
>     that, when connected with a receiver of type `R`, sends the types
>     `@_into-variant-type_@<S, env_of_t<R>>...` when they all complete
>     with `set_value`, the behavior of calling
>     `transfer_when_all_with_variant(sch, s...)` is undefined.
> 
>     * _Mandates:_ The type of the `tag_invoke` expression above satisfies
>       `sender`.
> 
> 2. Otherwise, `transfer_when_all(sch, into_variant(s)...)`.
:::

:::add
4. Let `s` and `e` be subexpressions such that `S` is `decltype((s))`. If
    `@_sender-for_@<S, transfer_when_all_with_variantt>` is `false`, then the expression
    `transfer_when_all_with_variant_t().transform_sender(s, e)` is ill-formed; otherwise, it
    is equal to:

    > ```
    > const auto& env = e;
    > auto domain = @_get-env-domain_@(env);
    > auto [tag, data, ...child] = s;
    > auto tfx = @_make-transformer-fn_@(domain, env);
    > return tfx(transfer_when_all)(std::move(data), tfx(into_variant)(std::move(child))...);
    > ```

    [This causes the `transfer_when_all_with_variant(sch, s...)` sender to
    become `transfer_when_all(sch, into_variant(s)...)` when it is connected
    with a receiver whose execution domain does not customize
    `transfer_when_all_with_variant`.]{.note}

:::

5. For a sender `t` returned from `transfer_when_all(sch, s...)` [or
    `transfer_when_all_with_variant(sch, s...)`]{.add}, `get_env(t)` shall
    return a queryable object `q` such that [`get_domain(q)` shall be
    expression-equivalent to `get_domain(sch)`, and]{.add}
    `get_completion_scheduler<@_CPO_@>(q)` returns a copy of `sch`, where
    _`CPO`_ is either `set_value_t` or `set_stopped_t`. The
    `get_completion_scheduler<set_error_t>` query is not implemented, as the
    scheduler cannot be guaranteed in case an error is thrown while trying to
    schedule work on the given scheduler object.




[Change __§11.9.6.14 [exec.into.variant]__ as follows:]{.ednote}

1. `into_variant` adapts a sender with multiple value completion signatures into
    a sender with just one consisting of a `variant` of `tuple`s.

2. The template `@_into-variant-type_@` computes the type sent by
   a sender returned from `into_variant`.

    > ```
    > template<class S, class E>
    >     requires sender_in<S, E>
    >   using @_into-variant-type_@ =
    >     value_types_of_t<S, E>;
    > ```

3. `into_variant` is a customization point object. For some subexpression `s`,
    let `S` be `decltype((s))`. If `S` does not satisfy `sender`,
    `into_variant(s)` is ill-formed. Otherwise, `into_variant(s)` [is
    expression-equivalent to:]{.add}

    > :::add
    > ```
    > transform_sender(
    >   @_get-sender-domain_@(s),
    >   @_make-into-variant-sender_@(s))
    > ```
    > ::: 
    
    [where `@_make-into-variant-sender_@(s)` is expression-equivalent to
    `@_make-sender_@(into_variant, @_unspecified_@, s)` and]{.add}
    returns a
    sender [object]{.add} `s2`[.]{.rm} [that behaves as follows:]{.add}

    [Reformatting here]{.ednote}
    
    1. When `s2` is connected with some receiver `out_r`, it:

      1. Constructs a receiver `r`:

          1. If `set_value(r, ts...)` is called, calls
             `set_value(out_r, @_into-variant-type_@<S, env_of_t<decltype((r))>>(@_decayed-tuple_@<decltype(ts)...>(ts...)))`.
             If this expression throws an exception, calls
             `set_error(out_r, current_exception())`.

          2. `set_error(r, e)` is expression-equivalent to `set_error(out_r, e)`.

          3. `set_stopped(r)` is expression-equivalent to `set_stopped(out_r)`.

      2. Calls `connect(s, r)`, resulting in an operation state `op_state2`.

      3. Returns an operation state `op_state` that contains `op_state2`. When
         `start(op_state)` is called, calls `start(op_state2)`.

    2. Given subexpressions `s2` and `e` [...] [...as before]{.ednote}




[Change __§11.9.6.15 [exec.stopped.as.optional]__ as follows:]{.ednote}

1. `stopped_as_optional` maps an input sender's stopped completion operation
   into the value completion operation as an empty optional. The input sender's
   value completion operation is also converted into an optional. The result is
   a sender that never completes with stopped, reporting cancellation by
   completing with an empty optional.

2. The name `stopped_as_optional` denotes a customization point object. For some
   subexpression `s`, let `S` be `decltype((s))`. [Let
   `_get-env-sender_` be an expression such that, when it is
   `connect`ed with a receiver `r`, `start` on the resulting operation state
   completes immediately by calling `set_value(r, get_env(r))`.]{.rm} The expression
   `stopped_as_optional(s)` is expression-equivalent to:

    > :::add
    > ```
    > transform_sender(
    >   @_get-sender-domain_@(s),
    >   @_make-sender_@(stopped_as_optional, @_unspecified_@, s))
    > ```
    > :::

    > :::rm
    > ```
    > let_value(
    >   @_get-env-sender_@,
    >   []<class E>(const E&) requires @_single-sender_@<S, E> {
    >     return let_stopped(
    >       then(s,
    >         []<class T>(T&& t) {
    >           return optional<decay_t<@_single-sender-value-type_@<S, E>>>{
    >             std::forward<T>(t)
    >           };
    >         }
    >       ),
    >       [] () noexcept {
    >         return just(optional<decay_t<@_single-sender-value-type_@<S, E>>>{});
    >       }
    >     );
    >   }
    > )
    > ```
    > :::

:::add
3. Let `s` and `e` be subexpressions such that `S` is `decltype((s))` and `E`
   is `decltype((e))`. If either `@_sender-for_@<S, stopped_as_optional_t>`
   or `@_single-sender_@<S, E>` is `false`, then the expression
   `stopped_as_optional_t().transform_sender(s, e)` is ill-formed; otherwise,
   it is equal to:

    > ```
    > const auto& env = e;
    > auto domain = @_get-env-domain_@(env);
    > auto [tag, data, child] = s;
    > using V = @_single-sender-value-type_@<S, E>;
    > auto tfx = @_make-transformer-fn_@(domain, env);
    > return tfx(let_stopped)(
    >     tfx(then)(std::move(child),
    >               []<class T>(T&& t) { return optional<V>(std::forward<T>(t)); }),
    >     []() noexcept { return just(optional<V>()); });
    > ```
:::

[Change __§11.9.6.16 [exec.stopped.as.error]__ as follows:]{.ednote}

1. `stopped_as_error` maps an input sender's stopped completion operation into
    an error completion operation as a custom error type. The result is a sender
    that never completes with stopped, reporting cancellation by completing with
    an error.

2. The name `stopped_as_error` denotes a customization point object. For some
   subexpressions `s` and `e`, let `S` be `decltype((s))` and let `E` be
   `decltype((e))`. If the type `S` does not satisfy `sender` or if the type `E`
   doesn't satisfy _`movable-value`_, `stopped_as_error(s, e)` is ill-formed.
   Otherwise, the expression `stopped_as_error(s, e)` is expression-equivalent
   to:

    > :::rm
    > ```
    > let_stopped(s, [] { return just_error(e); })
    > ```
    > :::

    > :::add
    > ```
    > transform_sender(
    >   @_get-sender-domain_@(s),
    >   @_make-sender_@(stopped_as_error, e, s))
    > ```
    > :::

:::add
3. Let `s` and `e` be subexpressions such that `S` is `decltype((s))` and `E` is
   `decltype((e))`. If `@_sender-for_@<S, stopped_as_error_t>` is `false`, then
   the expression `stopped_as_error_t().transform_sender(s, e)` is
   ill-formed; otherwise, it is equal to:
   
    > ```
    > const auto& env = e;
    > auto domain = @_get-env-domain_@(env);
    > auto [tag, data, child] = s;
    > auto tfx = @_make-transformer-fn_@(domain, env);
    > return tfx(let_stopped)(
    >     std::move(child),
    >     [err = std::move(data)]() mutable { return just_error(std::move(err)); });
    > ```   

:::

[Change __§11.9.6.17 [exec.ensure.started]__ as follows:]{.ednote}

1. `ensure_started` eagerly starts the execution of a sender, returning a sender
    that is usable as intput to additional sender algorithms.

2. Let _`ensure-started-env`_ be the type of an execution
    environment such that, given an instance `e`, the expression
    `get_stop_token(e)` is well-formed and has type `stop_token`.

2. The name `ensure_started` denotes a customization point object.
    For some subexpression `s`, let `S` be `decltype((s))`. If
    `sender_in<S, @_ensure-started-env_@>` or
    `constructible_from<decay_t<env_of_t<S>>, env_of_t<S>>` is
    `false`, `ensure_started(s)` is ill-formed. Otherwise, the
    expression `ensure_started(s)` is expression-equivalent to:

    > :::add
    > ```
    > transform_sender(
    >   @_get-sender-domain_@(s),
    >   @_make-sender_@(ensure_started, s));
    > ```
    > :::

:::rm
>  1. `tag_invoke(ensure_started, get_completion_scheduler<set_value_t>(get_env(s)), s)`,
>     if that expression is valid.
>
>      * _Mandates:_ The type of the `tag_invoke` expression above satisfies
>        `sender`.
>
>  2. Otherwise, `tag_invoke(ensure_started, s)`, if that expression is valid.
>
>      * _Mandates:_ The type of the `tag_invoke` expression above satisfies
>        `sender`.

:::

<!-- -->

> 1. [Let `s` be a subexpression such that `S` is `decltype((s))`, and let
>     `e...` be a pack of subexpressions such that `sizeof...(e) <= 1` is
>     `true`. If `@_sender-for_@<S, ensure_started_t>` is `false`, then the
>     expression `ensure_started_t().transform_sender(s, e...)` is ill-formed;
>     otherwise, it returns]{.add} [Otherwise, constructs]{.rm} a sender `s2` [,
>     which]{.rm}[that]{.add}:
>
>     1. Creates an object `sh_state` that [... as before]{.ednote}

[Change __§11.9.7.1 [exec.start.detached]__ as follows:]{.ednote}

1. `start_detached` eagerly starts a sender without the caller needing to manage
   the lifetimes of any objects.

2. The name `start_detached` denotes a customization point object. For some
    subexpression `s`, let `S` be `decltype((s))`. If `S` does not satisfy
    [`sender`]{.rm}[`sender_in<empty_env>`]{.add}, `start_detached` is
    ill-formed. Otherwise, the expression `start_detached(s)` is
    expression-equivalent to:

    > :::add
    > ```
    > apply_sender(@_get-sender-domain_@(s), start_detached, s)
    > ```
    > :::

:::add
> * _Mandates:_ The type of the expression above is `void`.
:::

> If the [function selected]{.rm}[expression]{.add} above does not eagerly start
> the sender `s` after connecting it with a receiver that ignores value and
> stopped completion operations and calls `terminate()` on error completions,
> the behavior of calling `start_detached(s)` is undefined.

:::rm
> 1. `tag_invoke(start_detached, get_completion_scheduler<set_value_t>(get_env(s)), s)`,
>    if that expression is valid.
> 
>     * _Mandates:_ The type of the `tag_invoke` expression above is `void`.
> 
> 2. Otherwise, `tag_invoke(start_detached, s)`, if that expression is valid.
> 
>     * _Mandates:_ The type of the `tag_invoke` expression above is `void`.
>
> 3. Otherwise, let `R` be the type of a receiver, let `r` be an rvalue of type `R`, and let
>    `cr` be a lvalue reference to `const R` such that:
>
>    --- The expression `set_value(r)` is not potentially-throwing and has no effect,
>
>    --- For any subexpression `e`, the expression `set_error(r, e)` is expression-equivalent
>        to `terminate()`,
>
>    --- The expression `set_stopped(r)` is not potentially-throwing and has no effect, and
>
>    --- The expression `get_env(cr)` is expression-equivalent to `empty_env{}`.
>
>    Calls `connect(s, r)`, resulting in an operation state `op_state`, then calls
>    `start(op_state)`.
:::

:::add
3. Let `s` be a subexpression such that `S` is `decltype((s))`, and let
    _`detached-receiver`_ and _`detached-operation`_ be the following
    exposition-only class types:

    > ```
    > struct @_detached-receiver_@ {
    >   using is_receiver = @_unspecified_@;
    >   @_detached-operation_@* @_op_@; @_// exposition only_@
    >    
    >   friend void tag_invoke(set_value_t, @_detached-receiver_@&& self) noexcept { delete self.@_op_@; }
    >   friend void tag_invoke(set_error_t, @_detached-receiver_@&&, auto&&) noexcept { terminate(); }
    >   friend void tag_invoke(set_stopped_t, @_detached-receiver_@&& self) noexcept { delete self.@_op_@; }
    >   friend empty_env tag_invoke(get_env_t, const @_detached-receiver_@&) noexcept { return {}; }
    > };
    > 
    > struct @_detached-operation_@ {
    >   connect_result_t<S, @_detached-receiver_@> @_op_@; @_// exposition only_@
    > 
    >   explicit @_detached-operation_@(S&& s)
    >     : @_op_@(connect(std::forward<S>(s), @_detached-receiver_@{this}))
    >   {}
    > };
    > ```

    If `sender_to<S, @_detached-receiver_@>` is `false`, then the
    expression `start_detached_t().apply_sender(s)` is ill-formed; otherwise, it
    is expression-equivalent to:

    > ```
    > start((new @_detached-operation_@(s))->@_op_@)
    > ```

:::


[Change __§11.9.7.2 [exec.sync.wait]__ as follows:]{.ednote}

1. [...]

<!-- -->

4. The name `this_thread::sync_wait` denotes a customization point object. For
    some subexpression `s`, let `S` be `decltype((s))`. If
    `sender_in<S, @_sync-wait-env_@>` is `false`, or [the number of the arguments
    `completion_signatures_of_t<S, @_sync-wait-env_@>::value_types` passed into
    the `Variant` template parameter is not 1]{.rm} [if the type
    `completion_signatures_of_t<S, @_sync-wait-env_@, @_type-list_@, type_identity_t>`
    is ill-formed]{.add}, `this_thread::sync_wait(s)` is ill-formed. Otherwise,
    `this_thread::sync_wait(s)` is expression-equivalent to:

> > :::add
> > ```
> > apply_sender(@_get-sender-domain_@(s), sync_wait, s)
> > ```
> > :::

:::add
> * _Mandates:_ The type of expression above is
>   `@_sync-wait-type_@<S, @_sync-wait-env_@>`.
:::


:::rm
> 1. `tag_invoke(this_thread::sync_wait, get_completion_scheduler<set_value_t>(get_env(s)), s)`,
>     if this expression is valid.
> 
>     * _Mandates:_ The type of the `tag_invoke` expression above is `@_sync-wait-type_@<S, @_sync-wait-env_@>`.
> 
> 2. Otherwise, `tag_invoke(this_thread::sync_wait, s)`, if this expression is valid and its type is.
> 
>     * _Mandates:_ The type of the `tag_invoke` expression above is `@_sync-wait-type_@<S, @_sync-wait-env_@>`.
:::

5. [Otherwise:]{.rm} [Let _`sync-wait-receiver`_ be a class type that satisfies
    `receiver`, let `r` be an xvalue of that type, and let `cr` be a const lvalue
    refering to `r` such that `get_env(cr)` has type _`sync-wait-env`_.
    If `sender_in<S, @_sync-wait-env_@>` is `false`, or if the type
    `completion_signatures_of_t<S, @_sync-wait-env_@, @_type-list_@, type_identity_t>`
    is ill-formed, the expression `sync_wait_t().apply_sender(s)` is ill-formed;
    otherwise, it has the following effects:]{.add}

    1. [Constructs a receiver `r`.]{.rm}

    2. Calls `connect(s, r)`, resulting in an operation state `op_state`,
        then calls `start(op_state)`.

    3. Blocks the current thread until a completion operation of `r` is
        executed. When it is:

        1. If `set_value(r, ts...)` has been called, returns
            `@_sync-wait-type_@<S, @_sync-wait-env_@>{@_decayed-tuple_@<decltype(ts)...>{ts...}}`.
            If that expression exits exceptionally, the exception is propagated
            to the caller of `sync_wait`.

        2. If `set_error(r, e)` has been called, let `E` be the decayed type
            of `e`. If `E` is `exception_ptr`, calls
            `std::rethrow_exception(e)`. Otherwise, if the `E` is
            `error_code`, throws `system_error(e)`. Otherwise, throws `e`.

        3. If `set_stopped(r)` has been called, returns
            `@_sync-wait-type_@<S, @_sync-wait-env_@>{}`.

5. The name `this_thread::sync_wait_with_variant` denotes a customization point
    object. For some subexpression `s`, let `S` be the type of
    `into_variant(s)`. If `sender_in<S, @_sync-wait-env_@>` is `false`,
    `this_thread::sync_wait_with_variant(s)` is ill-formed. Otherwise,
    `this_thread::sync_wait_with_variant(s)` is expression-equivalent to:

> > :::add
> > ```
> > apply_sender(@_get-sender-domain_@(s), sync_wait_with_variant, s)
> > ```
> > :::

:::add
> * _Mandates:_ The type of expression above is
>   `@_sync-wait-with-variant-type_@<S, @_sync-wait-env_@>`.
:::


:::rm
> 1. `tag_invoke(this_thread::sync_wait_with_variant, get_completion_scheduler<set_value_t>(get_env(s)), s)`,
>     if this expression is valid.
> 
>     * _Mandates:_ The type of the `tag_invoke` expression above is
>       `@_sync-wait-with-variant-type_@<S, @_sync-wait-env_@>`.
> 
> 2. Otherwise, `tag_invoke(this_thread::sync_wait_with_variant, s)`, if this
>     expression is valid.
> 
>     * _Mandates:_ The type of the `tag_invoke` expression above is
>       `@_sync-wait-with-variant-type_@<S, @_sync-wait-env_@>`.
:::


6. [Otherwise,]{.rm}[The expression `sync_wait_with_variant_t().apply_sender(s)` is
    expression-equivalent to]{.add} `this_thread::sync_wait(into_variant(s))`.


[Update __§11.10 [exec.execute]__ as follows:]

1. `execute` creates fire-and-forget tasks on a specified scheduler.

2. The name `execute` denotes a customization point object. For some
    subexpressions `sch` and `f`, let `Sch` be `decltype((sch))` and `F` be
    `decltype((f))`. If `Sch` does not satisfy `scheduler` or `F` does not
    satisfy `invocable`, `execute` is ill-formed. Otherwise, `execute` is
    expression-equivalent to:

    > :::add
    > ```
    > apply_sender(
    >   @_query-or-default_@(get_domain, sch, default_domain()),
    >   execute, schedule(sch), f)
    > ```
    > :::

:::add
> * _Mandates:_ The type of the expression above is `void`.
:::

:::rm
> 1. `tag_invoke(execute, sch, f)`, if that expression is valid. If
>     the function selected by `tag_invoke` does not invoke the function `f`
>     (or an object decay-copied from `f`) on an execution agent belonging to
>     the associated execution resource of `sch`, or if it does not call
>     `std::terminate` if an error occurs after control is returned to the
>     caller, the behavior of calling `execute`
>     is undefined.
> 
>     * <i>Mandates:</i> The type of the `tag_invoke` expression above is `void`.

:::

3. [Otherwise,]{.rm} [For some subexpressions `s` and `f` where `F` is
    `decltype((f))`, if `F` does not satisfy `invocable`, the expression
    `execute_t().apply_sender(s, f)` is ill-formed; otherwise, it is
    expression-equivalent to]{.add}
    `start_detached(then(@[schedule(sch)]{.rm}[s]{.add}@, f))`.


---
references:
  - id: stdexecgithub
    citation-label: stdexecgithub
    title: "stdexec"
    url: https://github.com/NVIDIA/stdexec
  - id: P2300R7
    citation-label: P2300R7
    type: paper
    title: "`std::execution`"
    author:
      - given: Michał
        family: Dominiak
        email:  griwes@griwes.info
      - given: Georgy
        family: Evtushenko
        email:  evtushenko.georgy@gmail.com
      - given: Lewis
        family: Baker
        email:  lewissbaker@gmail.com
      - given: Lucian Radu
        family: Teodorescu
        email: lucteo@lucteo.ro
      - given: Lee
        family: Howes
        email:  xrikcus@gmail.com
      - given: Kirk
        family: Shoop
        email:  kirk.shoop@gmail.com
      - given: Michael
        family: Garland
        email:  mgarland@nvidia.com
      - given: Eric
        family: Niebler
        email:  eric.niebler@gmail.com
      - given: Bryce Adelstein
        family: Lelbach
        email: brycelelbach@gmail.com
    url: https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2300r7.html
---
