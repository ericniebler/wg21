---
title: "A Utility for Creating Execution Environments"
document: P3325R0
date: today
audience:
  - "LEWG Library Evolution"
author:
  - name: Eric Niebler
    email: <eric.niebler@gmail.com>
toc: true
---

<div style="text-align: right;">
_"The environment is everything that isn't me."_<br/>
--- Albert Einstein
</div>

Introduction
============

Execution environments are a fundamental part of the `std::execution` proposal,
[@P2300R9], but that paper provides no utility for creating or manipulating
environments. Such utilities are increasingly necessary considering that some
proposed APIs (e.g., `write_env` from [@P3284R0]) require passing an environment.

This paper proposes two simple utility for creating an execution environments:
one to create an environment out of a query/value pair, and another to join
multiple environments into one.

Executive Summary
=================

This paper proposes the following changes to P2300R9:

* Add a class template provisionally called `prop` to the `std::execution`
  namespace. `prop` associates a query `Q` with a value `V`, yielding a
  *`queryable`* object `E` such that `Q(E)` is equal to `V`.

* Add a class template provisionally called `env` to the `std::execution`
  namespace. `env` aggregates several environments into one, giving precedence
  to the environments in lexical order.

* Optionally, replace `empty_env` with `env<>`.

Discussion
==========

Motivation
----------

In [@P2300R9], execution environments are an internal implementation detail of
the sender algorithms. There are no public-facing APIs that accept environment
objects as a parameter. One may wonder why a utility for constructing
environments is even necessary.

There are several reasons why the Standard Library would benefit from a utility
to construct an environment:

1. The set of sender algorithms is openly extensible. For those who decide to
    implement their own sender algorithms, the manipulation of execution
    environments is part of the job. Standard utilities will make this easier.

2. [@P3284R0] proposes a `write_env` sender adaptor that merges a user-specified
    environment with the environment of the receiver to which the sender is
    eventually connected. Using this adaptor requires the user to construct an
    environment. Although implementing an environment is not hard, an
    out-of-the-box solution will make using `write_env` simpler.

3. [@P3149R3] proposes two new algorithms, `spawn` and `spawn_future`, both of
    which can be parameterized by passing an environment as an optional
    argument.

4. Currently, there is no way to parameterize algorithms like `sync_wait` and
    `start_detached`. The author intends to bring a paper proposing overloads of
    those functions that accept environments as a way to inject things like stop
    tokens, allocators, and schedulers into the asynchronous operations that
    those algorithms launch.

In short, environments are how users will inject dependencies into async
computations. We can expect to see more APIs that will require (or will
optionally allow) the user to pass an environment. Thus, a standard utility for
making environments is desirable.

Design Considerations
---------------------

### Singleton Environments

Now that `tag_invoke` has been removed from P2300, defining an execution
environment is quite simple. To build an environment with a single query/value
pair, the following suffices:

```c++
template <class Query, class Value>
struct prop
{
  [[no_unique_address]] Query query_;
  Value value_;

  auto query(Query) const noexcept -> const Value &
  {
    return value_;
  }
};

// Example usage:
constexpr auto my_env = prop(get_allocator, std::allocator{});
```

Although simple, this template has some nice properties:

1. It is an aggregate so that members can be direct initialized from
    temporaries without so much as a move. A function that constructs and
    returns an environment using `prop` will benefit from RVO:

    ```c++
    // The frobnicator object will be constructed directly in
    // the callers stack frame:
    return prop(get_frobnicator, make_a_frobnicator());
    ```

2. An object constructed like `prop(get_allocator, my_allocator{})` will
    have the simple and unsurprising type
    `prop<get_allocator_t, my_allocator>`.

The `prop` utility proposed in this paper is only slightly more elaborate than
the `prop` class template shown above, and it shares these properties.

### Environment Composition

What if you need to construct an environment with more than one query/value
pair, say, an allocator and a scheduler? A utility to join multiple environments
would work together with `prop` described above to make a general
environment-building utility. This paper calls that utility `env`.

The following code demonstrates:

```c++
template <class Env, class Query>
concept _@*`has-query`*@ = requires (const Env& env) { env.query(Query()); };

template <class... Envs>
struct env : Envs...
{
  template <class Query>
  static constexpr size_t _index_of() {
    constexpr bool flags[] = {_@*`has-query`*@<Envs, Query>...};
    return ranges::find(flags, true) - flags;
  }

  template <class Query>
    requires (_@*`has-query`*@<Envs, Query> ||...)
  decltype(auto) query(Query q) const noexcept(...)
  {
    auto tup = tie(static_cast<const Envs&>(*this)...);
    return get<_index_of<Query>()>(tup).query(q);
  }
};

template <class... Envs>
env(Envs...) -> env<Envs...>;

// Example usage:
constexpr auto my_env = env(prop(get_allocator, my_alloc{}),
                            prop(get_scheduler, my_sched{}));
```

This `env` class template shares the desirable properties of `prop`: aggregate
initialization and unsprising naming. A query is handled by the "leftmost" child
environment that can handle it.

Note that the above code has the issue that two child environments cannot have
the same type. That is not a limitation of the facility proposed below.

### By Value vs. By Reference

There are times when you would like an environment to respond to a query with a
reference to a particular object rather than a copy. Capturing a reference is
dangerous, so the opt-in to reference semantics should be explicit.

`std::reference_wrapper` is how the Standard Library deals with such
problems. It should be possible to construct an environment using
`std::ref` to specify that the "value" should be stored by reference:

```c++
std::mutex mtx;
const auto my_env = prop(get_mutex, std::ref(mtx));
std::mutex & ref = get_mutex(my_env);
assert(&ref == &mtx);
```

Similarly, there are times when you would like to store the child environment by
reference. `std::ref` should work for that case as well:

```c++
// At namespace scope, construct a reusable environment:
constexpr auto global_env = prop(get_frobnicator, make_frobnicator());

// Construct an environment with a particular value for the get_allocator
// query, and a reference to the constexpr global_env:
auto env_with_allocator(auto alloc)
{
  return env(prop(get_allocator, alloc), std::ref(global_env));
}
```

The utility proposed in this paper satisfies all of the above use cases.

Naming
------

For the `prop` utility, a couple of other plausible names come to mind:

- `attr`
- `with`
- `property`
- `key_value`
- `query_value`

Other possibile names for `env` are:

- `attributes`, or `attrs`
- `properties`, or `props`
- `dictionary`, or `dict`

Implementation Experience
=========================

Types with a very similar designs have seen heavy use in `stdexec` for over two
years. The design proposed below has been prototyped and can be found
on [godbolt.org](https://godbolt.org/z/rY5E8bKor)[^1].

[^1]: [https://godbolt.org/z/rY5E8bKor](https://godbolt.org/z/rY5E8bKor)


Future Extensions
=================

There are several ways this utility might be extended in the future:

- Add a way to _remove_ a query from an environment.
- Add a wrapper for a reference to an environment.
- Add a wrapper that only accepts queries that are _forwarding_ (see
  [[exec.fwd.env]](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r9.html#spec-execution.forwarding_query)).


Proposed Wording
================

[Replace all occurances of `empty_env` with `env<>`. Change [exec.syn] as
follows:]{.ednote}

> <b>Header `<execution>` synopsis [exec.syn]</b>
>
> ```
> namespace std::execution {
>   @*...as before...*@
>
>   @[`struct empty_env {};`]{.rm}@
>   struct get_env_t { see below };
>   inline constexpr get_env_t get_env{};
>
>   template<class T>
>     using env_of_t = decltype(get_env(declval<T>()));
>
>   @[*`// [exec.prop] class template prop`*]{.add}@
>   @[`template<class Query, class Value>`]{.add}@
>     @[`struct prop;`]{.add}@
>
>   @[*`// [exec.env] class template env`*]{.add}@
>   @@[`template<@_queryable_@... Envs>`]{.add}@@
>     @[`struct env;`]{.add}@
>
>   @*// [exec.domain.default], execution domains*@
>   struct default_domain;
>
>   @*// [exec.sched], schedulers*@
>   struct scheduler_t {};
>
>   @*...as before...*@
> }
> ```


[After [exec.utils], add a new subsection [exec.envs] as follows:]{.ednote}


:::add

> <b>34.12 Queryable utilities [exec.envs]</b>
>
> <b>34.12.1 Class template `prop` [exec.prop]</b>
>
> ```c++
> namespace std::execution {
>   template<class Query, class Value>
>   struct prop {
>     [[no_unique_address]] Query @*query*@;    @*// exposition only*@
>     [[no_unique_address]] Value @*value*@;    @*// exposition only*@
>
>     [[nodiscard]] constexpr const Value& query(Query) const noexcept {
>       return @*value*@;
>     }
>   };
>
>   template<class Query, class Value>
>   prop(Query, Value) -> prop<Query, unwrap_reference_t<Value>>;
> }
> ```
>
> 1. Class template `prop` is for building a queryable object from a
>    query object and a value.
>
> 2. [*Example 1:*
>
> >  ```
> >  template<sender Sndr>
> >  sender auto parameterize_work(Sndr sndr) {
> >    @*`// Make an environment such that get_allocator(env) returns a reference to a copy`*@
> >    @*`// of my_alloc{}`*@
> >    auto e = prop(get_allocator, my_alloc{});
> >
> >    @*`// parameterize the input sender so that it will use our custom execution environment`*@
> >    return write_env(sndr, e);
> >  }
> >  ```
> >
> >  --- *end example*]
>
> <b>34.12.2 Class template `env` [exec.env]</b>
>
> ```c++
> namespace std::execution {
>   template<class Env, class Query, class... Args>
>     concept @_has-query_@ =                   @_// exposition only_@
>       requires (const Env& env, Args&&... args) {
>         env.query(Query(), std::forward<Args>(args)...);
>       };
>
>   template<class Env>
>     using @_wrap-env_@ = @_see below_@; @_// exposition only_@
>
>   template<@*`queryable`*@... Envs>
>   struct env : @_AS-BASE-ENVS_@(Envs...) {
>     template<class Query, class... Args>
>     constexpr decltype(auto) @*`get-first`*@() const noexcept {  @_// exposition only_@
>       constexpr bool flags[] = {@*`has-query`*@<Envs, Query, Args...>...};
>       constexpr size_t idx = ranges::find(flags, true) - flags;
>       auto tup = tie(static_cast<const @_wrap-env_@<Envs>&>(*this)...);
>       return get<idx>(tup);
>     }
>
>     template<class Query, class... Args>
>       requires (@*`has-query`*@<Env, Query, Args...> ||...)
>     [[nodiscard]] constexpr decltype(auto) query(Query q, Args&&... args) const
>       noexcept(noexcept(@*`get-first`*@<Query, Args...>().query(q, std::forward<Args>(args)...))) {
>       return @*`get-first`*@<Query, Args...>().query(q, std::forward<Args>(args)...);
>     }
>   };
>
>   template<class... Envs>
>     env(Envs...) -> env<unwrap_reference_t<Envs>...>;
> }
> ```
>
> 1. The class template `env` is used to construct a queryable object from
>     several queryable objects. Query invocations on the resulting object are
>     resolved by attempting to query each subobject in lexical order.
>
> 2. For a type `Env`, `@_wrap-env_@<Env>` is an alias for `Env` if `Env` is
>     an object type. Otherwise, it is an alias for `@_ref-env_@<Env>`,
>     where _`ref-env`_ is the following class template:
>
>     ```c++
>     template<class Env> struct @_ref-env_@;
>
>     template<class Env>
>     struct @_ref-env_@<Env&> {
>       constexpr @_ref-env_@(reference_wrapper<Env> r) noexcept : @_env_@(r) {}
>
>       template<class Query, class... Args>
>         requires @_has-query_@<Env, Query, Args...>
>       constexpr decltype(auto) query(Query q, Args&&... args) const
>         noexcept(noexcept(@_env_@.query(q, std::forward<Args>(args)...))) {
>         return @_env_@.query(q, std::forward<Args>(args)...);
>       }
>
>       Env& @_env_@; @_// exposition only_@
>     };
>     ```
>
> 3. Given a pack of types `Ts`, `@_AS-BASE-ENVS_@(Ts)` is a pack of types
>    `Us` such that `sizeof...(Ts) == sizeof...(Us)` is `true` where each
>    type `U@<sub>_n_</sub>@` in the pack is computed as follows:
>
>    1. If there is no type `T@<sub>_m_</sub>@` such that
>       `same_as<T@<sub>_m_</sub>@, T@<sub>_n_</sub>@>` is `true` for _`m`_
>       in the range `0` to `@_n_@-1` inclusive, then `U@<sub>_n_</sub>@`
>       is `@_wrap-env_@<T@<sub>_n_</sub>@>`.
>
>    2. Otherwise, `U@<sub>_n_</sub>@` denotes a unique unspecified class type
>       _`X`_ defined as follows:
>
>        ```c++
>        struct @_X_@ {
>          constexpr @_X_@(auto&&) noexcept {}
>          auto query(auto) const = delete;
>        };
>        ```
>
> 4. [*Example 1:*
>
> >  ```
> >  template<sender Sndr>
> >  sender auto parameterize_work(Sndr sndr) {
> >    @*`// Make an environment such that:`*@
> >    @*`//  - get_allocator(env) returns a reference to a copy of my_alloc{}`*@
> >    @*`//  - get_scheduler(env) returns a reference to a copy of my_sched{}`*@
> >    auto e = env(prop(get_allocator, my_alloc{}),
> >                 prop(get_scheduler, my_sched{}));
> >
> >    @*`// parameterize the input sender so that it will use our custom execution environment`*@
> >    return write_env(sndr, e);
> >  }
> >  ```
> >
> >  --- *end example*]
>

:::

Acknowledgements
================

I would like to thank Lewis Baker for many enlightening conversations about the
design of execution environments. The design presented here owes much to Lewis's
insights.
